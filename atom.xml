<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Interstellar</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="965087276.github.io/"/>
  <updated>2020-06-02T03:31:13.540Z</updated>
  <id>965087276.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CMU 15-213 实验1: Data Lab</title>
    <link href="965087276.github.io/2020/05/31/CMU-15-213-%E5%AE%9E%E9%AA%8C1-Data-Lab/"/>
    <id>965087276.github.io/2020/05/31/CMU-15-213-实验1-Data-Lab/</id>
    <published>2020-05-31T01:29:59.000Z</published>
    <updated>2020-06-02T03:31:13.540Z</updated>
    
    <content type="html"><![CDATA[<p>Data Lab 都是与位运算相关的一些题目，总共有13个题。每个题都是按要求实现一个函数，题目中规定了可以使用的操作符（不能使用规定之外的操作），并对使用次数作出了限制，要求就是用这些给定的操作符，在一定次数内，完成函数所要实现的功能。</p><h1 id="整数部分"><a href="#整数部分" class="headerlink" title="整数部分"></a>整数部分</h1><p>整数部分的题目限制比较多：不允许使用条件与循环，不能使用大于8 bit 的常数，也不能使用数组、结构体等结构。</p><h2 id="1-bitXor"><a href="#1-bitXor" class="headerlink" title="1. bitXor"></a>1. bitXor</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * bitXor - x^y using only ~ and &amp; </span></span><br><span class="line"><span class="comment"> *   Example: bitXor(4, 5) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp;</span></span><br><span class="line"><span class="comment"> *   Max ops: 14</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitXor</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// exclude x’s bit is 1 and y's bit is 1</span></span><br><span class="line">    <span class="keyword">int</span> allOne = ~(x &amp; y);</span><br><span class="line">    <span class="comment">// exclude x’s bit is 0 and y's bit is 0</span></span><br><span class="line">    <span class="keyword">int</span> allZero = ~(~x &amp; ~y);</span><br><span class="line">    <span class="comment">// neither (x’s bit is 1 and y's bit is 1) nor (x’s bit is 0 and y's bit is 0)</span></span><br><span class="line">    <span class="keyword">return</span> allOne &amp; allZero;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一题要用 <code>~</code> 和 <code>&amp;</code> 两个符号实现两个数的 <code>异或</code> 操作。</p><p><strong>思路：</strong> 通过逆向法，使用一个各个 bit 均为 1 的数 $ans = (2^{31}-1)$，找出 <code>x, y</code> 相应位置均为 1 的 bit 和 <code>x, y</code> 相应位置均为 0 的 bit，在 <code>ans</code> 中这些 bit 设为 0，剩余的结果即为 <code>x ^ y</code>。</p><p>上面代码中，<code>allOne = ~(x &amp; y)</code> 相当于 $(2^{31} - 1)$ 排除掉 <code>x, y</code> 相应位置均为 1 的 bit 后的结果；<code>allZero = ~(~x &amp; ~y)</code> 是将 <code>x, y</code> 相应位置均为 0 的 bit 设置为 0 ，其它位置设为 1；<code>allOne</code> 再通过与 <code>allZero</code> 按位 and 后便将 <code>x, y</code> 均为 0 的 bit 排除掉了，剩下的便是 <code>x ^ y</code> 。</p><h2 id="2-tmin"><a href="#2-tmin" class="headerlink" title="2. tmin"></a>2. tmin</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * tmin - return minimum two's complement integer: 0x80000000</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tmin</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回二进制补码表示中最小的数。</p><p>最小的数就是 符号位为1，其余位为0，也就是 $INT_MIN = -2^{31}$。</p><h2 id="3-isTmax"><a href="#3-isTmax" class="headerlink" title="3. isTmax"></a>3. isTmax</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isTmax - returns 1 if x is the maximum, two's complement number,</span></span><br><span class="line"><span class="comment"> *     and 0 otherwise </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | +</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isTmax</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断x是否为 ~(1&lt;&lt;31)</span></span><br><span class="line">    <span class="comment">// !!(~x)排除~x为0的情况;</span></span><br><span class="line">    <span class="comment">// 若~x=(1&lt;&lt;31), 则 ~x + ~x = 0</span></span><br><span class="line">    <span class="keyword">return</span> !!(~x) &amp; !(~x + ~x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断一个数是否为二进制补码表示中最大的数。</p><p>最大的数就是 符号位为0，其余为均为1，也就是 <code>INT_MAX = ~(1&lt;&lt;31)</code> 。</p><h2 id="4-allOddBits"><a href="#4-allOddBits" class="headerlink" title="4. allOddBits"></a>4. allOddBits</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span></span><br><span class="line"><span class="comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">allOddBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> slice = <span class="number">0xAA</span>;</span><br><span class="line">    <span class="keyword">int</span> oddBits = (slice &lt;&lt; <span class="number">24</span>) | (slice &lt;&lt; <span class="number">16</span>) | (slice &lt;&lt; <span class="number">8</span>) | slice;</span><br><span class="line">    <span class="keyword">return</span> !((x &amp; oddBits) ^ (oddBits));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断一个数的二进制的奇数位是否均为1。</p><p><strong>思路：</strong>构造一个奇数位均为1，偶数位均为0的二进制数：<code>0xAAAAAAAA</code> 。将该数与 x 按位 and，若得到结果为 <code>0xAAAAAAAA</code> ，则该数的奇数二进制位均为1.</p><p>因为最终要返回 0 或 1，所以再将结果与 <code>0xAAAAAAAA</code> 异或并使用 <code>!</code> 取否，将结果变为 0 或 1。</p><h2 id="5-negate"><a href="#5-negate" class="headerlink" title="5.  negate"></a>5.  negate</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * negate - return -x </span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">negate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ~x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求 -x。</p><p>将 x 按位取反，末位 +1 即可。</p><h2 id="6-isAsciiDigit"><a href="#6-isAsciiDigit" class="headerlink" title="6. isAsciiDigit"></a>6. isAsciiDigit</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters '0' to '9')</span></span><br><span class="line"><span class="comment"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isAsciiDigit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = x + ~<span class="number">47</span> + <span class="number">1</span>; <span class="comment">// x - 47</span></span><br><span class="line">    <span class="keyword">int</span> right = x + ~<span class="number">58</span> + <span class="number">1</span>; <span class="comment">// x - 58</span></span><br><span class="line">    <span class="keyword">return</span> !!left &amp; !(left &gt;&gt; <span class="number">31</span>) &amp; (right &gt;&gt; <span class="number">31</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断 x 是否是 ASCII 中的数字字符。</p><p><strong>思路：</strong>ASCII 数字字符的范围是 $48 \leq x \leq 57$ ，因此只需要判断 $x$ 是否在该范围即可。</p><p>将上面的左右区间各扩大 1 ，得到 $x$ 的范围为 $47 &lt; x &lt; 58$ 。若 $x$ 是一个数字字符，那么 $x - 47 &gt; 0$ 且 $x - 58 &lt; 0$ 。</p><p>分别计算出 $x - 47$ 的结果 <code>left</code> 和 $x - 58$ 的结果 <code>right</code> 。<code>left</code> 的符号位需要为0 并且 <code>left</code> 本身不能为 0，<code>right</code> 的符号位需要为 1。</p><h2 id="7-conditional"><a href="#7-conditional" class="headerlink" title="7. conditional"></a>7. conditional</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * conditional - same as x ? y : z </span></span><br><span class="line"><span class="comment"> *   Example: conditional(2,4,5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 16</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">conditional</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    x = !!x;</span><br><span class="line">    x = ~x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (x &amp; y) + (~x &amp; z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现三目运算符 <code>x ? y : z</code> 。<br><strong>思路：</strong>首先通过 <code>!!x</code> 将 <code>x</code> 变为 <code>0 或 1</code> ，然后通过 <code>~x + 1</code> 将 <code>x</code> 变为 <code>0x00000000 或 0xffffffff</code> 。当 <code>x = 0</code> 时，<code>~x + 1 = 0x00000000</code>；当 <code>x = 1</code> 时，<code>~x + 1 = 0xffffffff</code> 。</p><p><code>(x &amp; y) + (~x &amp; z)</code> 根据 <code>x</code> 的不同会等于 <code>y</code> 或 <code>z</code> 。</p><h2 id="8-isLessOrEqual"><a href="#8-isLessOrEqual" class="headerlink" title="8.  isLessOrEqual"></a>8.  isLessOrEqual</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// x &lt; 0 and y &gt;= 0</span></span><br><span class="line">    <span class="keyword">int</span> negateXandNorNegateY = (x &gt;&gt; <span class="number">31</span>) &amp; !(y &gt;&gt; <span class="number">31</span>);</span><br><span class="line">    <span class="comment">// x &gt;= 0 and y &lt; 0</span></span><br><span class="line">    <span class="keyword">int</span> norNegateXandNegateY = !(x &gt;&gt; <span class="number">31</span>) &amp; (y &gt;&gt; <span class="number">31</span>);</span><br><span class="line">    <span class="comment">// x - y</span></span><br><span class="line">    <span class="keyword">int</span> diff = x + ~y + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// x - y &lt;= 0</span></span><br><span class="line">    <span class="keyword">int</span> negateDiff = !diff | (diff &gt;&gt; <span class="number">31</span>);</span><br><span class="line">    <span class="keyword">return</span> negateXandNorNegateY | (!norNegateXandNegateY &amp; negateDiff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现 $\leq$ 运算符。</p><p><strong>思路：</strong> 这个题的关键是判断 $x - y$ 是否 $\leq $ 0 。基本思路是首先计算出 $x-y$ 的值，然后判断结果是否为 0 或者是否为负数（符号位为1）。</p><p>然而，这个题会出现运算溢出的情况，当 $x$ 与 $y$ 不同号时，二者相减可能会超出 <code>int</code> 的范围，因此需要特殊处理 $x$ 与 $y$ 不同号的情况。</p><h2 id="9-logicalNeg"><a href="#9-logicalNeg" class="headerlink" title="9. logicalNeg"></a>9. logicalNeg</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalNeg - implement the ! operator, using all of </span></span><br><span class="line"><span class="comment"> *              the legal operators except !</span></span><br><span class="line"><span class="comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">logicalNeg</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    x = x | x &gt;&gt; <span class="number">16</span>;</span><br><span class="line">    x = x | x &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    x = x | x &gt;&gt; <span class="number">4</span>;</span><br><span class="line">    x = x | x &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    x = x | x &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ~x &amp; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现 <code>!</code> 运算符。</p><p><strong>思路：</strong> 这个题的关键时判断 <code>x</code> 的二进制表示中是否含有 1 。这个解法是从网上看到的一个，比较巧妙。他用了类似分治的方法，将前16位的1放到后16位中，再将后16位中前8位的1放到后8位中，再将后8位中前4位的1放到后4位中，以此类推。若 <code>x</code> 的二进制表示中含有1，经过这一系列变化后，<code>x</code> 的二进制最后一位一定为 1 .</p><h2 id="10-howManyBits"><a href="#10-howManyBits" class="headerlink" title="10. howManyBits"></a>10. howManyBits</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* howManyBits - return the minimum number of bits required to represent x in</span></span><br><span class="line"><span class="comment"> *             two's complement</span></span><br><span class="line"><span class="comment"> *  Examples: howManyBits(12) = 5</span></span><br><span class="line"><span class="comment"> *            howManyBits(298) = 10</span></span><br><span class="line"><span class="comment"> *            howManyBits(-5) = 4</span></span><br><span class="line"><span class="comment"> *            howManyBits(0)  = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(-1) = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(0x80000000) = 32</span></span><br><span class="line"><span class="comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *  Max ops: 90</span></span><br><span class="line"><span class="comment"> *  Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">howManyBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sign, b16, b8, b4, b2, b1, b0;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sign = 0x00000000 或 0xffffffff</span></span><br><span class="line">    sign = x &gt;&gt; <span class="number">31</span>;</span><br><span class="line">    <span class="comment">// 若x非负，保持不变；否则将x按位取反</span></span><br><span class="line">    x = (sign &amp; ~x) | (~sign &amp; x);</span><br><span class="line"></span><br><span class="line">    b16 = !!(x &gt;&gt; <span class="number">16</span>) &lt;&lt; <span class="number">4</span>; <span class="comment">// 高16位是否有1</span></span><br><span class="line">    x &gt;&gt;= b16; <span class="comment">//如果有（至少需要16位），则将原数右移16位</span></span><br><span class="line">    b8 = !!(x &gt;&gt; <span class="number">8</span>) &lt;&lt; <span class="number">3</span>; <span class="comment">//剩余位高8位是否有1</span></span><br><span class="line">    x &gt;&gt;= b8; <span class="comment">// 如果还有（至少需要16+8=24位），则右移8位</span></span><br><span class="line">    b4 = !!(x &gt;&gt; <span class="number">4</span>) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">    x &gt;&gt;= b4;</span><br><span class="line">    b2 = !!(x &gt;&gt; <span class="number">2</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    x &gt;&gt;= b2;</span><br><span class="line">    b1 = !!(x &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    x &gt;&gt;= b1;</span><br><span class="line">    b0 = x;</span><br><span class="line">    <span class="keyword">return</span> b16 + b8 + b4 + b2 + b1 + b0 + <span class="number">1</span>; <span class="comment">// 最后的+1表示符号位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将一个数用补码表示最少需要几个bit？</p><p>例如 $12<em>{10} = 01100_2; \ -5</em>{10} = 1011<em>2; \ 0</em>{10} = 0<em>2; \ -1</em>{10} = 1_2$ . <strong>最高一位为符号位</strong></p><p><strong>思路：</strong> 对于一个正数，我们需要找到它最高的一位是1的，再加上符号位即可；对于一个负数，我们则需要找到它最高一位是0的（例如 5 位的 11101 和 4 位的 1101 以及 3 位的 101 表示的都是同一个值 -3，因此最高位连续的 1 是没有意义的），再加上符号位即可。因此，我们首先做一下统一，将负数都按位取反，这样统一都去找最高位是1的，再加上最后的符号位即为最终的答案。</p><p>如何找到最高位是1的那个位置呢？我们可以采用分治（divide and conquer）的方法。</p><ul><li><p>首先将这个 32 位的数 x 分成两半：高16位，低16位。先判断高16位中是否有1。</p><ul><li>若高16位有1，则说明最终答案肯定大于16，答案就等于 16 加上（x的高16位）这个数中最高位1的位置；</li><li>若高16位中没有1，则说明最终答案肯定不超过16，答案就等于（x的低16位） 这个数中最高位1的位置；</li></ul><p>怎么判断判断高16位中是否有1呢？只需将 x 右移16位，判断剩下的数是否为0即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !!(x &gt;&gt; <span class="number">16</span>) ) &#123;</span><br><span class="line">     <span class="comment">// 高16位有1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// 高16位没有1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接下来根据上一步的结果继续对 x的高16位 或 x的低16位 重复相同的步骤：将这个 16 位的数 y 分成两半：高8位，低8位。</p><p>先判断高8位中是否有1，其它的步骤与上一步类似。</p></li><li><p>一直这么分下去即可。</p></li></ul><h1 id="浮点数部分"><a href="#浮点数部分" class="headerlink" title="浮点数部分"></a>浮点数部分</h1><p>首先复习下浮点数的相关概念。</p><p>在计算机中，浮点数以 “阶码—尾数” 的方式进行表示，一个浮点数可以写成如下形式</p><script type="math/tex; mode=display">(-1)^s \ M \ 2^E</script><p>其中，$s$ 是一个符号位，标识了浮点数的正负，其取值为 $0$ 或 $1$，当 $s = 0$ 时，浮点数为正数，当 $s = 1$ 时，浮点数为负数。</p><p>$M$ 为尾数，其取值范围为 $[1.0, 2.0)$ ，$E$ 为阶码，这两个参数可以类比十进制中的科学计数法表示。例如，对于二进制数 $x = 1001$，将其表示成上述方式后为 $x = (-1)^0 \ast 1.001 \ast 2^3$。</p><p>C语言的浮点数类型有两种：32位的 <code>float</code> 和 64位的 <code>double</code>，这些 bit 存储了上面的符号位 $s$、阶码 $E$ 和 尾数 $M$，<code>double</code> 能够表示的浮点数的范围和精度都要比 <code>float</code> 大。</p><p><code>float</code> 是单精度浮点数，如下图所示，在它的 32 位中，最高 1 位是符号位，后 8 位是阶码位 ，最后 23 位是尾数位。</p><p><img src="float.png" alt=""></p><p><code>double</code> 是双精度浮点数，如下图所示，在它的 64 位中，最高 1 位是符号位，后 11 位是阶码位，最后 52 位是尾数位。</p><p><img src="double.png" alt=""></p><p>对于阶码 $E$ 和尾数 $M$ ，<code>float</code> 和 <code>double</code> 在存储时会将其进行一定编码后存储，如上图中的 exp 和 frac 存储的就是经过编码后的阶码和尾数。例如，对于阶码 $E$，在编码时会将其加上一个偏差 bias，也就是说， <code>exp = E + bias</code>；</p><p>而根据 <code>exp</code> 取值的不同，可将浮点数分类 <code>规格化(Normalized)浮点数</code> 和 <code>非规格化(Denormalized)浮点数</code> 两大类。</p><p>当 <code>exp != 000...0</code> 并且 <code>exp != 111...1</code> 时，浮点数为<strong>规格化浮点数</strong>。</p><ul><li><p>规格化浮点数中，阶码 $E$ 的偏差 bias 等于 $2^{k-1} - 1$ ，其中 $k$ 为 阶码位的位数。对于 <code>float</code> 来说，$k = 8$， $bias = 2^{8-1}-1 = 127$；对于 <code>double</code> 来说，$k = 11$，$bias = 2^{11-1}-1=1023$。</p></li><li><p>尾数 $M$ 为 $1.xxx…x_2$，因为规格化浮点数的尾数都是一点几，所以在存储时，会舍弃掉最前面那个大家都有的 $1$，不足 23 位的要添加后导零补齐23位。也就是说，frac 中存储的是 $xxx…x_2$，并添加后导零补齐23位。</p></li><li><p>举个栗子，我们看一下十进制数 15213 存储在 float 中是什么样的。</p><ul><li>首先将其写成阶码-尾数的方式<script type="math/tex; mode=display">\begin{aligned}15213_{10} &= 11101101101101_2 \\&= (-1)^0 \times 1.1101101101101_2 \times 2^{13} \\\end{aligned}</script></li></ul></li><li><p>$M = 1.1101101101101$，去掉最前面的 1，将剩余的数添加后导零补齐23位，得到 frac 的值</p><script type="math/tex; mode=display">  frac = 11011011011010000000000_2</script></li><li><p>$E = 13$，添加 bias = 127 后，得到 exp 的值：$exp = 17 + 127 = 140 = 1001100_2$</p></li><li><p>最终得到32位的 float 如下图所示</p><p><img src="eg-normalized.png" alt=""></p></li><li><p>由于规格化浮点数中 $1 \leq M &lt; 2$，所以其无法表示 $0$ </p></li></ul><p>当 <code>exp = 000...0</code> 时，这是非规格化浮点数的一种，这时用来表示特别小的数。</p><ul><li>阶码 $E = 1 - bias$ 而不是 $0 - bias$</li><li>尾数 $M = 0.000…0_2$，没有前面的 1 了。</li><li>这种情况可以表示 0 了，当 <code>exp = 000...0</code> 且 <code>frac = 000...0</code> 时，浮点数为 0。但是，这时根据 符号位$s$ 的不同会出现 $+0$ 和 $-0$ 两种情况。</li></ul><p>当 <code>exp = 111...1</code> 时，这是非规格化浮点数的另一种，这时用来表示无穷大或NaN。</p><ul><li>当 <code>frac = 000...0</code> 时，表示 $\infty$ 。例如，$1.0 / 0.0 = -1.0 / 0.0 = +\infty, 1.0 / -0.0 = -\infty$    </li><li>当 <code>frac != 000...0</code> 时，表示 NaN（Not-a-Number）。例如，$\sqrt{-1} = NaN$ </li></ul><hr><p>浮点数相关的三个题目要求就比较松了，可以使用条件判断和循环，可以使用任何符号，定义任意大小的常数，但是不可以使用 <code>float</code> 和 <code>double</code> 。</p><h2 id="1-float-twice"><a href="#1-float-twice" class="headerlink" title="1.  float_twice"></a>1.  float_twice</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * float_twice - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int's, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_twice</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="built_in">exp</span> = (uf &gt;&gt; <span class="number">23</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">int</span> frac = uf &amp; <span class="number">0x7fffff</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0xff</span>) &#123; <span class="comment">// The ans is NaN</span></span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 直接将 uf * 2 再保留符号位即可</span></span><br><span class="line">        uf =  (<span class="number">0x80000000</span> &amp; uf) | (uf &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 阶码加1</span></span><br><span class="line">        uf += <span class="number">1</span> &lt;&lt; <span class="number">23</span>;</span><br><span class="line">        <span class="comment">// 若阶码加1后变为0xff, 则令结果为无穷大（否则就变成NaN了，这个结果显然不是NaN）</span></span><br><span class="line">        <span class="keyword">if</span> (((uf &gt;&gt; <span class="number">23</span>) &amp; <span class="number">0xff</span>) == <span class="number">0xff</span>) &#123;</span><br><span class="line">            uf &amp;= <span class="number">0xff800000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算 2 乘以 一个浮点数。浮点数为 float，以 32 位 unsigned 的形式给出。</p><p><strong>思路：</strong> 这个题主要考察浮点数的基本表示方法。首先排除无穷大、NaN 的情况，这两种情况直接返回原参数即可。对于 exp = 0 的情况，直接将原参数乘以2并保留符号位即可。对于规格化浮点数的情况，乘以2 相当于 阶码加1，由于阶码在第23位，因此其加1就相当于 <code>uf + (1 &lt;&lt; 23)</code> 。若阶码加1后变为 <code>0xff</code>，此时的结果应为无穷大，而不是 NaN，因此需要将后23位的尾数位都设为0。</p><h2 id="2-float-i2f"><a href="#2-float-i2f" class="headerlink" title="2. float_i2f"></a>2. float_i2f</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * float_i2f - Return bit-level equivalent of expression (float) x</span></span><br><span class="line"><span class="comment"> *   Result is returned as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_i2f</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sign = x &amp; (<span class="number">1</span> &lt;&lt; <span class="number">31</span>);</span><br><span class="line">    <span class="keyword">int</span> E = <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">exp</span>, frac, add, mx, back, ans;</span><br><span class="line">    <span class="keyword">int</span> diff, var, p;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sign) &#123;</span><br><span class="line">            <span class="comment">// 把x变成非负数，因为浮点数的正负由前面的符号位s决定</span></span><br><span class="line">            x = -x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到最高位的1所在的位置</span></span><br><span class="line">        <span class="keyword">while</span> (!((p = (<span class="number">1</span>&lt;&lt;E)) &amp; x)) &#123;</span><br><span class="line">            E--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exp</span> = E + <span class="number">127</span>;</span><br><span class="line">        <span class="comment">// 获取尾数(1.xxxxx 即获取小数点后面的xxxxx )</span></span><br><span class="line">        frac = x &amp; (p - <span class="number">1</span>);</span><br><span class="line">        diff = E - <span class="number">23</span>;</span><br><span class="line">        <span class="keyword">if</span> (E &lt; <span class="number">23</span>) &#123;</span><br><span class="line">            <span class="comment">// 尾数不足23位，补齐23位</span></span><br><span class="line">            frac &lt;&lt;= <span class="number">23</span> - E;</span><br><span class="line">        &#125;</span><br><span class="line">        add = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (E &gt; <span class="number">23</span>) &#123; <span class="comment">// 尾数超过23位，向偶数舍入</span></span><br><span class="line">            <span class="comment">// 设尾数为 1.xxxx...xyyyy, y需要被舍入</span></span><br><span class="line">            <span class="comment">// 这里假设y共有四位</span></span><br><span class="line">            <span class="comment">// 如果 (yyyy大于1000) 或者 (yyyy=1000且最后一个x为1)，则需要加1摄入；其它情况直接截断即可</span></span><br><span class="line">            mx = <span class="number">1</span> &lt;&lt; diff;</span><br><span class="line">            var = mx &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            back = frac &amp; (mx - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (back &gt; var || (back == var &amp;&amp; (frac &amp; mx))) &#123;</span><br><span class="line">                add = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            frac &gt;&gt;= diff;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = (sign | (<span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>) | frac) + add;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将一个整数转换为单精度浮点数。</p><p><strong>思路：</strong> 这个题思路还是比较简单的，只是实现起来细节很多。</p><ol><li>要注意把 $x$ 变为非负数，因为 float 浮点数的正负是由最前面的1个符号位 s 决定的，所以后31位的阶码和尾数都是以非负数为前提的。</li><li>找到最高位 1 所在的位置，由此可以计算出阶码 exp 的值，这个 1 后面的数作为尾数的值。</li><li>第 2 步中计算出的尾数可能不足 23 位或者超出 23 位。对于不足 32 位的情况，需要添加后置 0 凑齐23位；对于超过 23 位的情况，需要进行向偶数舍入。</li></ol><h2 id="3-float-f2i"><a href="#3-float-f2i" class="headerlink" title="3. float_f2i"></a>3. float_f2i</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * float_f2i - Return bit-level equivalent of expression (int) f</span></span><br><span class="line"><span class="comment"> *   for floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Argument is passed as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point value.</span></span><br><span class="line"><span class="comment"> *   Anything out of range (including NaN and infinity) should return</span></span><br><span class="line"><span class="comment"> *   0x80000000u.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">float_f2i</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sign = uf &amp; (<span class="number">1</span> &lt;&lt; <span class="number">31</span>);</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">exp</span> = (uf &amp; <span class="number">0x7f800000</span>) &gt;&gt; <span class="number">23</span>;</span><br><span class="line">    <span class="keyword">int</span> frac = uf &amp; <span class="number">0x7fffff</span>;</span><br><span class="line">    <span class="keyword">int</span> bias = <span class="number">127</span>;</span><br><span class="line">    <span class="keyword">int</span> outOfRange = <span class="number">0x80000000</span>u;</span><br><span class="line">    <span class="keyword">int</span> ans, E;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0xff</span>) &#123;</span><br><span class="line">        ans = outOfRange;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        E = <span class="built_in">exp</span> - bias;</span><br><span class="line">        <span class="keyword">if</span> (E &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (E &gt; <span class="number">30</span>) &#123;</span><br><span class="line">            ans = outOfRange;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            frac += <span class="number">0x800000</span>;</span><br><span class="line">            <span class="keyword">if</span> (E &gt; <span class="number">23</span>) &#123;</span><br><span class="line">                frac &lt;&lt;= E - <span class="number">23</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                frac &gt;&gt;= <span class="number">23</span> - E;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sign) &#123;</span><br><span class="line">                frac = -frac;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = frac;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将一个单精度浮点数转换为整数（向下取整，截断小数位）。</p><p><strong>思路：</strong> 这个题不难，只需要提取出 符号位 $s$，阶码 $E$，尾数 $M$。根据 $ans = (-1)^s \ast M \ast 2^E$，排除掉越界的情况，对不越界的数截断小数点后面的位即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Data Lab 都是与位运算相关的一些题目，总共有13个题。每个题都是按要求实现一个函数，题目中规定了可以使用的操作符（不能使用规定之外的操作），并对使用次数作出了限制，要求就是用这些给定的操作符，在一定次数内，完成函数所要实现的功能。&lt;/p&gt;
&lt;h1 id=&quot;整数部分&quot;
      
    
    </summary>
    
      <category term="课程学习" scheme="965087276.github.io/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="CMU 15-213" scheme="965087276.github.io/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/CMU-15-213/"/>
    
    
      <category term="CMU 15-213" scheme="965087276.github.io/tags/CMU-15-213/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 560 和为K的子数组</title>
    <link href="965087276.github.io/2020/05/15/LeetCode-560-%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>965087276.github.io/2020/05/15/LeetCode-560-和为K的子数组/</id>
    <published>2020-05-15T01:27:31.000Z</published>
    <updated>2020-05-15T01:56:02.780Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个整数数组和一个整数 <strong>k，</strong>你需要找到该数组中和为 <strong>k</strong> 的连续的子数组的个数。</p><p><strong>示例 1 :</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入:nums &#x3D; [1,1,1], k &#x3D; 2</span><br><span class="line">输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。</span><br></pre></td></tr></table></figure><p><strong>说明 :</strong></p><ol><li>数组的长度为 [1, 20,000]。</li><li>数组中元素的范围是 [-1000, 1000] ，且整数 <strong>k</strong> 的范围是 [-1e7, 1e7]。</li></ol><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>直接二重循环的时间复杂度为 $O(n^2)$，肯定是不可取的。</p><p>这个题抽象一下就是寻找不同的元组对 $(i, j)$ 的个数，满足 $i \leq j$ 且 $nums[i] + \cdots + nums[j] = k$。</p><p>考虑前缀和的形式，令 $pre[i]$ 为 $nums$ 数组中前 $i$ 个 元素的和，则有</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> i == <span class="number">0</span> </span><br><span class="line">pre[i] = <span class="number">0</span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">pre[i] = pre[i<span class="number">-1</span>] + pre[i]</span><br></pre></td></tr></table></figure><p>我们要找满足 $i \leq j$ 且 $nums[i] + \cdots + nums[j] = k$ 的元组 $(i, j)$ 的数量 ，将 $pre$ 数组带入这个式子，可得</p><script type="math/tex; mode=display">pre[j] - pre[i-1] = k</script><p>移向得</p><script type="math/tex; mode=display">pre[i-1] = pre[j] - k</script><p>我们可以顺序遍历 $j$ ，考虑以 $j$ 结尾的和为 $k$ 的子数组的数量。根据上面的式子，对于每个 $j$ ，我们只需要寻找在 $j$ 前面有多少个前缀和为 $pre[j] - k$ 的 $pre[i]$ 即可。</p><p>我们建立哈希表 $mp$，以和为键，出现次数为对应的值，记录 $pre[i]$ 的出现次数，从左往右边更新 $mp$ 边计算答案（从左往右边更新边计算的时候已经保证了 $mp[pre[j]-k]$ 里记录的 $pre[i]$ 的下标范围是 $0 \leq i &lt; j$）</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">    mp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : nums) &#123;</span><br><span class="line">        pre += x;</span><br><span class="line">        <span class="keyword">if</span> (mp.<span class="built_in">find</span>(pre - k) != mp.<span class="built_in">end</span>()) count += mp[pre - k];</span><br><span class="line">        mp[pre]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定一个整数数组和一个整数 &lt;strong&gt;k，&lt;/strong&gt;你需要找到该数组中和为 &lt;strong&gt;k&lt;/strong&gt; 的连续的子数
      
    
    </summary>
    
      <category term="刷题" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
      <category term="LeetCode" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/LeetCode/"/>
    
    
      <category term="数组" scheme="965087276.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="哈希表" scheme="965087276.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer 链表中倒数第k个节点</title>
    <link href="965087276.github.io/2020/04/08/%E5%89%91%E6%8C%87Offer-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>965087276.github.io/2020/04/08/剑指Offer-链表中倒数第k个节点/</id>
    <published>2020-04-08T01:11:00.000Z</published>
    <updated>2020-05-15T01:32:59.667Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k &#x3D; 2.</span><br><span class="line"></span><br><span class="line">返回链表 4-&gt;5.</span><br></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这个题最容易想到的思路是先将链表遍历一遍，计算出链表的长度 $n$ ，然后再遍历链表找到第 $n - k + 1$ 个元素。这种方法需要遍历链表两次，在时间上有些劣势。</p><p>其实我们可以只遍历链表一次就可以完成。算法流程如下</p><ol><li>设置两个指针：fast 和 slow。</li><li>fast 指针先向前走 $k$ 步（结束之后，fast 指针和 slow 指针间相差 $k$ 步）</li><li>两个指针共同移动（都向前走 1 步，如此循环），当 fast 指针走过链表尾节点后跳出循环</li><li>此时 slow 指针与尾节点的距离为 $k-1$,  即 slow 指针指向了链表倒数第 $k$ 个节点。</li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode fast = head, slow = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) </span><br><span class="line">        fast = fast.next;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点
      
    
    </summary>
    
      <category term="刷题" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
      <category term="剑指Offer" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="链表" scheme="965087276.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>程序员面试金典 旋转矩阵</title>
    <link href="965087276.github.io/2020/04/07/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8-%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/"/>
    <id>965087276.github.io/2020/04/07/程序员面试金典-旋转矩阵/</id>
    <published>2020-04-07T01:17:04.000Z</published>
    <updated>2020-05-15T01:35:33.212Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一幅由 <code>N × N</code> 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。<strong>不能使用额外的内存空间</strong></p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">给定 matrix &#x3D; </span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">给定 matrix &#x3D;</span><br><span class="line">[</span><br><span class="line">  [ 5, 1, 9,11],</span><br><span class="line">  [ 2, 4, 8,10],</span><br><span class="line">  [13, 3, 6, 7],</span><br><span class="line">  [15,14,12,16]</span><br><span class="line">], </span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [15,13, 2, 5],</span><br><span class="line">  [14, 3, 4, 1],</span><br><span class="line">  [12, 6, 8, 9],</span><br><span class="line">  [16, 7,10,11]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>转运下面大神的思路</strong></p><blockquote><p><a href="https://leetcode-cn.com/problems/rotate-matrix-lcci/solution/c-tu-jie-yuan-di-cao-zuo-ji-bai-shuang-bai-vv-by-t/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rotate-matrix-lcci/solution/c-tu-jie-yuan-di-cao-zuo-ji-bai-shuang-bai-vv-by-t/</a></p></blockquote><p><strong>来观察下正方形矩阵旋转90度时究竟发生了什么。</strong></p><p><img src="1.gif" alt=""></p><p>观察图中颜色相同的四个位置，当旋转90度后，对应位置的元素发生了顺时针的交换。</p><p>设四个位置中，位于<strong>左上角区域</strong>的位置坐标为 $(i,j)$，则按顺时针顺序，四个位置分别为 $(i,j)$,  $(j, n-i-1)$,  $(n-i-1,n-j-1)$,  $(n-j-1,i)$ </p><p>matrix.size() 为奇数时，位置的对应关系相同，但左上角区域并<strong>不是整个矩阵的四分之一</strong>，如下图示：</p><p><img src="2.png" alt=""></p><p>其实就是<strong>多了中间列的上半部分</strong>。</p><p>那么现在捋一下如何<strong>原地操作元素</strong>：<br>枚举左上区域的所有位置，然后通过上面总结的位置关系直接交换元素。<br>对于一个位置 (i,j)，需要<strong>交换三次</strong>：</p><ol><li><code>swap(matrix[i][j], matrix[j][n-i-1]);</code></li><li><code>swap(matrix[i][j], matrix[n-i-1][n-j-1]);</code></li><li><code>swap(matrix[i][j], matrix[n-j-1][i]);</code></li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 这里行 或 列，谁多出一个都可以。即也可以是 i &lt; (n+1) / 2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i++) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (n + <span class="number">1</span>) / <span class="number">2</span>; j++) &#123;</span><br><span class="line">        swap(matrix[i][j], matrix[j][n-i<span class="number">-1</span>]);</span><br><span class="line">        swap(matrix[i][j], matrix[n-i<span class="number">-1</span>][n-j<span class="number">-1</span>]);</span><br><span class="line">        swap(matrix[i][j], matrix[n-j<span class="number">-1</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给你一幅由 &lt;code&gt;N × N&lt;/code&gt; 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。&lt;
      
    
    </summary>
    
      <category term="刷题" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
      <category term="程序员面试金典" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8/"/>
    
    
      <category term="数组" scheme="965087276.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 42 接雨水</title>
    <link href="965087276.github.io/2020/04/04/LeetCode-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
    <id>965087276.github.io/2020/04/04/LeetCode-42-接雨水/</id>
    <published>2020-04-04T09:16:38.000Z</published>
    <updated>2020-05-03T06:01:41.681Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><img src="1.png" alt=""></p><p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 <strong>感谢 Marcos</strong> 贡献此图。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>根据木桶原理，每根柱子能够承接雨水的数量等于其两边最大高度柱子中的较小者减去当前柱子的高度。</p><p>举个栗子，对于下面的柱子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[4, 3, 1, 2, 5, 4]</span><br></pre></td></tr></table></figure><p>柱子 1 所能承接雨水的数量为 3。计算方法是：分别寻找柱子 1 左右两边高度最高的柱子——柱子 4 和 柱子 5；取两个柱子中高度较小者——柱子 4；柱子 4 的高度减去柱子 1 的高度 得到结果为3。</p><p>因此，问题求解的核心在于，对于数组中的每个元素，如何找到其左右两边元素的最大值。</p><h2 id="思路1-动态规划"><a href="#思路1-动态规划" class="headerlink" title="思路1  动态规划"></a>思路1  动态规划</h2><ul><li><p>令 $left_max[i]$ 表示数组 $height$ 中从最左端到下标 i 最高的柱子高度，则 $left_max[i] = max(left_max[i-1], height[i])$</p></li><li><p>令 $right_max[i]$ 表示数组 $height$ 中从下标 i 到最右端最高的柱子高度，则  $right_max[i] = max(right_max[i+1], height[i])$</p></li><li><p>遍历数组 $height$，将 $min(left_max[i], right_max[i]) - height[i]$ 更新到答案中</p></li></ul><p>算法时间复杂度为 $O(n)$，空间复杂度为 $O(n)$</p><p><strong>代码如下</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">height</span> == null)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = <span class="built_in">height</span>.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left_max(<span class="built_in">size</span>), right_max(<span class="built_in">size</span>);</span><br><span class="line">    left_max[<span class="number">0</span>] = <span class="built_in">height</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">        left_max[i] = <span class="built_in">max</span>(<span class="built_in">height</span>[i], left_max[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    right_max[<span class="built_in">size</span> - <span class="number">1</span>] = <span class="built_in">height</span>[<span class="built_in">size</span> - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">size</span> - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        right_max[i] = <span class="built_in">max</span>(<span class="built_in">height</span>[i], right_max[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">size</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        ans += <span class="built_in">min</span>(left_max[i], right_max[i]) - <span class="built_in">height</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思路2-双指针"><a href="#思路2-双指针" class="headerlink" title="思路2 双指针"></a>思路2 双指针</h2><p>在上面动态规划的解法中，我们用到了 $left_max, right_max$ 两个数组，但是这两个数组中的每个元素其实我们只使用了一次，也就是说，当我们使用 $left_max[i]$ 时，$left_max[0] \ 至 \ left_max[i-1]$ 都不会再用到了。把这些不会用到的元素也存下来就有些浪费空间了，现在我们就来看一下如何去掉这两个数组。</p><p>先回顾一下两个数组是如何更新的</p><p>$left_max[i] = max(left_max[i-1], height[i])$</p><p>$right_max[i] = max(right_max[i+1], height[i])$</p><p>可以看到：left_max[i] 的值只与 left_max[i-1] 有关，与 left_max[0] 至 left_max[i-2] 的值都无关。设 left_max[i] 是本次遍历中所要计算的最大值，那么 left_max[i-1] 就是遍历所要计算的最大值，因此，我们完全可以只通过left_max这一个变量来维护这一系列的最大值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等号左边的left_max是本次要计算的left_max，相当于left_max[i]</span></span><br><span class="line"><span class="comment">// 等号右边的left_max是前一次遍历中计算的left_max, 相当于left_max[i-1]</span></span><br><span class="line">left_max = <span class="built_in">max</span>(left_max, <span class="built_in">height</span>[i])</span><br></pre></td></tr></table></figure><p>同理，right_max[i] 也可由 right_max 替代</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等号左边的right_max是本次要计算的right_max，相当于right_max[i]</span></span><br><span class="line"><span class="comment">// 等号右边的right_max是前一次遍历中计算的right_max, 相当于right_max[i+1]</span></span><br><span class="line">right_max = <span class="built_in">max</span>(right_max, <span class="built_in">height</span>[i])</span><br></pre></td></tr></table></figure><p>回到我们的题目中来，我们可以使用上面的优化，先将代码中的left_max数组去掉</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">height</span> == null)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = <span class="built_in">height</span>.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right_max(<span class="built_in">size</span>);</span><br><span class="line">    left_max = <span class="built_in">height</span>[<span class="number">0</span>];</span><br><span class="line">    right_max[<span class="built_in">size</span> - <span class="number">1</span>] = <span class="built_in">height</span>[<span class="built_in">size</span> - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">size</span> - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        right_max[i] = <span class="built_in">max</span>(<span class="built_in">height</span>[i], right_max[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">size</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        left_max = <span class="built_in">max</span>(left_max, <span class="built_in">height</span>[i]);</span><br><span class="line">        ans += <span class="built_in">min</span>(left_max, right_max[i]) - <span class="built_in">height</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，right_max数组是否也能直接去掉呢？显然是不行的，因此我们的求解过程是<strong>从左到右</strong>遍历的，left_max数组可以去掉的原因是它的计算过程也是从左到右遍历的，而right_max数组的计算过程是<strong>从右到左</strong>遍历的，因此不能直接去掉。</p><p>也就是说，无论是我们从左往右算，还是从右往左算，都只能去掉两个数组中的一个，那怎么做才能把这两个数组都去掉呢？相信你已经想到了，那就是<strong>既从左往右算，又从右往左算</strong>。</p><p>我们使用两个双指针 left 和 right 分别指向 height 数组的左右端点，同时使用上面的 left_max 和 right_max 分别维护左右两个方向的最大值。</p><p>在思路 1 中，对于位置 left 的柱子，其载水量为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">min</span>(left_max[left], right_max[left]) - <span class="built_in">height</span>[left];</span><br></pre></td></tr></table></figure><p>现在我们可以把两个数组去掉，其结果为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">min</span>(left_max, <span class="built_in">max</span>(<span class="built_in">height</span>[left], <span class="built_in">height</span>[left+<span class="number">1</span>], ... , <span class="built_in">height</span>[right]) ) - <span class="built_in">height</span>[left];</span><br></pre></td></tr></table></figure><p>如果 <code>left_max &lt; height[right]</code>  或是小于这其中的任意一个，那么上式等于 <code>left_max - height[left]</code>。这种情况下，我们不需要遍历 left 位置右边那一堆柱子的高度就可以得到 left 位置的载水量。</p><p>同理，对于位置 right 的柱子，其载水量为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">min</span>(right_max, <span class="built_in">max</span>(<span class="built_in">height</span>[<span class="number">0</span>], <span class="built_in">height</span>[<span class="number">1</span>], ... , <span class="built_in">height</span>[right]) ) - <span class="built_in">height</span>[right];</span><br></pre></td></tr></table></figure><p>如果 <code>right_max &lt; height[0]</code> 或是小于这其中的任意一个，那么上式等于 <code>right_max - height[right]</code>。</p><p>这样我们得到了下面的算法</p><ul><li>使用两个双指针 left 和 right 分别指向 height 数组的左右端点，同时使用上面的 left_max 和 right_max 分别维护左右两个方向的最大值。</li><li>当 left &lt;= right 时<ul><li>更新 <code>left_max = max(left_max, height[left])</code></li><li>更新 <code>right_max = max(right_max, height[right])</code></li><li>如果 <code>left_max &lt;= right_max</code>，根据木桶效应， left 位置的柱子的载水量可以直接算出，结果为 <code>left_max - height[left]</code>。</li><li>如果 <code>right_max &lt;= left_max</code>，根据木桶效应， right 位置的柱子的载水量可以直接算出，结果为 <code>right_max - height[right]</code>。</li><li>更新 left 指针或 right 指针位置，重复以上步骤</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left_max = <span class="number">0</span>, right_max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="built_in">height</span>.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        left_max = <span class="built_in">max</span>(left_max, <span class="built_in">height</span>[left]);</span><br><span class="line">        right_max = <span class="built_in">max</span>(right_max, <span class="built_in">height</span>[right]);</span><br><span class="line">        <span class="keyword">if</span> (left_max &lt; right_max) &#123; <span class="comment">// 右边再大也没用，因为左边是短板</span></span><br><span class="line">            ans += left_max - <span class="built_in">height</span>[left++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// right_max &lt;= left_max // 做百年再大也没用，因为右边是短板</span></span><br><span class="line">            ans += right_max - <span class="built_in">height</span>[right--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定 &lt;em&gt;n&lt;/em&gt; 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。&lt;/p&gt;
&lt;p&gt;&lt;img
      
    
    </summary>
    
      <category term="刷题" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="LeetCode" scheme="965087276.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer 树的子结构</title>
    <link href="965087276.github.io/2020/04/01/%E5%89%91%E6%8C%87Offer-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"/>
    <id>965087276.github.io/2020/04/01/剑指Offer-树的子结构/</id>
    <published>2020-04-01T01:28:14.000Z</published>
    <updated>2020-05-15T01:33:21.407Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>输入两棵完全二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p><p>例如:<br>给定的树 A:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    3  </span><br><span class="line">   &#x2F; \  </span><br><span class="line">  4   5 </span><br><span class="line"> &#x2F; \ </span><br><span class="line">1   2</span><br></pre></td></tr></table></figure><p>给定的树 B：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  4  </span><br><span class="line"> &#x2F; </span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p><p>输入按照完全二叉树的 BFS 遍历顺序输入</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：A &#x3D; [1,2,3], B &#x3D; [3,1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：A &#x3D; [3,4,5,1,2], B &#x3D; [4,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>回顾一下做字符串匹配时的思路。假设我们要判断字符串  <code>B = &quot;cde&quot;</code> 是否是字符串 <code>A = &quot;abcdef&quot;</code> 的子串，那么我们首先要找到 $A$ 中哪个位置的字符与 $B$ 的第一个字符 <code>c</code> 相等，经过这个步骤后，我们找到了子串 <code>A1 = &quot;cdef&quot;</code>；然后，我们需要判断 $B$ 是否是 $A1$ 的前缀，如果是，则说明 $B$ 是 $A$ 的字串，如果不是，那么我们需要最开始的步骤，在 $A$ 中再寻找下一个等于 <code>c</code> 的字符的位置进行判断。</p><p>这道题也是类似，要判断 $B$ 是否是 $A$ 的子树，我们先找到 $A$ 中哪个节点与 $B$ 的根节点相等，然后再判断 $B$ 是否是以该节点为根的树的前缀，如果不是，则再去 $A$ 中找到下一个这样的节点再做判断，以此类推。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="keyword">null</span> || B == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// A.val与B.val相等，判断B是否是A的前缀树</span></span><br><span class="line">        <span class="keyword">if</span> (A.val == B.val &amp;&amp; isPrefix(A, B)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// A.val与B.val不相等 或者 相等但不是前缀，则再去找下一个满足条件的A</span></span><br><span class="line">        <span class="keyword">if</span> (isSubStructure(A.left, B) || isSubStructure(A.right, B)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 判断B是否是A的前缀</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPrefix</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (B == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 空树是A的前缀</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A == <span class="keyword">null</span> || A.val != B.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isPrefix(A.left, B.left) &amp;&amp; isPrefix(A.right, B.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;输入两棵完全二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)&lt;/p&gt;
&lt;p&gt;B是A的子结构， 即 A中有出现和B相同
      
    
    </summary>
    
      <category term="刷题" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
      <category term="剑指Offer" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="二叉树" scheme="965087276.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.824 lab1笔记</title>
    <link href="965087276.github.io/2020/03/31/MIT6-824-lab1%E7%AC%94%E8%AE%B0/"/>
    <id>965087276.github.io/2020/03/31/MIT6-824-lab1笔记/</id>
    <published>2020-03-31T01:04:25.000Z</published>
    <updated>2020-05-31T01:29:05.824Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>这次的 Lab1 是根据 MapReduce 的论文来实现一个简易的 MapReduce 框架，需要具备基本的任务分发和超时任务检测机制。</p><p><img src="1.png" alt=""></p><p>先来回顾一下 MapReduce 的执行过程，论文中将其大致为如下几步</p><ol><li><p><strong>论文：</strong>MapReduce将用户输入分成 M 部分，每部分通常在 16-64MB ，并将用户程序（Map 函数和 Reduce 函数）拷贝到每台机器中。</p><p><strong>本实验：</strong> 在本实验中，有若干个待处理的 txt 文件（pg-*.txt），可以将每个 txt 文件作为一个 Map 任务。同时，Map 函数和 Reduce 函数的代码已经被编译到文件 wc.so 中，各个 Worker 需要读取这个文件将两个函数加载进来。</p></li><li><p><strong>论文：</strong> Master 将任务划分成 M 个 Map 任务和 R 个 Reduce 任务，每次寻找一个空闲的 Worker 将一个任务分配给它。</p><p><strong>本实验</strong>：本实验中，Map 任务的数量和 Reduce 任务的数量都已经事先确定好了。Map 任务的数量就是输入的 txt 文件的数量，Reduce 任务的数量在 master 的入口程序中设定（后面会提到）。在任务分配方面，与论文有所不同，实验中采用的是 Worker 主动向 Master 拉取任务的方式。</p></li><li><p><strong>论文：</strong> 执行 Map 任务的 Worker 读取输入文件，将文件传给 Map 函数，Map 函数解析文件内容并生成 key/value pairs 中间结果。这些中间结果会通过分区函数分成 R 个区域并写入本地磁盘中。Map 任务执行完后，Worker 将 R 个中间文件的回传给 Master，master 会将这些文件的位置传送给 Reduce worker。</p><p><strong>本实验：</strong> 与论文的步骤大致相同</p></li><li><p><strong>论文：</strong> 执行 Reduce 任务的 Worker 通过 RPC 从 Map Worker 所在主机的磁盘上读取这些中间文件，并通过 key 值进行排序，将具有相同 key 值的 key/value pair 传送到同一个 Reduce 任务中。Reduce 任务的输出同样输出到磁盘中。</p><p><strong>本实验：</strong> 由于本实验是使用单机的多个进程来模拟多机的分布式环境，因此 Reduce 任务只需要从本地读取 Map 任务的中间结果即可。</p></li><li><p>任务完成。</p></li></ol><p>下面根据代码详细介绍下这几个步骤</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先设定几个常量，来表示 master 当前所处的阶段（“Map阶段”、“Reduce阶段”或者“已完成”）和 每个任务的状态（未开始、进行中、完成）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// master.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Phase <span class="keyword">int8</span></span><br><span class="line"><span class="keyword">type</span> Status <span class="keyword">int8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line"><span class="comment">// master所处的阶段</span></span><br><span class="line">Phase_Map      = Phase(<span class="number">1</span>)</span><br><span class="line">Phase_Reduce   = Phase(<span class="number">2</span>)</span><br><span class="line">Phase_Complete = Phase(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务状态</span></span><br><span class="line">Status_Idel      = Status(<span class="number">0</span>)</span><br><span class="line">Status_Progess   = Status(<span class="number">1</span>)</span><br><span class="line">Status_Completed = Status(<span class="number">2</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="程序入口"><a href="#程序入口" class="headerlink" title="程序入口"></a>程序入口</h2><p>master 程序和 worker 程序的入口分别为 main 目录下的 mrmaster.go 和 mrworker.go。</p><h3 id="mrmaster-go"><a href="#mrmaster-go" class="headerlink" title="mrmaster.go"></a>mrmaster.go</h3><p>首先来看 mrmaster.go ，mrmaster.go 执行的命令为如下，可以看到 mrmaster.go会读取所有的输入文件作为参数。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> run mrmaster.<span class="keyword">go</span> pg-*.txt</span><br></pre></td></tr></table></figure><p>读取输入参数后，主函数调用 master.go 中的 MakeMaster 函数创建一个 Master 对象，MakeMaster传入的参数有两个，第一个参数为上面的输入文件 “pg-*.txt”，第二个参数为 reduce 任务的个数，这里固定为 10 个。</p><p>创建 Master 对象后，主函数每隔一秒会调用 m.Done() 函数判断 Master的所有任务是否都已完成，如果完成，那么整个流程结束，主程序将退出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mrmaster.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &lt; <span class="number">2</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">"Usage: mrmaster inputfiles...\n"</span>)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// os.Args[1:]为所有的输入文件， 10为reduce任务的个数</span></span><br><span class="line">m := mr.MakeMaster(os.Args[<span class="number">1</span>:], <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> m.Done() == <span class="literal">false</span> &#123;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以先看一下 m.Done() 函数如何实现。前面说到，我们使用了 Phase_Map、Phase_Reduce、Phase_Complete 三个常量表示 Master 当前所处的状态。因此，只需要判断 Master 是否处于 Phase_Complete 状态即可，代码如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Master.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">Done</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// m.Phase表示Master当前的状态，若为Complete状态，则所有任务均已完成</span></span><br><span class="line"><span class="keyword">return</span> m.Phase == Phase_Complete</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mrworker-go"><a href="#mrworker-go" class="headerlink" title="mrworker.go"></a>mrworker.go</h3><p>再来看 mrworker.go，mrworker.go 的执行命令如下，其中 wc.so 文件中包含了具体的 Map 和 Reduce 函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> run mrworker.<span class="keyword">go</span> wc.so</span><br></pre></td></tr></table></figure><p>mrworker.go 通过 loadPlugin 方法加载map函数和reduce函数，然后调用 mr.Worker 方法正式执行。当所有任务都执行完毕时，mrworker.go就会结束。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mrworker.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">2</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">"Usage: mrworker xxx.so\n"</span>)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mapf, reducef := loadPlugin(os.Args[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">mr.Worker(mapf, reducef)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// load the application Map and Reduce functions</span></span><br><span class="line"><span class="comment">// from a plugin file, e.g. ../mrapps/wc.so</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadPlugin</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">func</span>(<span class="keyword">string</span>, <span class="keyword">string</span>)</span> []<span class="title">mr</span>.<span class="title">KeyValue</span>, <span class="title">func</span><span class="params">(<span class="keyword">string</span>, []<span class="keyword">string</span>)</span> <span class="title">string</span>)</span> &#123;</span><br><span class="line">p, err := plugin.Open(filename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"cannot load plugin %v"</span>, filename)</span><br><span class="line">&#125;</span><br><span class="line">xmapf, err := p.Lookup(<span class="string">"Map"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"cannot find Map in %v"</span>, filename)</span><br><span class="line">&#125;</span><br><span class="line">mapf := xmapf.(<span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span> []<span class="title">mr</span>.<span class="title">KeyValue</span>)</span></span><br><span class="line">xreducef, err := p.Lookup(<span class="string">"Reduce"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"cannot find Reduce in %v"</span>, filename)</span><br><span class="line">&#125;</span><br><span class="line">reducef := xreducef.(<span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>, []<span class="keyword">string</span>)</span> <span class="title">string</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> mapf, reducef</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Master-对象初始化"><a href="#Master-对象初始化" class="headerlink" title="Master 对象初始化"></a>Master 对象初始化</h2><p>下面是 Master 对象中相关变量的定义，后面碰到某个变量时会对其详细解释，这里先暂时列出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// master.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Master <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reduce任务的数量</span></span><br><span class="line">NReduce <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// map任务的数量</span></span><br><span class="line">NMap    <span class="keyword">int</span></span><br><span class="line"><span class="comment">// 存放所有的map任务</span></span><br><span class="line">MapTasks []*MapTask</span><br><span class="line"><span class="comment">// 存放所有的reduce任务</span></span><br><span class="line">ReduceTasks []*ReduceTask</span><br><span class="line"><span class="comment">// Master当前所处的阶段</span></span><br><span class="line">Phase Phase</span><br><span class="line"><span class="comment">// map任务channel</span></span><br><span class="line">MapTaskChan    <span class="keyword">chan</span> *MapTask</span><br><span class="line"><span class="comment">// reduce任务channel</span></span><br><span class="line">    ReduceTaskChan <span class="keyword">chan</span> *ReduceTask</span><br><span class="line"><span class="comment">// map任务输出的中间文件的位置，数组大小NMap * NReduce</span></span><br><span class="line">    <span class="comment">// 每个map任务输出NReduce个中间文件</span></span><br><span class="line">IntermediateFiles [][]<span class="keyword">string</span></span><br><span class="line"><span class="comment">// 已完成的map任务的数量</span></span><br><span class="line">NCompleteMap    <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 已完成的reduce任务的数量</span></span><br><span class="line">NCompleteReduce <span class="keyword">int</span></span><br><span class="line"><span class="comment">// 互斥锁</span></span><br><span class="line">mu sync.Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mrmaster.go 通过调用 <code>mr.MakeMaster(os.Args[1:], 10)</code> 函数创建一个Master。</p><p>下面的MakeMaster函数主要做了三件事：1. 初始化 Master 对象的各个变量；2. 调用 m.server() 开启TCP服务监听；3. 初始化 map 任务，这里为了不阻塞 MakeMaster 过程，开启了一个新的线程异步的执行 map 任务的初始化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// master.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeMaster</span><span class="params">(files []<span class="keyword">string</span>, nReduce <span class="keyword">int</span>)</span> *<span class="title">Master</span></span> &#123;</span><br><span class="line">m := Master&#123;&#125;</span><br><span class="line"><span class="comment">// 初始化Master各变量</span></span><br><span class="line">m.NReduce = nReduce</span><br><span class="line">m.MapTasks = <span class="built_in">make</span>([]*MapTask, <span class="number">0</span>)</span><br><span class="line">m.MapTaskChan = <span class="built_in">make</span>(<span class="keyword">chan</span> *MapTask)</span><br><span class="line">m.ReduceTaskChan = <span class="built_in">make</span>(<span class="keyword">chan</span> *ReduceTask)</span><br><span class="line">m.NCompleteMap = <span class="number">0</span></span><br><span class="line">m.NCompleteReduce = <span class="number">0</span></span><br><span class="line">m.IntermediateFiles = <span class="built_in">make</span>([][]<span class="keyword">string</span>, nReduce)</span><br><span class="line">m.NMap = <span class="built_in">len</span>(files)</span><br><span class="line">m.Phase = Phase_Map</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于master和worker之间需要通过RPC来传递任务。因此，需要将两个任务对象注册到RPC中，这样</span></span><br><span class="line">    <span class="comment">// 对方才能够成功的反序列化</span></span><br><span class="line">gob.Register(&amp;MapTask&#123;&#125;)</span><br><span class="line">gob.Register(&amp;ReduceTask&#123;&#125;)</span><br><span class="line">    </span><br><span class="line">m.server()</span><br><span class="line"><span class="comment">// 初始化 Map 任务</span></span><br><span class="line"><span class="keyword">go</span> m.GenerateMapTask(files)</span><br><span class="line">    <span class="keyword">return</span> &amp;m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="详细实现"><a href="#详细实现" class="headerlink" title="详细实现"></a>详细实现</h2><p>下面结合介绍一下整个 lab 的详细实现。有一点要说明一下，下面几小节中各个方法的代码并不是完整的，我会删掉一些与该小节无关的代码以尽量避免干扰。</p><h3 id="一-Map任务的初始化"><a href="#一-Map任务的初始化" class="headerlink" title="一  Map任务的初始化"></a>一  Map任务的初始化</h3><p>首先是 Map 任务的初始化。在最开始，mrmaster.go中会调用MakeMaster 函数生成Master对象，而MakeMaster中会调用 GenerateMapTask 函数进行 map 任务的初始化，每一个 txt 文件为一个 map 任务。</p><p>该函数遍历所有的输入文件，为每个文件生成一个map任务，初始时任务为闲置（未开始）状态，当任务被分配或任务完成后，任务状态会相应的改变。map任务生成后，将其放入 MapTasks 数组存储起来，同时将其放入 MapTaskChan 中用于后面任务的分配。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// master.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map任务初始化，files为所有 "pg-*.txt" 输入文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">GenerateMapTask</span><span class="params">(files []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i, file := <span class="keyword">range</span> files &#123;</span><br><span class="line">mapTask := MapTask&#123;</span><br><span class="line">Id:       i, <span class="comment">// 任务编号</span></span><br><span class="line">FileName: file, <span class="comment">// 文件名称</span></span><br><span class="line">Status:  Status_Idel, <span class="comment">// 任务状态为闲置状态</span></span><br><span class="line">NReduce: m.NReduce, <span class="comment">// reduce任务的数量（等于 map任务输出的中间文件的数量）</span></span><br><span class="line">&#125;</span><br><span class="line">m.MapTasks = <span class="built_in">append</span>(m.MapTasks, &amp;mapTask)</span><br><span class="line"><span class="comment">// 将 map 任务放到 channel 中</span></span><br><span class="line">        m.MapTaskChan &lt;- (&amp;mapTask)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、-Worker向-Master-拉取-Map-任务"><a href="#二、-Worker向-Master-拉取-Map-任务" class="headerlink" title="二、 Worker向 Master 拉取 Map 任务"></a>二、 Worker向 Master 拉取 Map 任务</h3><p>当 Worker 成功启动后，就可以向 Master 发起 RPC 调用来申请任务了。同时，根据 MapReduce 的特性，Master 刚开始分配的任务都是 Map 任务，只有在所有的 Map 任务都执行完毕后才会开始分配 Reduce 任务。本小节只介绍 Map 任务的申请。（为了减少代码的干扰，下面的代码中删去了与 Reduce 任务相关的部分）</p><p>在mrworker.go 中，通过调用 <code>mr.Worker(mapf, reducef)</code> 方法并传入 mapf 和 reducef 两个函数作为参数完成 Worker 对象的创建工作。Worker 创建后，会调用 Run() 方法正式开始工作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Worker对象。因为不能与下面的Worker()方法重名，所以这里用了Work</span></span><br><span class="line"><span class="keyword">type</span> Work <span class="keyword">struct</span> &#123;</span><br><span class="line">Mapf    <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span> []<span class="title">KeyValue</span></span></span><br><span class="line">Reducef <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>, []<span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// main/mrworker.go calls this function.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Worker</span><span class="params">(mapf <span class="keyword">func</span>(<span class="keyword">string</span>, <span class="keyword">string</span>)</span> []<span class="title">KeyValue</span>,</span></span><br><span class="line">reducef <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>, []<span class="keyword">string</span>)</span> <span class="title">string</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">gob.Register(&amp;MapTask&#123;&#125;)</span><br><span class="line">gob.Register(&amp;ReduceTask&#123;&#125;)</span><br><span class="line"></span><br><span class="line">worker := &amp;Work&#123;</span><br><span class="line">Mapf:    mapf,</span><br><span class="line">Reducef: reducef,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 该方法会一直执行，直到master的所有任务均已完成</span></span><br><span class="line">worker.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Worker 开始工作后，首先调用 PullTask() 方法获取一个任务。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Work)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 获取任务</span></span><br><span class="line">        reply := w.PullTask()</span><br><span class="line">        ... ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PullTask() 方法会通过 RPC 调用 Master 的 AssignTask 方法向其申请任务。这里暂不考虑RPC调用失败的情况</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Work)</span> <span class="title">PullTask</span><span class="params">()</span> *<span class="title">PullTaskReply</span></span> &#123;</span><br><span class="line">args := PullTaskArgs&#123;&#125;</span><br><span class="line">reply := PullTaskReply&#123;&#125;</span><br><span class="line">    <span class="comment">// RPC调用，向Master申请任务</span></span><br><span class="line"><span class="keyword">if</span> call(<span class="string">"Master.AssignTask"</span>, &amp;args, &amp;reply) &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;reply</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Master 接收到任务申请的请求后，检查 MapTaskChan 中是否还有空闲的任务。如果存在，则分配该任务并将任务状态修改为 Progress；如果暂时没有空闲的任务可以分配，则返回 nil </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// master.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">AssignTask</span><span class="params">(args *PullTaskArgs, reply *PullTaskReply)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="comment">// 存在空闲的map任务</span></span><br><span class="line">    <span class="keyword">case</span> mapTask := &lt;-m.MapTaskChan:</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Printf(<span class="string">"Assign a mapTask : %v\n"</span>, *mapTask)</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 修改任务状态</span></span><br><span class="line">mapTask.Status = Status_Progess</span><br><span class="line">reply.Task = *mapTask</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Println(<span class="string">"No task to assign"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// No tasks can be assigned</span></span><br><span class="line">reply.Task = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Worker 从 PullTask 中接收到任务后，首先检查任务的状态。如果任务为 nil ，则说明 master 当前没有空闲的任务可以分配，这时候，为了避免 Worker 再频繁的向 Master 申请任务，可以先让 Worker 进程挂起一段时间（Sleep 1s），在这之后，再与 Master 通信。如果成功拿到任务，则调用 RunMapTask() 方法执行 Map 任务。</p><p>这里的 for 循环是个死循环，Worker 执行完一个任务后，可以再向 Master 申请下一个任务。for 循环的退出条件会在后面的 Reduce 任务相关小节说明。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// master.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Work)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">reply := w.PullTask()</span><br><span class="line">        <span class="keyword">if</span> reply.Task == <span class="literal">nil</span> &#123; <span class="comment">// Master暂时分配不到任务，等待1s后继续向Master申请</span></span><br><span class="line">            <span class="keyword">if</span> debug &#123;</span><br><span class="line">                log.Println(<span class="string">"Cannot apply a map Task, wait 1s"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 等待1s</span></span><br><span class="line">            time.Sleep(time.Second)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 执行 map 任务</span></span><br><span class="line">            w.RunMapTask(reply.Task)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、Map-任务执行"><a href="#三、Map-任务执行" class="headerlink" title="三、Map 任务执行"></a>三、Map 任务执行</h3><p>Worker 接收到来自 Master 分配的 Map 任务后，调用 RunMapTask 方法执行 Map 任务。</p><p>这部分代码与 “串行MapReduce示例“的代码基本一致，这里不作过多阐述。需要注意的是，Map任务的输出需要按照分区写入多个文件中，文件的数量与NReduce一致。每个中间文件的名称为 “mr-taskId-partitionId”</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Work)</span> <span class="title">RunMapTask</span><span class="params">(task *MapTask)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Printf(<span class="string">"Receive a map task: %v\n"</span>, *task)</span><br><span class="line">&#125;</span><br><span class="line">file, err := os.Open(task.FileName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"cannot open %v"</span>, task.FileName)</span><br><span class="line">&#125;</span><br><span class="line">content, err := ioutil.ReadAll(file)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"cannot read %v"</span>, task.FileName)</span><br><span class="line">&#125;</span><br><span class="line">file.Close()</span><br><span class="line">kva := w.Mapf(task.FileName, <span class="keyword">string</span>(content))</span><br><span class="line"></span><br><span class="line">sort.Sort(ByKey(kva))</span><br><span class="line"><span class="comment">// 中间结果；将中间结果划分成NReduce个分区存储</span></span><br><span class="line">kvas := <span class="built_in">make</span>([][]KeyValue, task.NReduce)</span><br><span class="line"><span class="comment">// 将中间结果分配到各个分区</span></span><br><span class="line"><span class="keyword">for</span> _, kv := <span class="keyword">range</span> kva &#123;</span><br><span class="line">outK := ihash(kv.Key) % task.NReduce</span><br><span class="line">kvas[outK] = <span class="built_in">append</span>(kvas[outK], kv)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 存储中间结果</span></span><br><span class="line">intermediateFiles := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 将中间结果写到文件中</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; task.NReduce; i++ &#123;</span><br><span class="line">os.Mkdir(<span class="string">"maptmp"</span>, os.ModePerm)</span><br><span class="line">filename := <span class="string">"maptmp/mr-"</span> + strconv.Itoa(task.Id) + <span class="string">"-"</span> + strconv.Itoa(i)</span><br><span class="line">file, _ := os.Create(filename)</span><br><span class="line">enc := json.NewEncoder(file)</span><br><span class="line"><span class="keyword">for</span> _, kv := <span class="keyword">range</span> kvas[i] &#123;</span><br><span class="line">err := enc.Encode(&amp;kv)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"write intermediate file error"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">intermediateFiles = <span class="built_in">append</span>(intermediateFiles, filename)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向Master报告任务</span></span><br><span class="line">w.ReportTaskFinish(task.Id, Phase_Map, intermediateFiles)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Map 任务完成后，调用 ReportTaskFinish 向 Master 报告</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Work)</span> <span class="title">ReportTaskFinish</span><span class="params">(taskId <span class="keyword">int</span>, taskType Phase, intermediates []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">args := ReportTaskFinishArgs&#123;</span><br><span class="line">TaskId:            taskId,</span><br><span class="line">TaskPhase:         taskType,</span><br><span class="line">IntermediateFiles: intermediates,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reply := ReportTaskFinishReply&#123;&#125;</span><br><span class="line">call(<span class="string">"Master.ReportTaskFinish"</span>, &amp;args, &amp;reply)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、Worker-执行完-Map-任务，向-Master-报告"><a href="#四、Worker-执行完-Map-任务，向-Master-报告" class="headerlink" title="四、Worker 执行完 Map 任务，向 Master 报告"></a>四、Worker 执行完 Map 任务，向 Master 报告</h3><p>Master 收到 Worker完成Map任务的消息后，修改这个Map任务的状态（状态变为 Completed 状态），并将Map任务产生的中间文件的位置存储下来。<strong>注意以上所有的修改均需要加锁，以避免不一致的情况。</strong> 同时，Master 还维护了 NCompleteMap 变量记录了当前已完成的Map任务的数量，当所有的Map任务均已经完成时，Master 转为 Reduce 阶段，并初始化 Reduce 任务。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// master.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">ReportTaskFinish</span><span class="params">(args *ReportTaskFinishArgs, reply *ReportTaskFinishReply)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> args.TaskPhase &#123;</span><br><span class="line"><span class="keyword">case</span> Phase_Map: <span class="comment">// Map阶段</span></span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Printf(<span class="string">"Complete map task %d\n"</span>, args.TaskId)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">m.mu.Lock()</span><br><span class="line">m.MapTasks[args.TaskId].Status = Status_Completed</span><br><span class="line">m.NCompleteMap++</span><br><span class="line"><span class="comment">// 添加中间文件的位置</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m.NReduce; i++ &#123;</span><br><span class="line">m.IntermediateFiles[i] = <span class="built_in">append</span>(m.IntermediateFiles[i], args.IntermediateFiles[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 所有Map任务均已完成</span></span><br><span class="line"><span class="keyword">if</span> m.NCompleteMap == m.NMap &#123;</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Println(<span class="string">"All Map Tasks finished"</span>)</span><br><span class="line">&#125;</span><br><span class="line">m.Phase = Phase_Reduce</span><br><span class="line"><span class="comment">// 初始化Reduce任务</span></span><br><span class="line"><span class="keyword">go</span> m.GenerateReduceMap()</span><br><span class="line">&#125;</span><br><span class="line">m.mu.Unlock()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、Master-初始化-Reduce-任务"><a href="#五、Master-初始化-Reduce-任务" class="headerlink" title="五、Master 初始化 Reduce 任务"></a>五、Master 初始化 Reduce 任务</h3><p>每个 Map 任务会输出 NReduce 个中间文件，因此 NMap 个 Map 任务总共输出 NReduce * NMap 个中间文件。在 Reduce 任务阶段，每个Reduce任务负责其中1个分区的所有中间文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// master.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">GenerateReduceMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// IntermediateFiles大小为 NReduce * NMap，即共有 NReduce 个分区</span></span><br><span class="line">    <span class="comment">// 每个reduce任务负责其中1个分区的所有中间文件</span></span><br><span class="line"><span class="keyword">for</span> i, files := <span class="keyword">range</span> m.IntermediateFiles &#123;</span><br><span class="line">reduceTask := ReduceTask&#123;</span><br><span class="line">Id:        i,</span><br><span class="line">FileNames: files,</span><br><span class="line">Status:    Status_Idel,</span><br><span class="line">&#125;</span><br><span class="line">m.ReduceTasks = <span class="built_in">append</span>(m.ReduceTasks, &amp;reduceTask)</span><br><span class="line">m.ReduceTaskChan &lt;- &amp;reduceTask</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六、Worker-向-Master-申请-Reduce-任务"><a href="#六、Worker-向-Master-申请-Reduce-任务" class="headerlink" title="六、Worker 向 Master 申请 Reduce 任务"></a>六、Worker 向 Master 申请 Reduce 任务</h3><p>这部分代码与前一部分基本一致；这里把Reduce任务相关的代码添加上。</p><p>Worker 调用 PullTask 方法向 Master 申请任务，Master 会返回自己当前所处的阶段作为任务标识</p><ul><li>如果 Master 处于 Phase_Complete 阶段，说明所有任务均已完成，此时 Worker 退出</li><li>如果 Master 处于 Phase_Map 阶段，说明拿到的任务为 Map 任务，此时调用 RunMapTask 执行 Map 任务</li><li>如果 Master 处于 Phase_Reduce 阶段，说明拿到的任务为 Reduce 任务，此时调用 RunReduceTask 执行 Reduce 任务</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Work)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">reply := w.PullTask()</span><br><span class="line"><span class="keyword">if</span> reply == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> reply.Master_Phase &#123;</span><br><span class="line"><span class="keyword">case</span> Phase_Complete:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> Phase_Map:</span><br><span class="line"><span class="keyword">if</span> reply.Task == <span class="literal">nil</span> &#123; <span class="comment">// Master 暂时无法分配任务，等待1s后继续申请</span></span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Println(<span class="string">"Cannot apply a map Task, wait 1s"</span>)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">w.RunMapTask(reply.Task.(*MapTask))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> Phase_Reduce:</span><br><span class="line"><span class="keyword">if</span> reply.Task == <span class="literal">nil</span> &#123; <span class="comment">// Master 暂时无法分配任务，等待1s后继续申请</span></span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Println(<span class="string">"Cannot apply a reduce Task, wait 1s"</span>)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">w.RunReduceTask(reply.Task.(*ReduceTask))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PullTask 方法通过 RPC 向 Master 申请任务</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Work)</span> <span class="title">PullTask</span><span class="params">()</span> *<span class="title">PullTaskReply</span></span> &#123;</span><br><span class="line">args := PullTaskArgs&#123;&#125;</span><br><span class="line">reply := PullTaskReply&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> call(<span class="string">"Master.AssignTask"</span>, &amp;args, &amp;reply) &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;reply</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里的 PullTaskReply{} 中的任务既可以是 Map 任务，又可以是 Reduce 任务。因此，在该对象中，使用go中的任意类型 <code>interface{}</code> 来表示任务</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rpc.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PullTaskReply <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 任务对象。interface&#123;&#125;代表任意类型</span></span><br><span class="line">    <span class="comment">// 可以通过 Task.(*MapTask) 或 Task.(*ReduceTask) 转变成 MapTask 或 ReduceTask</span></span><br><span class="line">Task         <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">Master_Phase Phase</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="七、Worker-执行-Reduce-任务"><a href="#七、Worker-执行-Reduce-任务" class="headerlink" title="七、Worker 执行 Reduce 任务"></a>七、Worker 执行 Reduce 任务</h3><p>在Reduce执行阶段，Worker读取Map任务产生的中间文件，调用 Reduce 函数计算后，将结果写入一个最终文件中，文件名为 “mr-out-taskId”。任务执行完成后，向 Master 报告</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Work)</span> <span class="title">RunReduceTask</span><span class="params">(task *ReduceTask)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Printf(<span class="string">"Receive a reduce task: %v\n"</span>, *task)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// map任务产生的中间文件</span></span><br><span class="line">files := task.FileNames</span><br><span class="line">kva := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">for</span> _, fileName := <span class="keyword">range</span> files &#123;</span><br><span class="line">file, err := os.Open(fileName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"cannot open %v"</span>, fileName)</span><br><span class="line">&#125;</span><br><span class="line">dec := json.NewDecoder(file)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">var</span> kv KeyValue</span><br><span class="line"><span class="keyword">if</span> err := dec.Decode(&amp;kv); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">kva[kv.Key] = <span class="built_in">append</span>(kva[kv.Key], kv.Value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 文件名为 "mr-out-taskId"</span></span><br><span class="line">ofile, _ := os.Create(<span class="string">"mr-out-"</span> + strconv.Itoa(task.Id))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> kva &#123;</span><br><span class="line">output := w.Reducef(k, kva[k])</span><br><span class="line">fmt.Fprintf(ofile, <span class="string">"%v %v\n"</span>, k, output)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">w.ReportTaskFinish(task.Id, Phase_Reduce, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="八、Worker-执行完-Reduce-任务，向-Master-报告"><a href="#八、Worker-执行完-Reduce-任务，向-Master-报告" class="headerlink" title="八、Worker 执行完 Reduce 任务，向 Master 报告"></a>八、Worker 执行完 Reduce 任务，向 Master 报告</h3><p>Master 根据 TaskPhase 参数判断 worker 提交的任务的类型。对于 reduce 任务，Master 维护了 NCompleteReduce 变量来表示当前已经完成的 reduce 任务的数量。若所有任务均已完成，Master会转变为 Phase_Completed 阶段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// master.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">ReportTaskFinish</span><span class="params">(args *ReportTaskFinishArgs, reply *ReportTaskFinishReply)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> args.TaskPhase &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> Phase_Map:</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Printf(<span class="string">"Complete map task %d\n"</span>, args.TaskId)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// lock</span></span><br><span class="line">m.mu.Lock()</span><br><span class="line">m.MapTasks[args.TaskId].Status = Status_Completed</span><br><span class="line">m.NCompleteMap++</span><br><span class="line"><span class="comment">// Add the intermediate files</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m.NReduce; i++ &#123;</span><br><span class="line">m.IntermediateFiles[i] = <span class="built_in">append</span>(m.IntermediateFiles[i], args.IntermediateFiles[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// All map tasks are completed</span></span><br><span class="line"><span class="keyword">if</span> m.NCompleteMap == m.NMap &#123;</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Println(<span class="string">"All Map Tasks finished"</span>)</span><br><span class="line">&#125;</span><br><span class="line">m.Phase = Phase_Reduce</span><br><span class="line"><span class="comment">// generate the reduce tasks</span></span><br><span class="line"><span class="keyword">go</span> m.GenerateReduceMap()</span><br><span class="line">&#125;</span><br><span class="line">m.mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> Phase_Reduce:</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Printf(<span class="string">"Complete reduce task %d\n"</span>, args.TaskId)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// lock</span></span><br><span class="line">m.mu.Lock()</span><br><span class="line">m.ReduceTasks[args.TaskId].Status = Status_Completed</span><br><span class="line">m.NCompleteReduce++</span><br><span class="line"><span class="comment">// All Reduce tasks are completed</span></span><br><span class="line"><span class="keyword">if</span> m.NCompleteReduce == m.NReduce &#123;</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Println(<span class="string">"All Reduce Tasks finished"</span>)</span><br><span class="line">&#125;</span><br><span class="line">m.Phase = Phase_Complete</span><br><span class="line">&#125;</span><br><span class="line">m.mu.Unlock()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="九、超时任务监测及重分配"><a href="#九、超时任务监测及重分配" class="headerlink" title="九、超时任务监测及重分配"></a>九、超时任务监测及重分配</h3><p>对于分配出去的每一个任务，Master 都会开启一个新的线程来监测该任务的状态（下面的 <code>go m.MonitorMapTask(mapTask)</code> 或 <code>go m.MonitorReduceTask(reduceTask)</code>）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// master.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">AssignTask</span><span class="params">(args *PullTaskArgs, reply *PullTaskReply)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> mapTask := &lt;-m.MapTaskChan:</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Printf(<span class="string">"Assign a mapTask : %v\n"</span>, *mapTask)</span><br><span class="line">&#125;</span><br><span class="line">mapTask.Status = Status_Progess</span><br><span class="line">reply.Task = *mapTask</span><br><span class="line"><span class="comment">// 监测Map任务</span></span><br><span class="line"><span class="keyword">go</span> m.MonitorMapTask(mapTask)</span><br><span class="line"><span class="keyword">case</span> reduceTask := &lt;-m.ReduceTaskChan:</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Printf(<span class="string">"Assign a reduceTask : %v\n"</span>, *reduceTask)</span><br><span class="line">&#125;</span><br><span class="line">reduceTask.Status = Status_Progess</span><br><span class="line">reply.Task = *reduceTask</span><br><span class="line"><span class="comment">// 监测Reduce任务</span></span><br><span class="line"><span class="keyword">go</span> m.MonitorReduceTask(reduceTask)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Println(<span class="string">"No task to assign"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// No tasks can be assigned</span></span><br><span class="line">reply.Task = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">reply.Master_Phase = m.Phase</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以 <code>go m.MonitorReduceTask(reduceTask)</code> 为例。该方法使用一个 NewTicker 定时器，该定时器相当于一个 channel，每隔 10s，系统会向定时器中发送一条信息。下面的 for 循环持续监测任务的状态，如果超过10s后任务仍未完成，将默认worker已经宕机。此时，这个任务会被设为 Idel 状态并重新加入任务队列 ReduceTaskChan 中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// master.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">MonitorReduceTask</span><span class="params">(task *ReduceTask)</span></span> &#123;</span><br><span class="line"><span class="comment">// timeout = 10s</span></span><br><span class="line">t := time.NewTicker(time.Second * <span class="number">10</span>)</span><br><span class="line"><span class="keyword">defer</span> t.Stop()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="comment">// timeout</span></span><br><span class="line"><span class="keyword">case</span> &lt;-t.C:</span><br><span class="line">m.mu.Lock()</span><br><span class="line">task.Status = Status_Idel</span><br><span class="line">m.ReduceTaskChan &lt;- task</span><br><span class="line">m.mu.Unlock()</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// task finished in 10s</span></span><br><span class="line"><span class="keyword">if</span> task.Status == Status_Completed &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是整个代码的主体部分。所有代码的汇总见下一小节。</p><h2 id="代码汇总"><a href="#代码汇总" class="headerlink" title="代码汇总"></a>代码汇总</h2><p><strong>master.go</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mr</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/gob"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">import</span> <span class="string">"net"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"os"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/rpc"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Phase <span class="keyword">int8</span></span><br><span class="line"><span class="keyword">type</span> Status <span class="keyword">int8</span></span><br><span class="line"><span class="keyword">type</span> MStatus <span class="keyword">int8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line"><span class="comment">// the master's phase</span></span><br><span class="line">Phase_Map      = Phase(<span class="number">1</span>)</span><br><span class="line">Phase_Reduce   = Phase(<span class="number">2</span>)</span><br><span class="line">Phase_Complete = Phase(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// the task's status</span></span><br><span class="line">Status_Idel      = Status(<span class="number">0</span>)</span><br><span class="line">Status_Progess   = Status(<span class="number">1</span>)</span><br><span class="line">Status_Completed = Status(<span class="number">2</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> WorkerMachine <span class="keyword">struct</span> &#123;</span><br><span class="line">Id     <span class="keyword">int64</span></span><br><span class="line">Status Status</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MapTask <span class="keyword">struct</span> &#123;</span><br><span class="line">Id       <span class="keyword">int</span></span><br><span class="line">FileName <span class="keyword">string</span></span><br><span class="line">WorkerId <span class="keyword">int64</span></span><br><span class="line">Status   Status</span><br><span class="line">NReduce  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReduceTask <span class="keyword">struct</span> &#123;</span><br><span class="line">Id        <span class="keyword">int</span></span><br><span class="line">FileNames []<span class="keyword">string</span></span><br><span class="line">WorkerId  <span class="keyword">int64</span></span><br><span class="line">Status    Status</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Master <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The number of reduce tasks</span></span><br><span class="line">NReduce <span class="keyword">int</span></span><br><span class="line"><span class="comment">// The number of map tasks</span></span><br><span class="line">NMap <span class="keyword">int</span></span><br><span class="line"><span class="comment">// array of map tasks</span></span><br><span class="line">MapTasks []*MapTask</span><br><span class="line"><span class="comment">// array of reduce tasks</span></span><br><span class="line">ReduceTasks []*ReduceTask</span><br><span class="line"><span class="comment">// the master's phase : map, reduce or complete</span></span><br><span class="line">Phase Phase</span><br><span class="line"><span class="comment">// the channel of map task</span></span><br><span class="line">MapTaskChan <span class="keyword">chan</span> *MapTask</span><br><span class="line"><span class="comment">// the channel of reduce task</span></span><br><span class="line">ReduceTaskChan <span class="keyword">chan</span> *ReduceTask</span><br><span class="line"><span class="comment">// the location of intermediate files for map tasks.  size = NMap * NReduce</span></span><br><span class="line">IntermediateFiles [][]<span class="keyword">string</span></span><br><span class="line"><span class="comment">// the number of map tasks which has completed</span></span><br><span class="line">NCompleteMap <span class="keyword">int</span></span><br><span class="line"><span class="comment">// the number of reduce tasks which has completed</span></span><br><span class="line">NCompleteReduce <span class="keyword">int</span></span><br><span class="line"><span class="comment">// mutex lock</span></span><br><span class="line">mu sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// start a thread that listens for RPCs from worker.go</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">server</span><span class="params">()</span></span> &#123;</span><br><span class="line">rpc.Register(m)</span><br><span class="line">rpc.HandleHTTP()</span><br><span class="line"><span class="comment">//l, e := net.Listen("tcp", ":1234")</span></span><br><span class="line">sockname := masterSock()</span><br><span class="line">os.Remove(sockname)</span><br><span class="line">l, e := net.Listen(<span class="string">"unix"</span>, sockname)</span><br><span class="line"><span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"listen error:"</span>, e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> http.Serve(l, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">GenerateMapTask</span><span class="params">(files []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i, file := <span class="keyword">range</span> files &#123;</span><br><span class="line">mapTask := MapTask&#123;</span><br><span class="line">Id:       i,</span><br><span class="line">FileName: file,</span><br><span class="line">Status:   Status_Idel,</span><br><span class="line">NReduce:  m.NReduce,</span><br><span class="line">&#125;</span><br><span class="line">m.MapTasks = <span class="built_in">append</span>(m.MapTasks, &amp;mapTask)</span><br><span class="line">m.MapTaskChan &lt;- &amp;mapTask</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">GenerateReduceMap</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i, files := <span class="keyword">range</span> m.IntermediateFiles &#123;</span><br><span class="line">reduceTask := ReduceTask&#123;</span><br><span class="line">Id:        i,</span><br><span class="line">FileNames: files,</span><br><span class="line">Status:    Status_Idel,</span><br><span class="line">&#125;</span><br><span class="line">m.ReduceTasks = <span class="built_in">append</span>(m.ReduceTasks, &amp;reduceTask)</span><br><span class="line">m.ReduceTaskChan &lt;- &amp;reduceTask</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">AssignTask</span><span class="params">(args *PullTaskArgs, reply *PullTaskReply)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> mapTask := &lt;-m.MapTaskChan:</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Printf(<span class="string">"Assign a mapTask : %v\n"</span>, *mapTask)</span><br><span class="line">&#125;</span><br><span class="line">mapTask.Status = Status_Progess</span><br><span class="line">reply.Task = *mapTask</span><br><span class="line"><span class="comment">// monitor the task</span></span><br><span class="line"><span class="keyword">go</span> m.MonitorMapTask(mapTask)</span><br><span class="line"><span class="keyword">case</span> reduceTask := &lt;-m.ReduceTaskChan:</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Printf(<span class="string">"Assign a reduceTask : %v\n"</span>, *reduceTask)</span><br><span class="line">&#125;</span><br><span class="line">reduceTask.Status = Status_Progess</span><br><span class="line">reply.Task = *reduceTask</span><br><span class="line"><span class="comment">// monitor the task</span></span><br><span class="line"><span class="keyword">go</span> m.MonitorReduceTask(reduceTask)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Println(<span class="string">"No task to assign"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// No tasks can be assigned</span></span><br><span class="line">reply.Task = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">reply.Master_Phase = m.Phase</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">ReportTaskFinish</span><span class="params">(args *ReportTaskFinishArgs, reply *ReportTaskFinishReply)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> args.TaskPhase &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> Phase_Map:</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Printf(<span class="string">"Complete map task %d\n"</span>, args.TaskId)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// lock</span></span><br><span class="line">m.mu.Lock()</span><br><span class="line">m.MapTasks[args.TaskId].Status = Status_Completed</span><br><span class="line">m.NCompleteMap++</span><br><span class="line"><span class="comment">// Add the intermediate files</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m.NReduce; i++ &#123;</span><br><span class="line">m.IntermediateFiles[i] = <span class="built_in">append</span>(m.IntermediateFiles[i], args.IntermediateFiles[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// All map tasks are completed</span></span><br><span class="line"><span class="keyword">if</span> m.NCompleteMap == m.NMap &#123;</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Println(<span class="string">"All Map Tasks finished"</span>)</span><br><span class="line">&#125;</span><br><span class="line">m.Phase = Phase_Reduce</span><br><span class="line"><span class="comment">// generate the reduce tasks</span></span><br><span class="line"><span class="keyword">go</span> m.GenerateReduceMap()</span><br><span class="line">&#125;</span><br><span class="line">m.mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> Phase_Reduce:</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Printf(<span class="string">"Complete reduce task %d\n"</span>, args.TaskId)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// lock</span></span><br><span class="line">m.mu.Lock()</span><br><span class="line">m.ReduceTasks[args.TaskId].Status = Status_Completed</span><br><span class="line">m.NCompleteReduce++</span><br><span class="line"><span class="comment">// All Reduce tasks are completed</span></span><br><span class="line"><span class="keyword">if</span> m.NCompleteReduce == m.NReduce &#123;</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Println(<span class="string">"All Reduce Tasks finished"</span>)</span><br><span class="line">&#125;</span><br><span class="line">m.Phase = Phase_Complete</span><br><span class="line">&#125;</span><br><span class="line">m.mu.Unlock()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">MonitorMapTask</span><span class="params">(task *MapTask)</span></span> &#123;</span><br><span class="line"><span class="comment">// timeout = 10s</span></span><br><span class="line">t := time.NewTicker(time.Second * <span class="number">10</span>)</span><br><span class="line"><span class="keyword">defer</span> t.Stop()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="comment">// timeout</span></span><br><span class="line"><span class="keyword">case</span> &lt;-t.C:</span><br><span class="line">m.mu.Lock()</span><br><span class="line">task.Status = Status_Idel</span><br><span class="line">m.MapTaskChan &lt;- task</span><br><span class="line">m.mu.Unlock()</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// task finished in 10s</span></span><br><span class="line"><span class="keyword">if</span> task.Status == Status_Completed &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">MonitorReduceTask</span><span class="params">(task *ReduceTask)</span></span> &#123;</span><br><span class="line"><span class="comment">// timeout = 10s</span></span><br><span class="line">t := time.NewTicker(time.Second * <span class="number">10</span>)</span><br><span class="line"><span class="keyword">defer</span> t.Stop()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="comment">// timeout</span></span><br><span class="line"><span class="keyword">case</span> &lt;-t.C:</span><br><span class="line">m.mu.Lock()</span><br><span class="line">task.Status = Status_Idel</span><br><span class="line">m.ReduceTaskChan &lt;- task</span><br><span class="line">m.mu.Unlock()</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// task finished in 10s</span></span><br><span class="line"><span class="keyword">if</span> task.Status == Status_Completed &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// main/mrmaster.go calls Done() periodically to find out</span></span><br><span class="line"><span class="comment">// if the entire job has finished.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">Done</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> m.Phase == Phase_Complete</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// create a Master.</span></span><br><span class="line"><span class="comment">// main/mrmaster.go calls this function.</span></span><br><span class="line"><span class="comment">// nReduce is the number of reduce tasks to use.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeMaster</span><span class="params">(files []<span class="keyword">string</span>, nReduce <span class="keyword">int</span>)</span> *<span class="title">Master</span></span> &#123;</span><br><span class="line">m := Master&#123;&#125;</span><br><span class="line"></span><br><span class="line">m.NReduce = nReduce</span><br><span class="line">m.MapTasks = <span class="built_in">make</span>([]*MapTask, <span class="number">0</span>)</span><br><span class="line">m.MapTaskChan = <span class="built_in">make</span>(<span class="keyword">chan</span> *MapTask)</span><br><span class="line">m.ReduceTaskChan = <span class="built_in">make</span>(<span class="keyword">chan</span> *ReduceTask)</span><br><span class="line">m.NCompleteMap = <span class="number">0</span></span><br><span class="line">m.NCompleteReduce = <span class="number">0</span></span><br><span class="line">m.IntermediateFiles = <span class="built_in">make</span>([][]<span class="keyword">string</span>, nReduce)</span><br><span class="line">m.NMap = <span class="built_in">len</span>(files)</span><br><span class="line">m.Phase = Phase_Map</span><br><span class="line"></span><br><span class="line">gob.Register(&amp;MapTask&#123;&#125;)</span><br><span class="line">gob.Register(&amp;ReduceTask&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// generate the map task</span></span><br><span class="line"><span class="keyword">go</span> m.GenerateMapTask(files)</span><br><span class="line">m.server()</span><br><span class="line"><span class="keyword">return</span> &amp;m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>worker.go</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mr</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/gob"</span></span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"sort"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">import</span> <span class="string">"log"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/rpc"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"hash/fnv"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Map functions return a slice of KeyValue.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">type</span> KeyValue <span class="keyword">struct</span> &#123;</span><br><span class="line">Key   <span class="keyword">string</span></span><br><span class="line">Value <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for sorting by key.</span></span><br><span class="line"><span class="keyword">type</span> ByKey []KeyValue</span><br><span class="line"></span><br><span class="line"><span class="comment">// for sorting by key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByKey)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(a) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByKey)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; a[i], a[j] = a[j], a[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByKey)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> a[i].Key &lt; a[j].Key &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// use ihash(key) % NReduce to choose the reduce</span></span><br><span class="line"><span class="comment">// task number for each KeyValue emitted by Map.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ihash</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">h := fnv.New32a()</span><br><span class="line">h.Write([]<span class="keyword">byte</span>(key))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">int</span>(h.Sum32() &amp; <span class="number">0x7fffffff</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Work <span class="keyword">struct</span> &#123;</span><br><span class="line">Id      <span class="keyword">int64</span></span><br><span class="line">Mapf    <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span> []<span class="title">KeyValue</span></span></span><br><span class="line">Reducef <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>, []<span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// main/mrworker.go calls this function.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Worker</span><span class="params">(mapf <span class="keyword">func</span>(<span class="keyword">string</span>, <span class="keyword">string</span>)</span> []<span class="title">KeyValue</span>,</span></span><br><span class="line">reducef <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>, []<span class="keyword">string</span>)</span> <span class="title">string</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">gob.Register(&amp;MapTask&#123;&#125;)</span><br><span class="line">gob.Register(&amp;ReduceTask&#123;&#125;)</span><br><span class="line"></span><br><span class="line">worker := &amp;Work&#123;</span><br><span class="line">Mapf:    mapf,</span><br><span class="line">Reducef: reducef,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">worker.Run()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Work)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">reply := w.PullTask()</span><br><span class="line"><span class="keyword">if</span> reply == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> reply.Master_Phase &#123;</span><br><span class="line"><span class="keyword">case</span> Phase_Complete:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> Phase_Map:</span><br><span class="line"><span class="keyword">if</span> reply.Task == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Println(<span class="string">"Cannot apply a map Task, wait 1s"</span>)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">w.RunMapTask(reply.Task.(*MapTask))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> Phase_Reduce:</span><br><span class="line"><span class="keyword">if</span> reply.Task == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Println(<span class="string">"Cannot apply a reduce Task, wait 1s"</span>)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">w.RunReduceTask(reply.Task.(*ReduceTask))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Work)</span> <span class="title">PullTask</span><span class="params">()</span> *<span class="title">PullTaskReply</span></span> &#123;</span><br><span class="line">args := PullTaskArgs&#123;&#125;</span><br><span class="line">reply := PullTaskReply&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> call(<span class="string">"Master.AssignTask"</span>, &amp;args, &amp;reply) &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;reply</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Work)</span> <span class="title">RunMapTask</span><span class="params">(task *MapTask)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Printf(<span class="string">"Receive a map task: %v\n"</span>, *task)</span><br><span class="line">&#125;</span><br><span class="line">file, err := os.Open(task.FileName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"cannot open %v"</span>, task.FileName)</span><br><span class="line">&#125;</span><br><span class="line">content, err := ioutil.ReadAll(file)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"cannot read %v"</span>, task.FileName)</span><br><span class="line">&#125;</span><br><span class="line">file.Close()</span><br><span class="line">kva := w.Mapf(task.FileName, <span class="keyword">string</span>(content))</span><br><span class="line"></span><br><span class="line">sort.Sort(ByKey(kva))</span><br><span class="line"></span><br><span class="line">kvas := <span class="built_in">make</span>([][]KeyValue, task.NReduce)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, kv := <span class="keyword">range</span> kva &#123;</span><br><span class="line">outK := ihash(kv.Key) % task.NReduce</span><br><span class="line">kvas[outK] = <span class="built_in">append</span>(kvas[outK], kv)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">intermediateFiles := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; task.NReduce; i++ &#123;</span><br><span class="line">os.Mkdir(<span class="string">"maptmp"</span>, os.ModePerm)</span><br><span class="line">filename := <span class="string">"maptmp/mr-"</span> + strconv.Itoa(task.Id) + <span class="string">"-"</span> + strconv.Itoa(i)</span><br><span class="line">file, _ := os.Create(filename)</span><br><span class="line">enc := json.NewEncoder(file)</span><br><span class="line"><span class="keyword">for</span> _, kv := <span class="keyword">range</span> kvas[i] &#123;</span><br><span class="line">err := enc.Encode(&amp;kv)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"write intermediate file error"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">intermediateFiles = <span class="built_in">append</span>(intermediateFiles, filename)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">w.ReportTaskFinish(task.Id, Phase_Map, intermediateFiles)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Work)</span> <span class="title">RunReduceTask</span><span class="params">(task *ReduceTask)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Printf(<span class="string">"Receive a reduce task: %v\n"</span>, *task)</span><br><span class="line">&#125;</span><br><span class="line">files := task.FileNames</span><br><span class="line">kva := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">for</span> _, fileName := <span class="keyword">range</span> files &#123;</span><br><span class="line">file, err := os.Open(fileName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"cannot open %v"</span>, fileName)</span><br><span class="line">&#125;</span><br><span class="line">dec := json.NewDecoder(file)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">var</span> kv KeyValue</span><br><span class="line"><span class="keyword">if</span> err := dec.Decode(&amp;kv); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">kva[kv.Key] = <span class="built_in">append</span>(kva[kv.Key], kv.Value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ofile, _ := os.Create(<span class="string">"mr-out-"</span> + strconv.Itoa(task.Id))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> kva &#123;</span><br><span class="line">output := w.Reducef(k, kva[k])</span><br><span class="line">fmt.Fprintf(ofile, <span class="string">"%v %v\n"</span>, k, output)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">w.ReportTaskFinish(task.Id, Phase_Reduce, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Work)</span> <span class="title">ReportTaskFinish</span><span class="params">(taskId <span class="keyword">int</span>, taskType Phase, intermediates []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">args := ReportTaskFinishArgs&#123;</span><br><span class="line">TaskId:            taskId,</span><br><span class="line">TaskPhase:         taskType,</span><br><span class="line">IntermediateFiles: intermediates,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reply := ReportTaskFinishReply&#123;&#125;</span><br><span class="line">call(<span class="string">"Master.ReportTaskFinish"</span>, &amp;args, &amp;reply)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// send an RPC request to the master, wait for the response.</span></span><br><span class="line"><span class="comment">// usually returns true.</span></span><br><span class="line"><span class="comment">// returns false if something goes wrong.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">call</span><span class="params">(rpcname <span class="keyword">string</span>, args <span class="keyword">interface</span>&#123;&#125;, reply <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">// c, err := rpc.DialHTTP("tcp", "127.0.0.1"+":1234")</span></span><br><span class="line">sockname := masterSock()</span><br><span class="line">c, err := rpc.DialHTTP(<span class="string">"unix"</span>, sockname)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"dialing:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> c.Close()</span><br><span class="line"></span><br><span class="line">err = c.Call(rpcname, args, reply)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>rpc.go</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mr</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// RPC definitions.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// remember to capitalize all names.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"os"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"strconv"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PullTaskArgs <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//Id int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PullTaskReply <span class="keyword">struct</span> &#123;</span><br><span class="line">Task         <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">Master_Phase Phase</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReportTaskFinishArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">TaskId            <span class="keyword">int</span></span><br><span class="line">TaskPhase         Phase</span><br><span class="line">IntermediateFiles []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReportTaskFinishReply <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cook up a unique-ish UNIX-domain socket name</span></span><br><span class="line"><span class="comment">// in /var/tmp, for the master.</span></span><br><span class="line"><span class="comment">// Can't use the current directory since</span></span><br><span class="line"><span class="comment">// Athena AFS doesn't support UNIX-domain sockets.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">masterSock</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">s := <span class="string">"/var/tmp/824-mr-"</span></span><br><span class="line">s += strconv.Itoa(os.Getuid())</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;这次的 Lab1 是根据 MapReduce 的论文来实现一个简易的 MapReduce 框架，需要具备基本的任务分发和超时任务检测机制。&lt;
      
    
    </summary>
    
      <category term="课程学习" scheme="965087276.github.io/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="MIT 6.824" scheme="965087276.github.io/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/MIT-6-824/"/>
    
    
      <category term="MIT 6.824" scheme="965087276.github.io/tags/MIT-6-824/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer-正则表达式匹配</title>
    <link href="965087276.github.io/2020/03/27/%E5%89%91%E6%8C%87Offer-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
    <id>965087276.github.io/2020/03/27/剑指Offer-正则表达式匹配/</id>
    <published>2020-03-27T15:08:09.000Z</published>
    <updated>2020-05-15T01:34:05.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>请实现一个函数用来匹配包含<code>&#39;. &#39;</code>和<code>&#39;*&#39;</code>的正则表达式。模式中的字符<code>&#39;.&#39;</code>表示任意一个字符，而<code>&#39;*&#39;</code>表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串<code>&quot;aaa&quot;</code>与模式<code>&quot;a.a&quot;</code>和<code>&quot;ab*ac*a&quot;</code>匹配，但与<code>&quot;aa.a&quot;</code>和<code>&quot;ab*a&quot;</code>均不匹配。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#39;*&#39; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#39;a&#39;。因此，字符串 &quot;aa&quot; 可被视为 &#39;a&#39; 重复了一次。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;ab&quot;</span><br><span class="line">p &#x3D; &quot;.*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: &quot;.*&quot; 表示可匹配零个或多个（&#39;*&#39;）任意字符（&#39;.&#39;）。</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aab&quot;</span><br><span class="line">p &#x3D; &quot;c*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#39;*&#39; 表示零个或多个，这里 &#39;c&#39; 为 0 个, &#39;a&#39; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br></pre></td></tr></table></figure><p><strong>示例 5:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;mississippi&quot;</span><br><span class="line">p &#x3D; &quot;mis*is*p*.&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>令 $dp[i][j]$ 表示串 $s$ 的前 $i$ 个字符和串 $p$ 的前 $j$ 个字符是否匹配（这里的 $i, j &gt;= 1$）。分为下面三种情况</p><ol><li><p>串 $p$ 的第 $j$ 个字符 $p[j-1]$ 为普通字符（不是 <code>. 或 *</code> ）</p><p>这时候 <code>dp[i][j]</code> 成立 的条件是 <code>dp[i-1][j-1] == true and s[i-1] == p[j-1]</code></p></li><li><p>串 $p$ 的第 $j$ 个字符  <code>p[j-1] == &#39;.&#39;</code> </p><p>这时候匹配的条件是 <code>dp[i-1][j-1] == true</code></p></li><li><p>串 $p$ 的第 $j$ 个字符  <code>p[j-1] == &#39;*&#39;</code> </p><p>设 <code>*</code> 前面的字符为 $x$, 这时候要再分为两种情况</p><ol><li><p><code>x*</code> 不去和串 $s$ 匹配</p><p>这时候 <code>dp[i][j]</code> 成立的条件是 <code>dp[i][j-2] == true</code></p></li><li><p><code>x*</code> 和串 $s$ 匹配</p><p>这时候 <code>dp[i][j]</code> 成立的条件是 <code>dp[i-1][j] == true and (s[i] == p[j-1] or p[j-1] == &#39;.&#39;)</code></p></li></ol></li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = s.length(), len2 = p.length();</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 处理 s = ""  p = "a*b*" 这种情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len2; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[j] == <span class="string">'*'</span>) dp[<span class="number">0</span>][j+<span class="number">1</span>] = dp[<span class="number">0</span>][j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len2; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[j] != <span class="string">'*'</span>) &#123;</span><br><span class="line">            dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = (dp[i][j] &amp;&amp; (s[i] == p[j] || p[j] == <span class="string">'.'</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// x* 不去和 s 匹配</span></span><br><span class="line">            dp[i+<span class="number">1</span>][j+<span class="number">1</span>] |= dp[i+<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">            <span class="comment">// x* 去和 s 匹配</span></span><br><span class="line">            dp[i+<span class="number">1</span>][j+<span class="number">1</span>] |= (dp[i][j+<span class="number">1</span>] &amp;&amp; (s[i] == p[j<span class="number">-1</span>] || p[j<span class="number">-1</span>] == <span class="string">'.'</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len1][len2];</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;请实现一个函数用来匹配包含&lt;code&gt;&amp;#39;. &amp;#39;&lt;/code&gt;和&lt;code&gt;&amp;#39;*&amp;#39;&lt;/code&gt;的正则表达式。
      
    
    </summary>
    
      <category term="刷题" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
      <category term="剑指Offer" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="动态规划" scheme="965087276.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer-矩阵中的路径</title>
    <link href="965087276.github.io/2020/03/23/%E5%89%91%E6%8C%87Offer-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <id>965087276.github.io/2020/03/23/剑指Offer-矩阵中的路径/</id>
    <published>2020-03-23T01:30:45.000Z</published>
    <updated>2020-05-15T01:32:45.010Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p><p>[[“a”,”<strong>b</strong>“,”c”,”e”],<br>[“s”,”<strong>f</strong>“,”<strong>c</strong>“,”s”],<br>[“a”,”d”,”<strong>e</strong>“,”e”]]</p><p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：board &#x3D; [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],</span><br><span class="line">[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word &#x3D; &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board &#x3D; [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word &#x3D; &quot;abcd&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= board.length &lt;= 200</code></li><li><code>1 &lt;= board[i].length &lt;= 200</code></li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>许久不写 DFS，竟然在这道题上卡了一个小时</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span><span class="params">(self, board: List[List[str]], word: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, j, k)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= i &lt; len(board) <span class="keyword">or</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= j &lt; len(board[<span class="number">0</span>]) <span class="keyword">or</span> board[i][j] != word[k]: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> k == len(word)<span class="number">-1</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            tmp, board[i][j] = board[i][j], <span class="string">'.'</span></span><br><span class="line">            <span class="keyword">if</span> dfs(i+<span class="number">1</span>, j, k+<span class="number">1</span>) <span class="keyword">or</span> dfs(i<span class="number">-1</span>, j, k+<span class="number">1</span>) <span class="keyword">or</span> dfs(i, j+<span class="number">1</span>, k+<span class="number">1</span>) <span class="keyword">or</span> dfs(i, j<span class="number">-1</span>, k+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            board[i][j] = tmp</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> dfs(i, j, <span class="number">0</span>): <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、
      
    
    </summary>
    
      <category term="刷题" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
      <category term="剑指Offer" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="DFS" scheme="965087276.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 945 使数组唯一的最小增量</title>
    <link href="965087276.github.io/2020/03/22/LeetCode-945-%E4%BD%BF%E6%95%B0%E7%BB%84%E5%94%AF%E4%B8%80%E7%9A%84%E6%9C%80%E5%B0%8F%E5%A2%9E%E9%87%8F/"/>
    <id>965087276.github.io/2020/03/22/LeetCode-945-使数组唯一的最小增量/</id>
    <published>2020-03-22T03:52:43.000Z</published>
    <updated>2020-05-15T01:29:36.713Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定整数数组 A，每次 <em>move</em> 操作将会选择任意 <code>A[i]</code>，并将其递增 <code>1</code>。</p><p>返回使 <code>A</code> 中的每个值都是唯一的最少操作次数。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,2]</span><br><span class="line">输出：1</span><br><span class="line">解释：经过一次 move 操作，数组将变为 [1, 2, 3]。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[3,2,1,2,1,7]</span><br><span class="line">输出：6</span><br><span class="line">解释：经过 6 次 move 操作，数组将变为 [3, 4, 1, 2, 5, 7]。</span><br><span class="line">可以看出 5 次或 5 次以下的 move 操作是不能让数组的每个值唯一的。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>0 &lt;= A.length &lt;= 40000</code></li><li><code>0 &lt;= A[i] &lt; 40000</code></li></ol><h1 id="思路及代码"><a href="#思路及代码" class="headerlink" title="思路及代码"></a>思路及代码</h1><h2 id="解法一：普通排序再遍历"><a href="#解法一：普通排序再遍历" class="headerlink" title="解法一：普通排序再遍历"></a>解法一：普通排序再遍历</h2><p>将数组 <code>A</code> 排序，遍历每个元素，如果当前元素小于等于其前面的元素，就将当前元素等于前面元素加1</p><p>时间复杂度为 $O(n\log n)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minIncrementForUnique</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    sort (A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] &lt;= A[i<span class="number">-1</span>]) &#123;</span><br><span class="line">            ans += A[i<span class="number">-1</span>] - A[i] + <span class="number">1</span>;</span><br><span class="line">            A[i] = A[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解法二：计数法（预存每个数的出现次数）"><a href="#解法二：计数法（预存每个数的出现次数）" class="headerlink" title="解法二：计数法（预存每个数的出现次数）"></a>解法二：计数法（预存每个数的出现次数）</h2><p>注意到数组 <code>A</code> 各元素的范围在 <code>[0, 40000)</code> 之间。因此，我们可以开辟一个大小为 40000 的数组 $times$，存储每个数的出现次数。然后遍历数组 $times$，如果某个数 $i$ 的出现次数 $times[i]$ 大于1，那么这个数只留下 1 个，剩下 $times[i]-1$ 个数都 加 1 变为 $i+1$ ，如此循环下去。</p><p>时间复杂度为 $O(n)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> times[<span class="number">40000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minIncrementForUnique</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(times, <span class="number">0</span>, <span class="keyword">sizeof</span> times);</span><br><span class="line">    <span class="keyword">int</span> minV = <span class="number">40000</span>, maxV = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        times[A[i]]++;</span><br><span class="line">        minV = <span class="built_in">min</span>(minV, A[i]);</span><br><span class="line">        maxV = <span class="built_in">max</span>(maxV, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minV; i &lt; maxV; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (times[i] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 更新答案</span></span><br><span class="line">            ans += times[i] - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 将剩下的 times[i]-1 个数变为 i+1</span></span><br><span class="line">            times[i+<span class="number">1</span>] += times[i] - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设 maxV 有 x 个，则需要更新 (x - 1) * x / 2 次</span></span><br><span class="line">    ans += (times[maxV] - <span class="number">1</span>) * times[maxV] / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解法三：线性探测"><a href="#解法三：线性探测" class="headerlink" title="解法三：线性探测"></a>解法三：线性探测</h2><p><strong>该解法摘自 LeetCode</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">作者：sweetiee</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;minimum-increment-to-make-array-unique&#x2F;solution&#x2F;ji-shu-onxian-xing-tan-ce-fa-onpai-xu-onlogn-yi-ya&#x2F;</span><br><span class="line">来源：力扣（LeetCode）</span><br></pre></td></tr></table></figure><p>这道题可以看作是 把原数组映射到一个地址不冲突的区域，映射后的地址不小于原数组对应的元素。</p><p>比如，<code>[3, 2, 1, 2, 1, 7]</code> 就映射成了 <code>[3, 2, 1, 4, 5, 7]</code></p><p>那么这其实和 <strong>解决hash冲突的线性探测法</strong>很像，只不过这里的探测是单向（往右）的：如果地址冲突了，会探测它的下一个位置，如果下一个位置还是冲突，继续向后看，直到第一个不冲突的位置为止。</p><p>但是，直接进行线性探测可以会因为多次冲突导致探测时间太长，因此我们可以考虑在探测的过程中进行<strong>路径压缩</strong>。</p><p>如何路径压缩呢？<strong>就是经过某条路径最终探测到一个空位置x后，将这条路径上的值都变成空位置所在的下标x，那么假如下次探测的点又是这条路径上的点，则可以直接跳转到这次探测到的空位置x，从x开始继续探测。</strong></p><p>下面用样例2：[3, 2, 1, 2, 1, 7]，来模拟一遍线性探测的过程.</p><p><strong>step1: 插入3：</strong></p><p><img src="1.png" alt=""></p><p>因为3的位置是空的，所以直接放入3即可。（此时数组变成了上图，红色表示本次的更改）</p><p><strong>step2: 插入2：</strong></p><p><img src="2.png" alt=""></p><p><strong>step3: 插入1：</strong></p><p><img src="3.png" alt=""></p><p><strong>step4: 插入2：</strong></p><p><img src="4.png" alt=""></p><p>此时我们发现2的位置已经有值了，于是继续向后探测，直到找到空位4，于是2映射到了4。<br>并且！！我们要对刚刚走过的路径2-&gt;3-&gt;4进行压缩，即将他们的值都设置为本次探测到的空位4(那么下次探测就可以直接从4往后找了)。</p><p><strong>step5: 插入1：</strong></p><p><img src="5.png" alt=""></p><p><strong>step6: 插入7：</strong></p><p><img src="6.png" alt=""></p><p>代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">move</span>[<span class="number">80000</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPos</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="built_in">move</span>[x];</span><br><span class="line">        <span class="keyword">return</span> b == <span class="number">-1</span> ? <span class="built_in">move</span>[x] = x : <span class="built_in">move</span>[x] = findPos(b + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minIncrementForUnique</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(<span class="built_in">move</span>, <span class="number">-1</span>, <span class="keyword">sizeof</span> <span class="built_in">move</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : A) &#123;</span><br><span class="line">            ans += findPos(x) - x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定整数数组 A，每次 &lt;em&gt;move&lt;/em&gt; 操作将会选择任意 &lt;code&gt;A[i]&lt;/code&gt;，并将其递增 &lt;code&gt;1&lt;/co
      
    
    </summary>
    
      <category term="刷题" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
      <category term="LeetCode" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/LeetCode/"/>
    
    
      <category term="数组" scheme="965087276.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer-旋转数组的最小数字</title>
    <link href="965087276.github.io/2020/03/22/%E5%89%91%E6%8C%87Offer-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <id>965087276.github.io/2020/03/22/剑指Offer-旋转数组的最小数字/</id>
    <published>2020-03-22T02:16:32.000Z</published>
    <updated>2020-05-15T01:33:49.519Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组（存在重复元素）的一个旋转，输出旋转数组的最小元素。例如，数组 <code>[3,4,5,1,2]</code> 为 <code>[1,2,3,4,5]</code> 的一个旋转，该数组的最小值为1。 </p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[3,4,5,1,2]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>采用二分法，设  $l$ , $r$ 分别指向数组左右两端，$mid$ 为数组的中点</p><p>那么这道题的关键在于怎么用 $l, r, mid$ 这三个位置的数值判断出最小值是位于 $mid$ 的左边还是右边</p><ul><li><p>用左边位置 $l$ 和中间位置 $mid$ 比较可以吗？</p><p>答案是不可以。这个数组可以看作是两段 非递减的数据 拼接起来的。像 <code>[3, 4, 5, 1, 2]</code>  与  <code>[1, 2, 3, 4, 5]</code> ，中间位置的值都比左边大，但最小值一个在后面，一个在前面，因此这种做法不可以。</p></li><li><p>用右边位置 $r$ 和中间位置 $mid$ 比较可以吗？</p><p>答案是可以的。<code>[1, 2, 3, 4, 5]  [3, 4, 5, 1, 2]  [2, 3, 4, 5 ,4]  [10, 1, 10, 10, 10]</code>；当中间位置大于右边位置时，最小值一定在右边；当中间位置大于左边位置时，最小值一定在左边；当中间位置等于右边位置时，不能判断最小值在哪边，但是可以排除右端点。</p></li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minArray</span><span class="params">(self, numbers: List[int])</span> -&gt; int:</span></span><br><span class="line">    l, r = <span class="number">0</span>, len(numbers) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="comment"># 最小值一定在右边</span></span><br><span class="line">        <span class="keyword">if</span> numbers[mid] &gt; numbers[r]: l = mid + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 最小值一定在左边（也可能是 numbers[mid]）</span></span><br><span class="line">        <span class="keyword">elif</span> numbers[mid] &lt; numbers[r]: r = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 最小值一定在左边</span></span><br><span class="line">            <span class="keyword">if</span> numbers[mid] &gt; numbers[l]: r = mid - <span class="number">1</span></span><br><span class="line">            <span class="comment"># numbers[mid] == numbers[l] 此时不能判断最小值在哪边 </span></span><br><span class="line">            <span class="keyword">else</span>: r = r - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> numbers[r]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组（存在重复元素）的一个旋转，输出旋转数组的最小元素。
      
    
    </summary>
    
      <category term="刷题" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
      <category term="剑指Offer" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="二分搜索" scheme="965087276.github.io/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer—重建二叉树</title>
    <link href="965087276.github.io/2020/03/20/%E5%89%91%E6%8C%87Offer%E2%80%94%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>965087276.github.io/2020/03/20/剑指Offer—重建二叉树/</id>
    <published>2020-03-20T06:54:42.000Z</published>
    <updated>2020-05-15T01:34:15.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p>例如，给出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">前序遍历 preorder &#x3D; [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br></pre></td></tr></table></figure><p>返回如下的二叉树</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>首先回顾一下前序遍历和中序遍历</p><ul><li>前序遍历顺序：根节点，左子树，右子树</li><li>中序遍历顺序：左子树，根节点，右子树</li></ul><p>本体的思路是，首先找到二叉树的根节点，然后找到其左子树和右子树，并对其左右子树递归地执行前面的操作。</p><p>根节点很容易找：前序遍历中的第一个节点就是根节点（例如上例中的 3）。</p><p>左子树和右子树怎么着呢？在中序遍历中，我们找到根节点所在的位置，这个位置左边的都是左子树（例如上例中的 9），右边的都是右子树（例如上例中的15 20 7）。假设这样找出的左子树有 $x$ 个节点，右子树有 $y$ 个节点，那么在前序遍历的序列中去掉根节点后，前 $x$ 个元素就是左子树，剩下的元素就是右子树。这样我们就可以递归地进行求解了。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = preorder.length;</span><br><span class="line">        <span class="keyword">return</span> buildTree(preorder, inorder, <span class="number">0</span>, n-<span class="number">1</span>, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> l1, <span class="keyword">int</span> r1, <span class="keyword">int</span> l2, <span class="keyword">int</span> r2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 &gt; r1 || l2 &gt; r2) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[l1]);</span><br><span class="line">        <span class="keyword">int</span> p = l2;</span><br><span class="line">        <span class="comment">// 找到中序遍历中 根节点 的位置，存于p中</span></span><br><span class="line">        <span class="keyword">while</span> (inorder[p] != preorder[l1]) p++;</span><br><span class="line">        <span class="comment">// 左子树的个数</span></span><br><span class="line">        <span class="keyword">int</span> leftNum = p - l2;</span><br><span class="line">        <span class="comment">// 右子树的个数：(r2 - l2 + 1) - leftNum - 1</span></span><br><span class="line">        <span class="keyword">int</span> rightNum = r2 - p;</span><br><span class="line">        root.left = buildTree(preorder, inorder, l1 + <span class="number">1</span>, l1 + leftNum, l2, p - <span class="number">1</span>);</span><br><span class="line">        root.right = buildTree(preorder, inorder, l1 + leftNum + <span class="number">1</span>, r1, p + <span class="number">1</span>, r2);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。&lt;/p&gt;
&lt;p&gt;例如，给出&lt;/
      
    
    </summary>
    
      <category term="刷题" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
      <category term="剑指Offer" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="二叉树" scheme="965087276.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer—数组中重复的数字</title>
    <link href="965087276.github.io/2020/03/16/%E5%89%91%E6%8C%87Offer%E2%80%94%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>965087276.github.io/2020/03/16/剑指Offer—数组中重复的数字/</id>
    <published>2020-03-16T10:26:44.000Z</published>
    <updated>2020-05-15T01:33:32.342Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p><strong>样例1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">2 或 3</span><br></pre></td></tr></table></figure><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这个题有个关键点：<strong>所有数组都在 0～n-1 的范围内</strong>。</p><p>那么在没有重复数字的情况下，我们可以通过下面的算法使得对每个下标 $i$ 都有 $nums[i] = i$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若nums[i] != i, 则将 nums[i] 放在位置 nums[i]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums[i].<span class="built_in">size</span>(); i++) <span class="keyword">if</span> (nums[i] != i)</span><br><span class="line">    swap(nums[i], nums[nums[i]]);</span><br></pre></td></tr></table></figure><p>在有重复数字的情况下，必然存在一个 $nums[i]$，在执行上述代码第3行前，已经有 $nums[i] == nums[nums[i]]$ 了，此时这个 $nums[i]$ 就是一个重复数字</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) <span class="keyword">if</span> (nums[i] != i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[nums[i]] == nums[i]) <span class="keyword">return</span> nums[i];</span><br><span class="line">        swap(nums[i], nums[nums[i]]); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了
      
    
    </summary>
    
      <category term="刷题" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
      <category term="剑指Offer" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="数组" scheme="965087276.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>23种设计模式-装饰者模式</title>
    <link href="965087276.github.io/2020/02/20/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>965087276.github.io/2020/02/20/23种设计模式-装饰者模式/</id>
    <published>2020-02-20T10:47:10.000Z</published>
    <updated>2020-05-03T06:01:41.675Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>装饰(Decorator)模式属于“单一职责”模式的一种，它讲的是在软件组件的设计中，如果责任划分的不清晰，那么使用继承得到的结果往往是随着需求的变化，子类急剧膨胀，同时充斥着大量重复代码（也叫代码的bad smell），这时候的关键是划清责任。</p><p>当然，这里并不是说别的模式就没有责任问题了。只是装饰者模式，以及后面要说的桥(Bridge)模式，这两个模式在责任的问题上表现得特别突出，因此把它们俩划分到单一职责模式类别中。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>假设我们在设计一个IO的库，就是一些流操作。针对这些流操作呢，我们有一些需求，比如说，我们需要有针对文件的的文件流、针对内存的内存流以及针对网络的网络流，也需要有一些对流进行加密、缓冲等等各种操作。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>这个时候我们可能很快会想到，关于流的操作，我们需要有一个基类，这个基类里呢需要有一些读(read)、写(write)以及定位(seek)等等这样一些公共操作，我们将这些操作定义成抽象方法。（这里也可以用接口，但是因为装饰者模式一般都用抽象类，所以这里就使用了抽象类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stream</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">char</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> number)</span></span>;</span><br><span class="line">    <span class="comment">// 定位</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>;</span><br><span class="line">    <span class="comment">// 写</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> data)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么接下来，针对文件流，我们去继承Stream基类，然后去实现这三个方法(这里为了简便起见，就不具体实现每个方法了)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileStream</span> <span class="keyword">extends</span> <span class="title">Stream</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 读文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">seek</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定位文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 写文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同样的，针对网络流和内存流，我们也去继承Stream基类并去实现这三个方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkStream</span> <span class="keyword">extends</span> <span class="title">Stream</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 读网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">seek</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定位网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 写网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryStream</span> <span class="keyword">extends</span> <span class="title">Stream</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 读内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">seek</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定位内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 写内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来，我们需要去考虑加密、缓冲等拓展操作。但是我们会发现，这些拓展操作是不能单独存在的。比如说，加密，我们很难说对一个流直接进行加密，我们需要先把数据从流中读出来然后在这基础上对这些数据进行加密。所以说这里的对流加密其实是针对数据的加密，对于缓冲来说也是一样。也就是说，这些拓展操作需要在对流先进行一个主体操作后才能进行。</p><p>在上面我们已经定义了三种不同的流类型：文件流、网络流、内存流。因此，加密和缓冲也要在这三种流的基础上进行。</p><p>那么我们怎么做呢？我们这里针对文件流的加密定义一个“加密文件流”类，这个类去继承FileStream类，然后在FileStream这个类的基础上作加密操作</p><p>如下面的代码所示，我们去Override父类的三个方法。对于read()方法，我们先调用<strong>父类</strong>的read()方法读取数据，然后对读取的数据再进行一些加密操作后返回；对于write()方法，我们可能要在写数据前进行加密；对于seek()方法，我们可能前后都要加密。这里为了方便起见，在代码用注释来表示加密的过程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CryptoFileStream</span> <span class="keyword">extends</span> <span class="title">FileStream</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.read(number); <span class="comment">// 读文件流</span></span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seek</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">        <span class="keyword">super</span>.seek(position); <span class="comment">// 定位文件流</span></span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">        <span class="keyword">super</span>.write(data); <span class="comment">// 写文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不只是文件流需要有加密操作，网络流和内存流也需要加密操作，我们按照相同的方法定义网络流和内存流的加密操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CryptoNetworkStream</span> <span class="keyword">extends</span> <span class="title">NetworkStream</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.read(number); <span class="comment">// 读网络流</span></span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seek</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">        <span class="keyword">super</span>.seek(position); <span class="comment">// 定位网络流</span></span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">        <span class="keyword">super</span>.write(data); <span class="comment">// 写网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CryptoMemoryStream</span> <span class="keyword">extends</span> <span class="title">MemoryStream</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.read(number); <span class="comment">// 读内存流</span></span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seek</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">        <span class="keyword">super</span>.seek(position); <span class="comment">// 定位内存流</span></span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">        <span class="keyword">super</span>.write(data); <span class="comment">// 写内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同样的道理，对于缓冲(Buffer)，我们也要考虑对文件流进行缓冲、对网络流进行缓冲、对内存流进行缓冲，因此我们也要定义针对这三种流的缓冲操作的类。（这里为了方便，代码中就不写具体的实现了）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BufferedFileStream extends FileStream &#123;</span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> BufferedNetworkStream extends NetworkStream &#123;</span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> BufferedMemoryStream extends MemoryStream &#123;</span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么再往后呢，我们还可能有对文件流即进行加密又进行缓冲的双重操作需求，那么这时候我们可能要新建一个CryptoBufferedFileStream类，这个类去继承FileStream, 或是去继承CryptoFileStream和BufferedFileStream中的一种来完成这个需求。这里我们采用继承FileStream的方式，代码可能是这样子的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CryptoBufferedFileStream extends FileStream &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.read(number); <span class="comment">// 读文件流</span></span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">        <span class="comment">// 额外的缓冲操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seek</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">        <span class="comment">// 额外的缓冲操作</span></span><br><span class="line">        <span class="keyword">super</span>.seek(position); <span class="comment">// 定位文件流</span></span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">        <span class="comment">// 额外的缓冲操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">        <span class="comment">// 额外的缓冲操作</span></span><br><span class="line">        <span class="keyword">super</span>.write(data); <span class="comment">// 写文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="问题及优化"><a href="#问题及优化" class="headerlink" title="问题及优化"></a>问题及优化</h4><p>那么到这里了，我们来看一下，以上的这些设计有没有什么问题呢？既然这么说了，它当然是有问题的，我们来分析一下它有什么毛病。</p><p>首先，我们来看一下目前类的结构<br><img src="1.png" alt=""><br>类图的最上方是我们刚开始定义的Stream基类，然后分别定义了文件流(FileStream)、网络流(NetWorkStream)、内存流(MemoryStream)这三个基本的流的类，下面是根据对流的各种拓展操作（加密、缓冲）定义的拓展类。</p><p>那么这个类的规模有多大呢。我们可以来算一下</p><ol><li>首先类图第一层Stream类是$1$个类</li><li>接下来我们假设像FileStream、NetWorkStream、MemoryStream等等流的种类共有$n$种；那么类图的第一层和第二层共有$1+n$个类</li><li>接下来看第三层，我假设对流的操作（加密、缓冲等等）的种类共有$m$种。那么对于$n$种流中的每一种，我们都可以选择$1$至$m$种操作附加在上面，因此仅针对一种流的操作，就需要有<script type="math/tex; mode=display">C_m^1 + C_m^2 + C_m^3 + ... + C_m^m = 2^m-1</script>$2^m-1$个类，因此第三层总共有$n * (2^m - 1)$个类。</li></ol><p>因此三层加起来类的总数目为</p><script type="math/tex; mode=display">1+n+n * (2^m - 1) = 1 + n*2^m</script><p>可以看出类的数目是随着$n, m$的增加呈指数级增长的，可以说这个规模是相当庞大了。在我们这个例子里, $n=3, m=2$, 因此总共有$1+3*2^2=13$个类，这还不算太多。但如果稍微增加一下，让$n=5, m=5$，这个时候类的数目就达到了惊人的161个。</p><p>除了类的数量问题，还有一个比较严重的问题，我们来看一下代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加密文件流</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CryptoFileStream</span> <span class="keyword">extends</span> <span class="title">FileStream</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.read(number); <span class="comment">// 读文件流</span></span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seek</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">        <span class="keyword">super</span>.seek(position); <span class="comment">// 定位文件流</span></span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">        <span class="keyword">super</span>.write(data); <span class="comment">// 写文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加密网络流</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CryptoNetworkStream</span> <span class="keyword">extends</span> <span class="title">NetworkStream</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.read(number); <span class="comment">// 读网络流</span></span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seek</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">        <span class="keyword">super</span>.seek(position); <span class="comment">// 定位网络流</span></span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">        <span class="keyword">super</span>.write(data); <span class="comment">// 写网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加密内存流</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CryptoMemoryStream</span> <span class="keyword">extends</span> <span class="title">MemoryStream</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.read(number); <span class="comment">// 读内存流</span></span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seek</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">        <span class="keyword">super</span>.seek(position); <span class="comment">// 定位内存流</span></span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">        <span class="keyword">super</span>.write(data); <span class="comment">// 写内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里我们再次展示了加密文件流、加密网络流以及加密内存流这三个类的代码。从这三个类的代码里，我们可以发现，这三个类的read()方法、seek()方法以及write()方法的代码相互之间都是完全一样的（<strong>注意</strong>：这里的加密操作不会因为流的不同而不同，对所有流都是一样的），因此这里面有代码重复问题。</p><p>既然重复了，我们就要想办法消除重复。首先，我们作一个变换，我们把继承去掉，换成相应类的实例变量，如下所示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加密文件流</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CryptoFileStream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> FileStream stream;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        stream.read(number); <span class="comment">// 读文件流</span></span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seek</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">        stream.seek(position); <span class="comment">// 定位文件流</span></span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">        stream.write(data); <span class="comment">// 写文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加密网络流</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CryptoNetworkStream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> NetWorkStream stream;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        stream.read(number); <span class="comment">// 读网络流</span></span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seek</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">        stream.seek(position); <span class="comment">// 定位网络流</span></span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">        stream.write(data); <span class="comment">// 写网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加密内存流</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CryptoMemoryStream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MemoryStream stream;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.read(number); <span class="comment">// 读内存流</span></span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seek</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">        <span class="keyword">super</span>.seek(position); <span class="comment">// 定位内存流</span></span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">        <span class="keyword">super</span>.write(data); <span class="comment">// 写内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这时候，每个类只有第一行代码是不一样的，我们把它们拿出来看一下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> FileStream stream;</span><br><span class="line"><span class="keyword">private</span> NetworkStream stream;</span><br><span class="line"><span class="keyword">private</span> MemoryStream stream;</span><br></pre></td></tr></table></figure><br>这三行的唯一的区别就是变量的声明类型不同。在《重构》那本书里有一句话：当一个变量的声明类型都是某个类型A的子类的时候，你就应该把它声明成类型A。<br>在这里，FileStream、NetWorkStream、MemoryStream都是Stream的子类。因此，我们将这三行代码的声明类型都改为Stream类型。然后，我们就可以利用到多态的性质，在将来给它传入相应的子类型。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加密文件流</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CryptoFileStream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stream stream; <span class="comment">// 将来让它 = FileStream类型</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        stream.read(number); <span class="comment">// 读文件流</span></span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seek</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">        stream.seek(position); <span class="comment">// 定位文件流</span></span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">        stream.write(data); <span class="comment">// 写文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加密网络流</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CryptoNetworkStream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stream stream; <span class="comment">// 将来让它 = NetworkStream类型</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        stream.read(number); <span class="comment">// 读网络流</span></span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seek</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">        stream.seek(position); <span class="comment">// 定位网络流</span></span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">        stream.write(data); <span class="comment">// 写网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加密内存流</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CryptoMemoryStream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stream stream; <span class="comment">// 将来让它 = MemoryStream类型</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.read(number); <span class="comment">// 读内存流</span></span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seek</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">        <span class="keyword">super</span>.seek(position); <span class="comment">// 定位内存流</span></span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">        <span class="keyword">super</span>.write(data); <span class="comment">// 写内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样改造之后呢，我们又发现，现在上面这三个类的代码完全一样了（除了类名）。既然完全一样，那干嘛还要三个类，我们就只需要保留一个就可以了。我们将保留的那一个类的类名改为CryptoStream。类里的Stream成员，将来可以根据需要，灵活地赋值成FileStream、MemoryStream或NetworkStream。我们把构造函数也加上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加密流</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CryptoStream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将来让它 = MemoryStream类型 </span></span><br><span class="line">    <span class="comment">// 或        MemoryStream类型 </span></span><br><span class="line">    <span class="comment">// 或        MemoryStream类型</span></span><br><span class="line">    <span class="keyword">private</span> Stream stream;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stream</span><span class="params">(Stream stream)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stream = stream;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.read(number); <span class="comment">// 读内存流</span></span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seek</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">        <span class="keyword">super</span>.seek(position); <span class="comment">// 定位内存流</span></span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">        <span class="keyword">super</span>.write(data); <span class="comment">// 写内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样修改之后，其实还有一个注意事项。类里的read()、seek()、write()方法原先是怎么来的？是因为我们要去拓展Stream类的这三个方法的功能，也就是说这三个方法是CryptoStream类的必须要有的。为了确保我们一定会去覆写Stream抽象类的这三个方法，我们让CryptoStream再去继承Stream抽象类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加密流</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CryptoStream</span> <span class="keyword">extends</span> <span class="title">Stream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将来让它 = FileStream类型 </span></span><br><span class="line">    <span class="comment">// 或        MemoryStream类型 </span></span><br><span class="line">    <span class="comment">// 或        NetworkStream类型</span></span><br><span class="line">    <span class="keyword">private</span> Stream stream;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stream</span><span class="params">(Stream stream)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stream = stream;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.read(number); <span class="comment">// 读内存流</span></span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seek</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">        <span class="keyword">super</span>.seek(position); <span class="comment">// 定位内存流</span></span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">        <span class="keyword">super</span>.write(data); <span class="comment">// 写内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意这是个很奇怪的地方，在这里我们既继承了Stream类，又组合（包含）了一个Stream类型的实例。但是这两者的作用是不一样的。这里的继承是为了完善Stream接口（抽象类）的规范，这里的组合是为了将来通过多态可以支持调用FileStream、NetworkStream以及MemoryStream。</p><p>同样，我们对缓冲流也进行相应的修改。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓冲流</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedStream</span> <span class="keyword">extends</span> <span class="title">Stream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将来让它 = FileStream类型 </span></span><br><span class="line">    <span class="comment">// 或        NetworkStream类型 </span></span><br><span class="line">    <span class="comment">// 或        MemoryStream类型</span></span><br><span class="line">    <span class="keyword">private</span> Stream stream;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stream</span><span class="params">(Stream stream)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stream = stream;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.read(number); <span class="comment">// 读内存流</span></span><br><span class="line">        <span class="comment">// 额外的缓冲操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seek</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 额外的缓冲操作</span></span><br><span class="line">        <span class="keyword">super</span>.seek(position); <span class="comment">// 定位内存流</span></span><br><span class="line">        <span class="comment">// 额外的缓冲操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 额外的缓冲操作</span></span><br><span class="line">        <span class="keyword">super</span>.write(data); <span class="comment">// 写内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>到这里，问题已经解决的差不多了。我们现在来测试一下。</p><p>我们先建立一个文件流，然后对其进行操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileStream s1 = <span class="keyword">new</span> FileStream();</span><br></pre></td></tr></table></figure></p><p>我们现在想对文件流加密，怎么做呢？在最初的实现中，我们建立了一个CryptoFileStream类来完成这个功能，这其实是将文件流和对文件的加密这两个功能在编译时装配起来。而现在，我们不需要这么做，我们在运行阶段向CryptoStream中传入一个FileStream对象，这个叫做运行时装配。也就是说，在编译时，我们并没有诸如“加密文件流、缓冲文件流、加密缓冲文件流”这些类，但是我们可以在运行时通过组合的方式把它们装配出来，以满足需求。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FileStream s1 = <span class="keyword">new</span> FileStream();</span><br><span class="line"><span class="comment">// 运行时装配</span></span><br><span class="line">CryotoStream s2 = <span class="keyword">new</span> CryStream(s1);</span><br></pre></td></tr></table></figure><br>接下来对流s1进行缓存操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BufferedStream s3 = <span class="keyword">new</span> BufferedStream(s1);</span><br></pre></td></tr></table></figure><br>我们还可以对流s1既进行加密又进行缓存<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BufferedStream s4 = <span class="keyword">new</span> BufferedStream(s2);</span><br></pre></td></tr></table></figure><br>目前我们类的结构如下<br><img src="2.png" alt=""></p><p>还可以做得更好一点，我们看加密流和缓冲流的这两个子类的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加密流</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CryptoStream</span> <span class="keyword">extends</span> <span class="title">Stream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将来让它 = FileStream类型 </span></span><br><span class="line">    <span class="comment">// 或        MemoryStream类型 </span></span><br><span class="line">    <span class="comment">// 或        NetworkStream类型</span></span><br><span class="line">    <span class="keyword">private</span> Stream stream;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stream</span><span class="params">(Stream stream)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stream = stream;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.read(number); <span class="comment">// 读内存流</span></span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seek</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">        <span class="keyword">super</span>.seek(position); <span class="comment">// 定位内存流</span></span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">        <span class="keyword">super</span>.write(data); <span class="comment">// 写内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓冲流</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedStream</span> <span class="keyword">extends</span> <span class="title">Stream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将来让它 = FileStream类型 </span></span><br><span class="line">    <span class="comment">// 或        NetworkStream类型 </span></span><br><span class="line">    <span class="comment">// 或        MemoryStream类型</span></span><br><span class="line">    <span class="keyword">private</span> Stream stream;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stream</span><span class="params">(Stream stream)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stream = stream;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.read(number); <span class="comment">// 读内存流</span></span><br><span class="line">        <span class="comment">// 额外的缓冲操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seek</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 额外的缓冲操作</span></span><br><span class="line">        <span class="keyword">super</span>.seek(position); <span class="comment">// 定位内存流</span></span><br><span class="line">        <span class="comment">// 额外的缓冲操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 额外的缓冲操作</span></span><br><span class="line">        <span class="keyword">super</span>.write(data); <span class="comment">// 写内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这两个类都有一个Stream实例。按照《重构》中的理论，如果一个父类（Stream）的两个或多个子类(BufferedStream、CrytpoStream)中都有同样的字段(Stream stream)时，应该把这个字段往上提。</p><p>那么提到哪里呢，提到Stream中肯定是不行的。因为FileStream类也是Stream的子类，而FileStream是不需要stream实例的。因此，这里就只能设置一个中间类了，这个中间类作为BufferedStream和CrytpoStream的父类，同时去继承Stream类。这个中间类也就是装饰者模式中抽象装饰者类，作为所有装饰者类的基类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Decorator extends Stream &#123;</span><br><span class="line">    <span class="keyword">protected</span> Stream stream;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Stream stream)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stream = stream;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">char</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> number)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> data)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改造之后，两个子类的代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加密流</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CryptoStream</span> <span class="keyword">extends</span> <span class="title">DecoratorStream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stream</span><span class="params">(Stream stream)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(stream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.read(number); <span class="comment">// 读内存流</span></span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seek</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">        <span class="keyword">super</span>.seek(position); <span class="comment">// 定位内存流</span></span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">        <span class="keyword">super</span>.write(data); <span class="comment">// 写内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓冲流</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedStream</span> <span class="keyword">extends</span> <span class="title">DecoratorStream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stream</span><span class="params">(Stream stream)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(stream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.read(number); <span class="comment">// 读内存流</span></span><br><span class="line">        <span class="comment">// 额外的缓冲操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seek</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 额外的缓冲操作</span></span><br><span class="line">        <span class="keyword">super</span>.seek(position); <span class="comment">// 定位内存流</span></span><br><span class="line">        <span class="comment">// 额外的缓冲操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 额外的缓冲操作</span></span><br><span class="line">        <span class="keyword">super</span>.write(data); <span class="comment">// 写内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h4><p>好嘞，现在装饰者就算大功告成了。我们重新捋一遍代码</p><p>首先，我们定义了一个Stream基类(抽象类），包含一些通用的需求<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stream</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">char</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> number)</span></span>;</span><br><span class="line">    <span class="comment">// 定位</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>;</span><br><span class="line">    <span class="comment">// 写</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> data)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然后，分别实现了文件流、网络流、内存流三个具体的流。这三个类在装饰者模式中被称作“被装饰者”<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件流</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileStream</span> <span class="keyword">extends</span> <span class="title">Stream</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 读文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">seek</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定位文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 写文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 网络流</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkStream</span> <span class="keyword">extends</span> <span class="title">Stream</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 读网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">seek</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定位网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 写网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存流</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryStream</span> <span class="keyword">extends</span> <span class="title">Stream</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 读内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">seek</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定位内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 写内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>定义了一个抽象的装饰者类，继承自Stream类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Decorator extends Stream &#123;</span><br><span class="line">    <span class="keyword">protected</span> Stream stream;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Stream stream)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stream = stream;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">char</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> number)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> data)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后是”加密流、缓冲流”两个类，这两个类在装饰者模式中被称为“装饰者”<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加密流</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CryptoStream</span> <span class="keyword">extends</span> <span class="title">DecoratorStream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stream</span><span class="params">(Stream stream)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(stream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.read(number); <span class="comment">// 读内存流</span></span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seek</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">        <span class="keyword">super</span>.seek(position); <span class="comment">// 定位内存流</span></span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 额外的加密操作</span></span><br><span class="line">        <span class="keyword">super</span>.write(data); <span class="comment">// 写内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓冲流</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedStream</span> <span class="keyword">extends</span> <span class="title">DecoratorStream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stream</span><span class="params">(Stream stream)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(stream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.read(number); <span class="comment">// 读内存流</span></span><br><span class="line">        <span class="comment">// 额外的缓冲操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seek</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 额外的缓冲操作</span></span><br><span class="line">        <span class="keyword">super</span>.seek(position); <span class="comment">// 定位内存流</span></span><br><span class="line">        <span class="comment">// 额外的缓冲操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 额外的缓冲操作</span></span><br><span class="line">        <span class="keyword">super</span>.write(data); <span class="comment">// 写内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="3.png" alt=""></p><h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><h4 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h4><p>在某些情况下我们可能会“过度地使用继承来扩展对象的功能”，由于继承为类型引入的<strong>静态特质</strong>，使得这种扩展方式缺乏灵活性；并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多子类的膨胀。</p><p>如何使“对象功能的扩展”能够根据需要来动态地实现？同时避免“扩展功能的增多”带来的子类膨胀问题？从而使得任何“功能扩展变化”所导致的影响将为最低？</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>来看一下GoF中的定义</p><blockquote><p>动态（组合）地给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类（继承）更为灵活（消除重复代码 &amp; 减少子类个数）。</p></blockquote><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src="4.png" alt=""><br>这里的Component是实例中的Stream类；Decorator是实例中的DecoratorStream类。</p><h3 id="要点总结"><a href="#要点总结" class="headerlink" title="要点总结"></a>要点总结</h3><ol><li>通过采用组合而非继承的手法， Decorator模式实现了在运行时动态扩展对象功能的能力，而且可以根据需要扩展多个功能。避免了使用继承带来的“灵活性差”和“多子类衍生问题”。</li><li>Decorator类在接口上表现为is-a Component的继承关系，即Decorator类继承了Component类所具有的接口。但在实现上又表现为has-a Component的组合关系，即Decorator类又使用了另外一个Component类。</li><li>Decorator模式的目的并非解决“多子类衍生的多继承”问题，Decorator模式应用的要点在于解决“主体类在多个方向上的扩展功能”——是为“装饰”的含义。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h3&gt;&lt;p&gt;装饰(Decorator)模式属于“单一职责”模式的一种，它讲的是在软件组件的设计中，如果责任划分的不清晰，那么使用继承得到的结果往往是随着
      
    
    </summary>
    
      <category term="设计模式" scheme="965087276.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>spark学习-RDD</title>
    <link href="965087276.github.io/2020/02/17/spark%E5%AD%A6%E4%B9%A0-RDD/"/>
    <id>965087276.github.io/2020/02/17/spark学习-RDD/</id>
    <published>2020-02-17T05:08:09.000Z</published>
    <updated>2020-05-03T06:01:41.688Z</updated>
    
    <content type="html"><![CDATA[<!-- <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script> --><h1 id="Spark-RDD"><a href="#Spark-RDD" class="headerlink" title="Spark-RDD"></a>Spark-RDD</h1><p>摘自spark中文文档及官方英文文档</p><blockquote><p><a href="https://spark-reference-doc-cn.readthedocs.io/zh_CN/latest/programming-guide/rdd-guide.html" target="_blank" rel="noopener">https://spark-reference-doc-cn.readthedocs.io/zh_CN/latest/programming-guide/rdd-guide.html</a><br><a href="https://spark.apache.org/docs/latest/rdd-programming-guide.html#rdd-persistence" target="_blank" rel="noopener">https://spark.apache.org/docs/latest/rdd-programming-guide.html#rdd-persistence</a></p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>使用spark时要先创建一个<strong>JavaSparkContext</strong>对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// appName为应用名称，这个名称会显示在cluster UI界面上</span></span><br><span class="line"><span class="comment">// 关于master参数可参考https://spark.apache.org/docs/latest/submitting-applications.html#master-urls</span></span><br><span class="line">SparkConf conf = <span class="keyword">new</span> SparkConf().setAppName(appName).setMaster(master);</span><br><span class="line">JavaSparkContext sc = <span class="keyword">new</span> JavaSparkContext(conf);</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="Resilient-Distributed-Datasets-RDDs"><a href="#Resilient-Distributed-Datasets-RDDs" class="headerlink" title="Resilient Distributed Datasets (RDDs)"></a>Resilient Distributed Datasets (RDDs)</h2><p>RDD是一个可容错、可并行操作的分布式元素集合。总体上有两种方法可以创建 RDD 对象：由驱动程序中的集合对象通过并行化操作创建，或者从外部存储系统中数据集加载（如：共享文件系统、HDFS、HBase或者其他Hadoop支持的数据源）。</p><h3 id="并行集合"><a href="#并行集合" class="headerlink" title="并行集合"></a>并行集合</h3><p>并行集合的创建：调用<strong>JavaSparkContext的parallelize</strong>方法来创建，传入一个已有的集合对象作为参数。集合对象中所有的元素都将被复制到一个可并行操作的分布式数据集中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; data = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">JavaRDD&lt;Integer&gt; distData = sc.parallelize(data);</span><br></pre></td></tr></table></figure><br>并行集合一个重要参数是<strong>partitions</strong>分区数，spark的每个任务（task）都是基于partition的，每个分区一个对应的任务（task）。典型场景下，一般每个CPU对应2~4个分区。并且一般而言，Spark会基于集群的情况，自动设置这个分区数。当然，你还是可以手动控制这个分区数，只需给parallelize方法再传一个参数即可（如：sc.parallelize(data, 10) ）</p><h3 id="外部数据集"><a href="#外部数据集" class="headerlink" title="外部数据集"></a>外部数据集</h3><p>例如读取文件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JavaRDD&lt;String&gt; distFile = sc.textFile(<span class="string">"data.txt"</span>);</span><br></pre></td></tr></table></figure></p><h3 id="RDD-Operation"><a href="#RDD-Operation" class="headerlink" title="RDD Operation"></a>RDD Operation</h3><p>RDD支持两种类型的算子</p><ol><li><strong>transformations</strong>: 将一个已有的RDD转换成一个新的RDD,例如<strong>map</strong>操作</li><li><strong>action</strong>: 基于RDD的计算，并将结果返回给驱动器(driver), 例如<strong>reduce</strong>操作 </li></ol><p>所有的<strong>transformations</strong>算子都是懒惰(lazy)运算。只有当action算子需要结果时才计算。</p><blockquote><p>All transformations in Spark are lazy, in that they do not compute their results right away. Instead, they just remember the transformations applied to some base dataset (e.g. a file). The transformations are only computed when an action requires a result to be returned to the driver program. This design enables Spark to run more efficiently. For example, we can realize that a dataset created through map will be used in a reduce and return only the result of the reduce to the driver, rather than the larger mapped dataset.</p></blockquote><p>默认情况下，在执行<strong>action</strong>算子时，每个<strong>transformed RDD</strong>都会被重新计算，这可能比较耗费时间。因此，可以将这些RDD持久化(persist)到内存中来节省下一次的时间。</p><h3 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h3><p>考虑下面的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JavaRDD&lt;String&gt; lines = sc.textFile(<span class="string">"data.txt"</span>);</span><br><span class="line">JavaRDD&lt;Integer&gt; lineLengths = lines.map(s -&gt; s.length());</span><br><span class="line"><span class="keyword">int</span> totalLength = lineLengths.reduce((a, b) -&gt; a + b);</span><br></pre></td></tr></table></figure><br>其中，第一行是从外部文件加载数据，并创建一个基础RDD。这时候，数据集并没有加载进内存除非有其他操作施加于lines，这时候的lines RDD其实可以说只是一个指向 data.txt 文件的指针。第二行，用lines通过map转换得到一个lineLengths RDD，同样，lineLengths也是懒惰计算的。最后，我们使用 reduce算子计算长度之和，reduce是一个action算子。此时，Spark将会把计算分割为一些小的任务，分别在不同的机器上运行，每台机器上都运行相关的一部分map任务，并在本地进行reduce，并将这些reduce结果都返回给驱动器。</p><p>如果后续我们想复用lineLengths, 可以在第三行前加一句<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lineLengths.persist(StorageLevel.MEMORY_ONLY());</span><br></pre></td></tr></table></figure><br>这样的话lineLengths在第一次计算完成后，spark会将它保存在内存中。</p><h3 id="Passing-Functions-to-Spark"><a href="#Passing-Functions-to-Spark" class="headerlink" title="Passing Functions to Spark"></a>Passing Functions to Spark</h3><p>一些较复杂的操作，可以定义成函数（Function）传递给spark。这里需要实现spark的Function接口。<br><a href="https://spark.apache.org/docs/latest/api/java/index.html?org/apache/spark/api/java/function/package-summary.html" target="_blank" rel="noopener">https://spark.apache.org/docs/latest/api/java/index.html?org/apache/spark/api/java/function/package-summary.html</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JavaRDD&lt;String&gt; lines = sc.textFile(<span class="string">"data.txt"</span>);</span><br><span class="line">JavaRDD&lt;Integer&gt; lineLengths = lines.map(<span class="keyword">new</span> Function&lt;String, Integer&gt;() &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">(String s)</span> </span>&#123; <span class="keyword">return</span> s.length(); &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">int</span> totalLength = lineLengths.reduce(<span class="keyword">new</span> Function2&lt;Integer, Integer, Integer&gt;() &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">(Integer a, Integer b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>也可以写在外边<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetLength</span> <span class="keyword">implements</span> <span class="title">Function</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">(String s)</span> </span>&#123; <span class="keyword">return</span> s.length(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sum</span> <span class="keyword">implements</span> <span class="title">Function2</span>&lt;<span class="title">Integer</span>, <span class="title">Integer</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">(Integer a, Integer b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JavaRDD&lt;String&gt; lines = sc.textFile(<span class="string">"data.txt"</span>);</span><br><span class="line">JavaRDD&lt;Integer&gt; lineLengths = lines.map(<span class="keyword">new</span> GetLength());</span><br><span class="line"><span class="keyword">int</span> totalLength = lineLengths.reduce(<span class="keyword">new</span> Sum());</span><br></pre></td></tr></table></figure></p><h3 id="Understanding-closures-闭包"><a href="#Understanding-closures-闭包" class="headerlink" title="Understanding closures(闭包)"></a>Understanding closures(闭包)</h3><p>Spark里一个比较难的事情就是，理解在整个集群上跨节点执行的变量和方法的作用域以及生命周期。Spark里一个频繁出现的问题就是RDD算子在变量作用域之外修改了其值。下面的例子，我们将会以foreach() 算子为例，来递增一个计数器counter，不过类似的问题在其他算子上也会出现。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">JavaRDD&lt;Integer&gt; rdd = sc.parallelize(data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wrong: Don't do this!!</span></span><br><span class="line">rdd.foreach(x -&gt; counter += x);</span><br><span class="line"></span><br><span class="line">println(<span class="string">"Counter value: "</span> + counter);</span><br></pre></td></tr></table></figure><p>在集群模式下，为了执行这个作业，Spark会将 RDD 算子的计算过程分割成多个独立的<strong>task</strong>, 每个task分发给一个<strong>executor</strong>去执行。而执行之前，Spark需要计算<strong>闭包</strong>。闭包是由执行器执行RDD算子（本例中的foreach()）时所需要的变量和方法组成的。闭包将会被<strong>序列化</strong>，并发送给每个executor。</p><p>在上面的例子中，闭包中的变量会跟随不同的闭包副本，发送到不同的executor上，所以等到foreach真正在executor上运行时，其引用的counter已经不再是驱动器上所定义的那个counter副本了，驱动器内存中仍然会有一个counter变量副本，但是这个副本对executor是不可见的！executor只能看到其所收到的序列化闭包中包含的counter副本。因此，最终驱动器上得到的counter将会是0。</p><p>为了确保类似这样的场景下，代码能有确定的行为，这里应该使用<strong>累加器（Accumulator）</strong>。累加器是Spark中专门用于集群跨节点分布式执行计算中，安全地更新同一变量的机制。</p><h4 id="打印RDD中的元素"><a href="#打印RDD中的元素" class="headerlink" title="打印RDD中的元素"></a>打印RDD中的元素</h4><p>另一种常见习惯是，试图用 rdd.foreach(println) 或者 rdd.map(println) 来打印RDD中所有的元素。如果是在单机上，这种写法能够如预期一样，打印出RDD所有元素。然后，在集群模式下，这些输出将会被打印到执行器的标准输出（stdout）上，因此驱动器的标准输出（stdout）上神马也看不到！如果真要在驱动器上把所有RDD元素都打印出来，你可以先调用collect算子，把RDD元素先拉到驱动器上来，代码可能是这样：rdd.collect().foreach(println)。不过如果RDD很大的话，有可能导致驱动器内存溢出，因为collect会把整个RDD都弄到驱动器所在单机上来；如果你只是需要打印一部分元素，那么take是更安全的选择：rdd.take(100).foreach(println)</p><h3 id="使用键值对"><a href="#使用键值对" class="headerlink" title="使用键值对"></a>使用键值对</h3><p>通过<strong>scala.Tuple2</strong>类来使用键值对。下面的代码统计了data.txt中每行文本出现的次数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JavaRDD&lt;String&gt; lines = sc.textFile(<span class="string">"data.txt"</span>);</span><br><span class="line">JavaPairRDD&lt;String, Integer&gt; pairs = lines.mapToPair(s -&gt; <span class="keyword">new</span> Tuple2(s, <span class="number">1</span>));</span><br><span class="line">JavaPairRDD&lt;String, Integer&gt; counts = pairs.reduceByKey((a, b) -&gt; a + b);</span><br></pre></td></tr></table></figure></p><h3 id="Transformation算子"><a href="#Transformation算子" class="headerlink" title="Transformation算子"></a>Transformation算子</h3><p>spark所支持的的转换算子列表参见<br><a href="https://spark.apache.org/docs/latest/rdd-programming-guide.html#transformations" target="_blank" rel="noopener">https://spark.apache.org/docs/latest/rdd-programming-guide.html#transformations</a></p><h3 id="action算子"><a href="#action算子" class="headerlink" title="action算子"></a>action算子</h3><p>spark所支持的action算子参见<br><a href="https://spark.apache.org/docs/latest/rdd-programming-guide.html#actions" target="_blank" rel="noopener">https://spark.apache.org/docs/latest/rdd-programming-guide.html#actions</a></p><h3 id="混洗（Shuffle）算子"><a href="#混洗（Shuffle）算子" class="headerlink" title="混洗（Shuffle）算子"></a>混洗（Shuffle）算子</h3><p>有一些Spark算子会触发众所周知的混洗（Shuffle）事件。Spark中的混洗机制是用于将数据重新分布，其结果是所有数据将在各个分区间重新分组。一般情况下，混洗需要跨执行器（Executor）或跨机器复制数据，这也是混洗操作一般都比较复杂而且开销大的原因。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>以 reduceByKey 算子为例来看一下。reduceByKey算子会生成一个新的RDD，将源RDD中一个key对应的多个value组合进一个tuple - 然后将这些values输入给reduce函数，得到的result再和key关联放入新的RDD中。这个算子的难点在于对于某一个key来说，并非其对应的所有values都在同一个分区（partition）中，甚至有可能都不在同一台机器上，但是这些values又必须放到一起计算reduce结果。</p><p>在Spark中，通常是由于为了进行某种计算操作，而将数据分布到所需要的各个分区当中。而在计算阶段，单个任务（task）只会操作单个分区中的数据 – 因此，为了组织好每个 reduceByKey 中 reduce 任务执行时所需的数据，Spark需要执行一个多对多操作。即，Spark需要读取RDD的所有分区，并找到所有key对应的所有values，然后跨分区传输这些values，并将每个key对应的所有values放到同一分区，以便后续计算各个key对应values的reduce结果 – 这个过程就叫做混洗（Shuffle）。</p><p>虽然混洗好后，各个分区中的元素和分区自身的顺序都是确定的，但是分区中元素的顺序并非确定的。如果需要混洗后分区内的元素有序，可以参考使用以下混洗操作：</p><ol><li>mapPartitions 使用 .sorted 对每个分区排序</li><li>repartitionAndSortWithinPartitions 重分区的同时，对分区进行排序，比自行组合repartition和sort更高效</li><li>sortBy 创建一个全局有序的RDD</li></ol><h4 id="性能影响"><a href="#性能影响" class="headerlink" title="性能影响"></a>性能影响</h4><p>混洗（Shuffle）之所以开销大，是因为混洗操作需要引入磁盘I/O，数据序列化以及网络I/O等操作。为了组织好混洗数据，Spark需要生成对应的任务集 – 一系列map任务用于组织数据，再用一系列reduce任务来聚合数据。注意这里的map、reduce是来自MapReduce的术语，和Spark的map、reduce算子并没有直接关系。</p><p>在Spark内部，单个map任务的输出会尽量保存在内存中，直至放不下为止。然后，这些输出会基于目标分区重新排序，并写到一个文件里。在reduce端，reduce任务只读取与之相关的并已经排序好的blocks。</p><p>某些混洗算子会导致非常明显的内存开销增长，因为这些算子需要在数据传输前后，在内存中维护组织数据记录的各种数据结构。特别地，reduceByKey和aggregateByKey都会在map端创建这些数据结构，而ByKey系列算子都会在reduce端创建这些数据结构。如果数据在内存中存不下，Spark会把数据吐到磁盘上，当然这回导致额外的磁盘I/O以及垃圾回收的开销。</p><p>混洗还会再磁盘上生成很多临时文件。以Spark-1.3来说，这些临时文件会一直保留到其对应的RDD被垃圾回收才删除。之所以这样做，是因为如果这些信息需要重新计算的时候，这些混洗文件可以不必重新生成。如果程序持续引用这些RDD或者垃圾回收启动频率较低，那么这些垃圾回收可能需要等较长的一段时间。这就意味着，长时间运行的Spark作业可能会消耗大量的磁盘。Spark的临时存储目录，是由spark.local.dir 配置参数指定的。</p><p>spark混洗操作的相关配置可以参考</p><blockquote><p><a href="https://spark.apache.org/docs/latest/configuration.html#shuffle-behavior" target="_blank" rel="noopener">https://spark.apache.org/docs/latest/configuration.html#shuffle-behavior</a></p></blockquote><h3 id="RDD持久化"><a href="#RDD持久化" class="headerlink" title="RDD持久化"></a>RDD持久化</h3><p>spark的一项关键能力就是它可以持久化（或者缓存）数据集在内存中，从而跨操作复用这些数据集。如果你持久化了一个RDD，那么每个节点上都会存储该RDD的一些分区，这些分区是由对应的节点计算出来并保持在内存中，后续可以在其他施加在该RDD上的action算子中复用（或者从这些数据集派生新的RDD）。这使得后续动作的速度提高很多（通常高于10倍）。</p><h4 id="持久化数据"><a href="#持久化数据" class="headerlink" title="持久化数据"></a>持久化数据</h4><p>你可以用persist() 或者 cache() 来标记一下需要持久化的RDD。等到该RDD首次被施加action算子的时候，其对应的数据分区就会被保留在内存里。同时，Spark的缓存具备一定的容错性 – 如果RDD的任何一个分区丢失了，Spark将自动根据其原来的混洗信息重新计算这个分区。</p><p>另外，每个持久化的RDD可以使用不同的存储级别，比如，你可以把RDD保存在磁盘上，或者以java序列化对象保存到内存里（为了省空间），或者跨节点多副本，或者使用 Tachyon 存到虚拟机以外的内存里。这些存储级别都可以由persist()的参数StorageLevel对象来控制。cache() 方法本身就是一个使用默认存储级别做持久化的快捷方式，默认存储级别是 StorageLevel.MEMORY_ONLY（以Java序列化方式存到内存里）。</p><p>完整的存储级别列表参见</p><blockquote><p><a href="https://spark.apache.org/docs/latest/rdd-programming-guide.html#rdd-persistence" target="_blank" rel="noopener">https://spark.apache.org/docs/latest/rdd-programming-guide.html#rdd-persistence</a></p></blockquote><h4 id="删除持久化的数据"><a href="#删除持久化的数据" class="headerlink" title="删除持久化的数据"></a>删除持久化的数据</h4><p>Spark会自动监控各个节点上的缓存使用率，并通过LRU（最近最少使用）算法将老数据逐出内存。也可以通过RDD.unpersist()方法来手动删除删除无用的缓存</p><h2 id="共享变量"><a href="#共享变量" class="headerlink" title="共享变量"></a>共享变量</h2><p>一般而言，当我们给Spark算子（如 map 或 reduce）传递一个函数时，这些函数将会在远程的集群节点上运行，并且这些函数所引用的变量都是各个节点上的独立副本。这些变量都会以副本的形式复制到各个机器节点上，如果更新这些变量副本的话，这些更新并不会传回到驱动器（driver）程序。通常来说，支持跨任务的可读写共享变量是比较低效的。不过，Spark还是提供了两种比较通用的共享变量：广播变量（Broadcast Variables）和累加器（Accumulators）。</p><h3 id="广播变量"><a href="#广播变量" class="headerlink" title="广播变量"></a>广播变量</h3><p>广播变量提供了一种只读的共享变量，它是在每个机器节点上保存一个缓存，而不是每个任务保存一份副本。通常可以用来在每个节点上保存一个较大的输入数据集，这要比常规的变量副本更高效（一般的变量是每个任务一个副本，一个节点上可能有多个任务）。Spark还会尝试使用高效的广播算法来分发广播变量，以减少通信开销。</p><p>Spark的操作有时会有多个阶段（stage），不同阶段之间的分割线就是混洗（shuffle）操作。Spark会自动广播各个阶段用到的公共数据。这些方式广播的数据都是序列化过的，并且在运行各个任务前需要反序列化。这也意味着，显示地创建广播变量，只有在跨多个阶段（stage）的任务需要同样的数据 或者 缓存数据的序列化和反序列化格式很重要的情况下 才是必须的。</p><p>广播变量可以通过一个变量v来创建，只需调用 SparkContext.broadcast(v)即可。这个广播变量是对变量v的一个包装，要访问其值，可以调用广播变量的 value 方法。代码示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Broadcast&lt;<span class="keyword">int</span>[]&gt; broadcastVar = sc.broadcast(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br><span class="line"></span><br><span class="line">broadcastVar.value();</span><br><span class="line"><span class="comment">// returns [1, 2, 3]</span></span><br></pre></td></tr></table></figure><br>广播变量创建之后，集群中任何函数都不应该再使用原始变量v，这样才能保证v不会被多次复制到同一个节点上。另外，对象v在广播后不应该再被更新，这样才能保证所有节点上拿到同样的值（例如，更新后，广播变量又被同步到另一新节点，新节点有可能得到的值和其他节点不一样）。</p><h3 id="累加器"><a href="#累加器" class="headerlink" title="累加器"></a>累加器</h3><p>累加器是一种只支持满足结合律的“累加”操作的变量，因此它可以很高效地支持并行计算。利用累加器可以实现计数（类似MapReduce中的计数器）或者求和。Spark原生支持了数字类型的累加器，开发者也可以自定义新的累加器。如果创建累加器的时候给了一个名字，那么这个名字会展示在Spark UI上，这对于了解程序运行处于哪个阶段非常有帮助（注意：Python尚不支持该功能）。</p><p>创捷累加器时需要赋一个初始值v，调用 SparkContext.accumulator(v) 可以创建一个累加器。后续集群中运行的任务可以使用 add 方法 或者 += 操作符 （仅Scala和Python支持）来进行累加操作。不过，任务本身并不能读取累加器的值，只有驱动器程序可以用 value 方法访问累加器的值。代码示例如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LongAccumulator accum = jsc.sc().longAccumulator();</span><br><span class="line"></span><br><span class="line">sc.parallelize(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)).foreach(x -&gt; accum.add(x));</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 10/09/29 18:41:08 INFO SparkContext: Tasks finished in 0.317106 s</span></span><br><span class="line"></span><br><span class="line">accum.value();</span><br><span class="line"><span class="comment">// returns 10</span></span><br></pre></td></tr></table></figure></p><p>也可以通过实现AccumulatorV2来自定义自己的累加器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VectorAccumulatorV2</span> <span class="keyword">implements</span> <span class="title">AccumulatorV2</span>&lt;<span class="title">MyVector</span>, <span class="title">MyVector</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> MyVector myVector = MyVector.createZeroVector();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    myVector.reset();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(MyVector v)</span> </span>&#123;</span><br><span class="line">    myVector.add(v);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Then, create an Accumulator of this type:</span></span><br><span class="line">VectorAccumulatorV2 myVectorAcc = <span class="keyword">new</span> VectorAccumulatorV2();</span><br><span class="line"><span class="comment">// Then, register it into spark context:</span></span><br><span class="line">jsc.sc().register(myVectorAcc, <span class="string">"MyVectorAcc1"</span>);</span><br></pre></td></tr></table></figure></p><p>若某个task任务失败，在进行累加时，spark会忽视这个任务。因此，累加时若出现失败任务可能会导致运算不正确</p><blockquote><p> When a Spark task finishes, Spark will try to merge the accumulated updates in this task to an accumulator. If it fails, Spark will ignore the failure and still mark the task successful and continue to run other tasks. Hence, a buggy accumulator will not impact a Spark job, but it may not get updated correctly although a Spark job is successful.</p></blockquote><p>对于在action算子中更新的累加器，Spark保证每个任务对累加器的更新只会被应用一次，例如，某些任务如果重启过，则不会再次更新累加器。而如果在transformation算子中更新累加器，那么用户需要注意，一旦某个任务因为失败被重新执行，那么其对累加器的更新可能会实施多次。</p><p>累加器并不会改变Spark懒惰求值的运算模型。如果在RDD算子中更新累加器，那么其值只会在RDD做action算子计算的时候被更新一次。因此，在transformation算子（如：map）中更新累加器，其值并不能保证一定被更新。以下代码片段说明了这一特性：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LongAccumulator accum = jsc.sc().longAccumulator();</span><br><span class="line">data.map(x -&gt; &#123; accum.add(x); <span class="keyword">return</span> f(x); &#125;);</span><br><span class="line"><span class="comment">// Here, accum is still 0 because no actions have caused the `map` to be computed.</span></span><br></pre></td></tr></table></figure></p><!-- <style type="text/css">    h1 { counter-reset: h2counter; }    h2 { counter-reset: h3counter; }    h3 { counter-reset: h4counter; }    h4 { counter-reset: h5counter; }    h5 { counter-reset: h6counter; }    h6 { }    h2:before {      counter-increment: h2counter;      content: counter(h2counter) ".\0000a0\0000a0";    }    h3:before {      counter-increment: h3counter;      content: counter(h2counter) "."                counter(h3counter) ".\0000a0\0000a0";    }    h4:before {      counter-increment: h4counter;      content: counter(h2counter) "."                counter(h3counter) "."                counter(h4counter) ".\0000a0\0000a0";    }    h5:before {      counter-increment: h5counter;      content: counter(h2counter) "."                counter(h3counter) "."                counter(h4counter) "."                counter(h5counter) ".\0000a0\0000a0";    }    h6:before {      counter-increment: h6counter;      content: counter(h2counter) "."                counter(h3counter) "."                counter(h4counter) "."                counter(h5counter) "."                counter(h6counter) ".\0000a0\0000a0";    }</style> -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- 
&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default&quot;&gt;&lt;/script&gt; --&gt;
&lt;h1 id=&quot;Spark-RDD&quot;&gt;
      
    
    </summary>
    
      <category term="分布式系统" scheme="965087276.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Spark" scheme="965087276.github.io/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>23种设计模式-装饰模式</title>
    <link href="965087276.github.io/2020/02/16/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
    <id>965087276.github.io/2020/02/16/23种设计模式-装饰模式/</id>
    <published>2020-02-16T03:55:12.000Z</published>
    <updated>2020-05-03T06:01:41.662Z</updated>
    
    <content type="html"><![CDATA[<h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>在某些情况下我们可能会“过度地使用继承来扩展对象的功能”，由于继承为类型引入的静态特质，使得这种扩展方式缺乏灵活性；并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多子类的膨胀。</p><p>如何使“对象功能的扩展”能够根据需要来动态地实现？同时避免“扩展功能的增多”带来的子类膨胀问题？从而使得任何“功能扩展变化”所导致的影响将为最低？</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>这里我们引用《HeadFirst设计模式》中的例子。</p><p>星巴兹是一家咖啡连锁店，由于扩张速度太快，他们准备更新他们的订单系统以合乎饮料的供应要求。他们原先的类设计如下。<br><img src="1.png" alt=""><br>系统中包含一个Beverage(饮料)抽象类，所有的饮料都必须继承这个抽象类;Beverage类中包含一个描述饮料信息的description实例变量以及计算饮料价格的cost()抽象方法。每种饮料子类，如HouseBlend(混合咖啡)、DarkToast(深焙咖啡)都必须实现cost()方法来计算自己的价格。</p><p>购买咖啡时，还可以向其中加入各种调料，如豆浆(Soy)、摩卡(Mocha)等，咖啡店会根据加入的调料收取不同的费用。在初始设计中，他们枚举了顾客所有可能的购买组合（如混合豆浆咖啡、混合摩卡咖啡、深焙豆浆咖啡、深焙摩卡咖啡），每种组合都建立了一个类。<br><img src="2.png" alt=""></p><p>这种实现方式有明显的弊端。例如，假设某种调料的价格改变，那么所有包含该调料的类都要修改cost()方法；如果新增加了一种咖啡或调料，那么又需要增加很多的类。假如有$n$种咖啡、$m$种调料，仅调料的组合就有$2^m$种，再乘以咖啡的数量，可以算出类的总数目为$1 + n*2^m$种（+1是因为还有个Beverage抽象类），数量相当之大了，这对后期的维护来说简直是噩梦。</p><h4 id="改进1"><a href="#改进1" class="headerlink" title="改进1"></a>改进1</h4><p>上面的实现最大的问题是类是呈指数级增长的，那么我们可以先从减少类的数量为切入点进行改进。</p><p>首先对Beverage基类进行修改，对每种调料都设置一个boolean类型的变量，表示饮料中是否加入该调料，将这些变量都放到Beverage基类中，通过set方法设置变量的值。<br><img src="3.png" alt=""><br><img src="4.png" alt=""><br>Beverage根据各boolean变量的值，计算所有调料的价钱<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (hasMilk()) sum += <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (hasSoy()) sum += <span class="number">1.5</span>;</span><br><span class="line">        <span class="keyword">if</span> (hasMocha())  sum += <span class="number">0.6</span>;</span><br><span class="line">        <span class="keyword">if</span> (hasWhip())  sum += <span class="number">0.8</span>;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>子类（每种咖啡类）调用自己的cost()方法计算自己咖啡的价钱，同时调用超类的cost()方法加入调料的价钱<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DarkRoast</span> <span class="keyword">extends</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DarkRoast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        description = <span class="string">"Most Excellent Dark Roast"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span> + <span class="keyword">super</span>.cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>现在假设要购买一杯加豆浆（Joy）和摩卡（Mocha）的深焙咖啡，只需要在原有DarkRoast的基础上，设置相应的调料变量即可，而不需要专门创建一个新的类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DarkRoast darkRoast = <span class="keyword">new</span> DarkRoast();</span><br><span class="line">darkRoast.setJoy(<span class="keyword">true</span>);</span><br><span class="line">darkRoast.setMocha(<span class="keyword">true</span>);</span><br><span class="line">System.out.println(<span class="string">"咖啡的价格为 “ + darkRoast.cost());</span></span><br></pre></td></tr></table></figure><br>这种实现方式相比第一种，类的数目大大减小，只需要$1+m$个类（$m$为咖啡的数量）。但是，这种实现方式还是有欠缺的。</p><ol><li>若调料价钱改变，则需要修改Beverage类的cost()方法</li><li>若出现新的调料，则要在Beverage类中添加新的boolean变量，并修改cost()方法</li><li>对某些饮料而言，一些调料并不适合，如在茶水(Tea类)中加奶泡(whip)。但是，Tea类仍然会继承这些不合适的方法(hasWhip())</li><li>若顾客想要双倍摩卡咖啡，这种实现方式就不适用了</li></ol><h4 id="改进2-装饰者模式"><a href="#改进2-装饰者模式" class="headerlink" title="改进2 装饰者模式"></a>改进2 装饰者模式</h4><p>装饰者模式是以饮料为主体，在运行时以饮料来“装饰对象”。比如说，顾客要买一杯加摩卡和奶泡的深焙咖啡，那么要做的是</p><ol><li>构造一个深焙咖啡（DarkRoast）对象</li><li>用摩卡（Mocha）对象装饰它</li><li>用奶泡（Whip）对象装饰它</li><li>调用cost()方法</li></ol><p>可以参考下面的图片解释<br><img src="5-1.png" alt=""><br><img src="5-2.png" alt=""><br><img src="5-3.png" alt=""></p><p>接下来用代码来实现一下。<br>首先还是一个Beverage（饮料）的抽象类，里面包含一个抽象的cost()方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来，建立各种饮料类。每种饮料类都要实现自己的cost()方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 深焙咖啡</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DarkRoast</span> <span class="keyword">extends</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DarkRoast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        description = <span class="string">"DarkRoast"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.99</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 混合咖啡</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseBlend</span> <span class="keyword">extends</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HouseBlend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        description = <span class="string">"HouseBlend"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.89</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来建立调料类。因为调料类是用来装饰饮料类的，所以调料类中包含了一个饮料类的实例对象,如摩卡类的代码如下。计算价格时，只需将摩卡的价格(0.2)与被包装的饮料的价格相加即可。因为多态的缘故，被包装的是谁，并不需要关心，这就大大增加了代码的灵活性。饮料的description字段的设置同理，为被包装的饮料的description与调料的description相加。</p><p>同时，作为装饰者，调料类中的方法还要与饮料类中的方法保持一致。为了满足这个约束，各调料类还要继承饮料类以确保包含饮料类的所有方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 摩卡</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mocha</span> <span class="keyword">extends</span> <span class="title">Beverage</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Beverage beverage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mocha</span><span class="params">(Beverage beverage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beverage = beverage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.cost() + <span class="number">0.1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.getDescription() + <span class="string">", Mocha"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意，摩卡类中既继承了Beverage类，还拥有一个Beverage实例，这两个所起的作用是不一样的。</p><ol><li>拥有Beverage实例是因为调料类需要装饰饮料类，这里的Beverage实例是被Mocha类装饰的对象</li><li>继承是因为饮料类中的方法要与调料类中的方法保持一致，即装饰者类的方法要与被装饰者类的方法保持一致，这里的继承是个约束作用，确保装饰者拥有了被装饰者的所有方法。</li></ol><p>同理，建立其它两种饮料的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 豆浆</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Soy</span> <span class="keyword">extends</span> <span class="title">Beverage</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Beverage beverage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Soy</span><span class="params">(Beverage beverage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beverage = beverage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.cost() + <span class="number">0.2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.getDescription() + <span class="string">", Soy"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 奶泡</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Whip</span> <span class="keyword">extends</span> <span class="title">Beverage</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Beverage beverage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Whip</span><span class="params">(Beverage beverage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beverage = beverage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.cost() + <span class="number">0.3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.getDescription() + <span class="string">", Whip"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>再看这三个饮料类，它们有共同的实例参数(beverage)。因此，可以将抽离出来单独放到一个基类中，这个基类在装饰者模式中被称为组件(Component)类，即用来装饰别的类。同时，getDescription()方法在各种调料中都有不同的实现，在原先的Beverage类中，它不是一个抽象方法。在这里，也将它放到基类中，同时声明为一个抽象方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CondimentDecorator</span> <span class="keyword">extends</span> <span class="title">Beverage</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Beverage beverage;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>修改后的饮料类代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mocha</span> <span class="keyword">extends</span> <span class="title">CondimentDecorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mocha</span><span class="params">(Beverage beverage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beverage = beverage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.cost() + <span class="number">0.1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.getDescription() + <span class="string">", Mocha"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Soy</span> <span class="keyword">extends</span> <span class="title">CondimentDecorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Soy</span><span class="params">(Beverage beverage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beverage = beverage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.cost() + <span class="number">0.2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.getDescription() + <span class="string">", Soy"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Whip</span> <span class="keyword">extends</span> <span class="title">CondimentDecorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Whip</span><span class="params">(Beverage beverage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beverage = beverage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.cost() + <span class="number">0.3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.getDescription() + <span class="string">", Whip"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试一下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先建立一个深焙咖啡 $0.99</span></span><br><span class="line">Beverage beverage = <span class="keyword">new</span> DarkRoast();</span><br><span class="line"><span class="comment">// 不加任何调料装饰，直接输出</span></span><br><span class="line"><span class="comment">// 输出结果：DarkRoast $0.99</span></span><br><span class="line">System.out.println(beverage.getDescription() + <span class="string">" $"</span> + beverage.cost());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再建立一个深焙咖啡（被装饰者） $0.99</span></span><br><span class="line">Beverage beverage2 = <span class="keyword">new</span> DarkRoast();</span><br><span class="line"><span class="comment">// 加一点摩卡（装饰者） $0.1</span></span><br><span class="line">beverage2 = <span class="keyword">new</span> Mocha(beverage2);</span><br><span class="line"><span class="comment">// 再加一份摩卡（双倍的摩卡）（装饰者）$0.1</span></span><br><span class="line">beverage2 = <span class="keyword">new</span> Mocha(beverage2);</span><br><span class="line"><span class="comment">// 加点奶泡（装饰者）$0.3</span></span><br><span class="line">beverage2 = <span class="keyword">new</span> Whip(beverage2);</span><br><span class="line"><span class="comment">//输出结果：DarkRoast, Mocha, Mocha, Whip $1.49</span></span><br><span class="line">System.out.println(beverage2.getDescription() + <span class="string">" $"</span> + beverage2.cost());</span><br></pre></td></tr></table></figure></p><p>本例的类图如下<br><img src="6.png" alt=""></p><h3 id="装饰者模式定义"><a href="#装饰者模式定义" class="headerlink" title="装饰者模式定义"></a>装饰者模式定义</h3><p>装饰者模式动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。<br><img src="7.png" alt=""></p><h3 id="要点总结"><a href="#要点总结" class="headerlink" title="要点总结"></a>要点总结</h3><ol><li>通过采用组合而非继承的手法， Decorator模式实现了在运行时动态扩展对象功能的能力，而且可以根据需要扩展多个功能。避免了使用继承带来的“灵活性差”和“多子类衍生问题”。</li><li>Decorator类在接口上表现为is-a Component的继承关系，即Decorator类继承了Component类所具有的接口。但在实现上又表现为has-a Component的组合关系，即Decorator类又使用了另外一个Component类。</li><li>Decorator模式的目的并非解决“多子类衍生的多继承”问题，Decorator模式应用的要点在于解决“主体类在多个方向上的扩展功能”——是为“装饰”的含义。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;动机&quot;&gt;&lt;a href=&quot;#动机&quot; class=&quot;headerlink&quot; title=&quot;动机&quot;&gt;&lt;/a&gt;动机&lt;/h3&gt;&lt;p&gt;在某些情况下我们可能会“过度地使用继承来扩展对象的功能”，由于继承为类型引入的静态特质，使得这种扩展方式缺乏灵活性；并且随着子类的增多（扩展
      
    
    </summary>
    
      <category term="设计模式" scheme="965087276.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>23种设计模式-观察者模式</title>
    <link href="965087276.github.io/2020/02/14/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>965087276.github.io/2020/02/14/23种设计模式-观察者模式/</id>
    <published>2020-02-14T11:34:04.000Z</published>
    <updated>2020-05-03T06:01:41.678Z</updated>
    
    <content type="html"><![CDATA[<h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>在软件构建过程中，我们需要为某些对象建立一种“通知依赖关系”——一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知。如果这样的依赖关系过于紧密，将使软件不能很好地抵御变化。</p><p>使用面向对象技术，可以将这种依赖关系弱化，并形成一种稳定的依赖关系。从而实现软件体系结构的松耦合。</p><h3 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h3><p>定义对象间的一种一对多的依赖关系，以便当一个对象（Subject）的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。<br><img src="class.png" alt=""></p><h3 id="要点总结"><a href="#要点总结" class="headerlink" title="要点总结"></a>要点总结</h3><ol><li>使用面向对象的抽象， Observer模式使得我们可以独立地改变目<br>标与观察者，从而使二者之间的依赖关系达致松耦合</li><li>目标发送通知时，无需指定观察者，通知（可以携带通知信息作<br>为参数）会自动传播</li><li>观察者自己决定是否需要订阅通知，目标对象对此一无所知</li><li>Observer模式是基于事件的UI框架中非常常用的设计模式，也是<br>MVC模式的一个重要组成部分</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;动机&quot;&gt;&lt;a href=&quot;#动机&quot; class=&quot;headerlink&quot; title=&quot;动机&quot;&gt;&lt;/a&gt;动机&lt;/h3&gt;&lt;p&gt;在软件构建过程中，我们需要为某些对象建立一种“通知依赖关系”——一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知
      
    
    </summary>
    
      <category term="设计模式" scheme="965087276.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>23种设计模式-模板方法模式</title>
    <link href="965087276.github.io/2020/02/13/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>965087276.github.io/2020/02/13/23种设计模式-模板方法模式/</id>
    <published>2020-02-12T16:10:10.000Z</published>
    <updated>2020-05-03T06:01:41.659Z</updated>
    
    <content type="html"><![CDATA[<h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><hr><p>在软件构建过程中，对于某一项任务，它常常有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或者由于固有的原因（比如框架与应用之间的关系）而无法和任务的整体结构同时实现。</p><p>如何在确定稳定操作结构的前提下，来灵活应对各个子步骤的变化或者晚期实现需求？</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><hr><p>小明希望学炒菜：手撕包菜 &amp; 蒜蓉炒菜心。炒菜的流程分为5步，对每种菜来说，炒菜的流程都是一样的。</p><ol><li>倒油</li><li>热油</li><li>倒蔬菜</li><li>倒调味料</li><li>翻炒</li></ol><p>其中，<strong>倒油</strong>、<strong>热油</strong>、<strong>翻炒</strong>三步操作对各个菜都是一样的，而<strong>倒蔬菜</strong>、<strong>倒调味料</strong>两步对各种菜之间是有差异的。</p><p>对于这个问题，最直接的想法是分别建立“手撕包菜”、“蒜蓉炒菜心”两个类，在两个类里实现这5个方法，代码如下所示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VegetableBaocai</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cookingVegetable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pourOil();</span><br><span class="line">        <span class="keyword">this</span>.heatOil();</span><br><span class="line">        <span class="keyword">this</span>.pourVegetable();</span><br><span class="line">        <span class="keyword">this</span>.pourSauce();</span><br><span class="line">        <span class="keyword">this</span>.fry();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pourOil</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"倒油"</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heatOil</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"热油"</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fry</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"翻炒"</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pourVegetable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"下锅的蔬菜是包菜"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pourSauce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"下锅的酱料是辣椒"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VegetableCaixin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cookingVegetable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pourOil();</span><br><span class="line">        <span class="keyword">this</span>.heatOil();</span><br><span class="line">        <span class="keyword">this</span>.pourVegetable();</span><br><span class="line">        <span class="keyword">this</span>.pourSauce();</span><br><span class="line">        <span class="keyword">this</span>.fry();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pourOil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"倒油"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heatOil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"热油"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"翻炒"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pourVegetable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"下锅的蔬菜是菜心"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pourSauce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"下锅的酱料是蒜蓉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样做的缺点也很明显：代码中存在大量重复的部分，两个类除了pourVegetable()方法和pourSauce()方法外都相同。</p><p>既然有重复部分，那么我们可以将重复部分抽离出来，放进一个基类(CookingVegetable)中。</p><p>一种直观的想法是，将<strong>倒油</strong>、<strong>热油</strong>、<strong>翻炒</strong>这三个方法放到基类中。代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CookingVegetable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">pourOil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"倒油"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">heatOil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"热油"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">fry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"翻炒"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VegetableBaocai</span> <span class="keyword">extends</span> <span class="title">CookingVegetable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cookingVegetable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.pourOil();</span><br><span class="line">        <span class="keyword">super</span>.heatOil();</span><br><span class="line">        <span class="keyword">this</span>.pourVegetable();</span><br><span class="line">        <span class="keyword">this</span>.pourSauce();</span><br><span class="line">        <span class="keyword">super</span>.fry();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pourVegetable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"下锅的蔬菜是包菜"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pourSauce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"下锅的酱料是辣椒"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VegetableCaixin</span> <span class="keyword">extends</span> <span class="title">CookingVegetable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cookingVegetable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.pourOil();</span><br><span class="line">        <span class="keyword">super</span>.heatOil();</span><br><span class="line">        <span class="keyword">this</span>.pourVegetable();</span><br><span class="line">        <span class="keyword">this</span>.pourSauce();</span><br><span class="line">        <span class="keyword">super</span>.fry();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pourVegetable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"下锅的蔬菜是菜心"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pourSauce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"下锅的酱料是蒜蓉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种实现方式的类图如下所示<br><img src="foolish1.png" alt=""></p><p>这种实现比上一种好了很多，但是还是有重复，重复的地方在于两个子类有完全一样的<em>cookingVegetable()</em>方法，这就会出现两个问题。</p><ol><li>假设现在又增加了两种菜：番茄炒蛋、红烧茄子，那么这两个类也都要包含<em>cookingVegetable()</em>方法。</li><li>假设<em>cookingVegetable()</em>方法有变动，在<em>fry()</em>步骤之后新增一个<em>清洗(clean)</em>步骤，那么每个炒菜类的<em>cookingVegetable()</em>方法都要加上<em>clean()</em>方法。</li></ol><p>既然各子类的<em>cookingVegetable()</em>方法，那么有办法将这个方法也抽象化吗？这就引出了模板方法模式。</p><p>我们将<em>cookingVegetable()</em>方法提取出来放到基类中，由于该方法中，<em>pourOil(), heatOil(), fry()</em>三个子方法对不同子类都是一样的，那么我们直接在基类中实现它们，让子类去调用基类的方法；<em>pourVegetable(), pourSauce()</em>这两个方法是各不相同的，我们可以在基类中声明它们，让各个子类去单独实现，也就是抽象方法。其类图如下<br><img src="class2.png" alt=""></p><p>基类的代码如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CookingVegetable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明成final方法，不允许子类覆盖</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">cookingVegetable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pourOil();</span><br><span class="line">        <span class="keyword">this</span>.heatOil();</span><br><span class="line">        <span class="keyword">this</span>.pourVegetable();</span><br><span class="line">        <span class="keyword">this</span>.pourSauce();</span><br><span class="line">        <span class="keyword">this</span>.fry();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pourOil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"倒油"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heatOil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"热油"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"翻炒"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这些方法由子类单独实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">pourVegetable</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">pourSauce</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各个子类去实现上面两个抽象方法，代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VegetableBaocai</span> <span class="keyword">extends</span> <span class="title">CookingVegetable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pourVegetable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"下锅的蔬菜是包菜"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pourSauce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"下锅的酱料是辣椒"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VegetableCaixin</span> <span class="keyword">extends</span> <span class="title">CookingVegetable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pourVegetable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"下锅的蔬菜是菜心"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pourSauce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"下锅的酱料是蒜蓉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面测试一下，分别建立包菜、菜心两个类进行测试<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 手撕包菜</span></span><br><span class="line">        VegetableBaocai baocai = <span class="keyword">new</span> VegetableBaocai();</span><br><span class="line">        <span class="comment">// 蒜蓉菜心</span></span><br><span class="line">        VegetableCaixin caixin = <span class="keyword">new</span> VegetableCaixin();</span><br><span class="line">        baocai.cookingVegetable();</span><br><span class="line">        System.out.println(<span class="string">"================"</span>);</span><br><span class="line">        caixin.cookingVegetable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">倒油</span><br><span class="line">热油</span><br><span class="line">下锅的蔬菜是包菜</span><br><span class="line">下锅的酱料是辣椒</span><br><span class="line">翻炒</span><br><span class="line">================</span><br><span class="line">倒油</span><br><span class="line">热油</span><br><span class="line">下锅的蔬菜是菜心</span><br><span class="line">下锅的酱料是蒜蓉</span><br><span class="line">翻炒</span><br></pre></td></tr></table></figure><p>以上便是模板方法模式的一个实例</p><h3 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h3><p>模板方法模式定义了一个操作中的算法的骨架（稳定），而将一些步骤（会变化的步骤）延迟到子类中。模板方法模式使得子类可以不改变一个算法的骨架即可重定义（override重写）该算法的某些特定步骤。</p><p>在上面的例子中，<strong>cookingVegetable()</strong>方法可以看作一个算法，该算法的骨架包含5个步骤：倒油、热油、倒蔬菜、倒调味料、翻炒。有两个步骤（倒蔬菜、倒调味料）根据子类的不同实现起来也不同，因此这两个方法的实现<strong>延迟</strong>到子类中。<br><img src="class.png" alt=""></p><h3 id="要点总结"><a href="#要点总结" class="headerlink" title="要点总结"></a>要点总结</h3><ol><li>模板方法模式是一种非常基础性的设计模式，在面向对象系统中有着大量的应用，它用最简洁的机制（虚函数的多态性）为很多应用程序框架提供了灵活的扩展点，是代码复用的基本实现结构。</li><li>除了可以灵活应对子步骤的变化外，“不要调用我，让我来调用你”的<strong>反向控制结构</strong>是模板方法模式的典型应用。</li><li>在具体实现方面，被模板方法模式调用的虚方法可以具有实现，也可以没有任何实现（抽象方法），但一般推荐将它们设置为<strong>protected</strong>方法。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;动机&quot;&gt;&lt;a href=&quot;#动机&quot; class=&quot;headerlink&quot; title=&quot;动机&quot;&gt;&lt;/a&gt;动机&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;在软件构建过程中，对于某一项任务，它常常有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或者由于固有的原因（比如框架与应用之
      
    
    </summary>
    
      <category term="设计模式" scheme="965087276.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>用一个栈实现另一个栈的排序</title>
    <link href="965087276.github.io/2020/01/17/%E7%94%A8%E4%B8%80%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%88%E7%9A%84%E6%8E%92%E5%BA%8F/"/>
    <id>965087276.github.io/2020/01/17/用一个栈实现另一个栈的排序/</id>
    <published>2020-01-17T09:06:37.000Z</published>
    <updated>2020-05-15T01:34:34.141Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一个栈中元素的类型为整型，现在想将栈从栈顶到栈底从大到小的顺序排序，只许申请一个栈以及新的变量，不能申请额外的数据结构。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>申请一个辅助栈<strong>help</strong>, 将原先的栈中的元素<strong>x</strong>一个个弹出放入<strong>help</strong>栈中，通过下面的操作使得这个栈的元素保持从栈顶到栈底从大到小的顺序排序。</p><ul><li>若<strong>help</strong>栈为空, 直接将<strong>x</strong>入<strong>help</strong>栈</li><li>若<strong>help</strong>栈顶元素小于<strong>x</strong>，直接将<strong>x</strong>入<strong>help</strong>栈。因为<strong>help</strong>栈保持了从大到小的顺序，所以<strong>help</strong>栈顶就是当前<strong>help</strong>栈中最大的元素</li><li>若<strong>help</strong>栈顶元素大于<strong>x</strong>，则将<strong>help</strong>栈顶元素弹出，放入原始栈中。重复这一步，直到<strong>help</strong>栈顶元素小于x为止</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; sortStackByStack(<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">stack</span>) &#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; help;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">stack</span>.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="built_in">stack</span>.top(); <span class="built_in">stack</span>.pop();</span><br><span class="line">        <span class="keyword">while</span> (!help.empty() &amp;&amp; help.top() &lt; x) &#123;</span><br><span class="line">            <span class="built_in">stack</span>.push(help.top());</span><br><span class="line">            help.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        help.push(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> help;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;一个栈中元素的类型为整型，现在想将栈从栈顶到栈底从大到小的顺序排序，只许申请一个栈以及新的变量，不能申请额外的数据结构。&lt;/p&gt;
&lt;h3 i
      
    
    </summary>
    
      <category term="刷题" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
      <category term="程序员代码面试指南" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BB%A3%E7%A0%81%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"/>
    
    
      <category term="栈" scheme="965087276.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-1247 Minimum Swaps to Make Strings Equal</title>
    <link href="965087276.github.io/2020/01/14/LeetCode-1247-Minimum-Swaps-to-Make-Strings-Equal/"/>
    <id>965087276.github.io/2020/01/14/LeetCode-1247-Minimum-Swaps-to-Make-Strings-Equal/</id>
    <published>2020-01-14T01:50:26.000Z</published>
    <updated>2020-05-15T01:30:04.877Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><hr><p>You are given two strings s1 and s2 of equal length consisting of letters “x” and “y” only. Your task is to make these two strings equal to each other. You can swap any two characters that belong to <strong>different</strong> strings, which means: swap s1[i] and s2[j].</p><h3 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h3><hr><blockquote><h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h4><p><strong>Input:</strong> s1 = “xx”, s2 = “yy”<br><strong>Output:</strong> 1<br><strong>Explanation:</strong><br>Swap s1[0] &gt; and s2[1], s1 = “yx”, s2 = “yx”.</p><h4 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h4><p><strong>Input:</strong> s1 = “xy”, s2 = “yx”<br><strong>Output:</strong> 2<br><strong>Explanation:</strong><br>Swap s1[0] and s2[0], s1 = “yy”, s2 = “xx”.<br>Swap s1[0] and s2[1], s1 = “xy”, s2 = “xy”.<br>Note that you can’t swap s1[0] and s1[1] to make s1 equal to “yx”, cause we can only swap chars in different strings.</p><h4 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3:"></a>Example 3:</h4><p><strong>Input:</strong> s1 = “xx”, x2 = “xy”<br><strong>Output:</strong>: -1</p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><hr><p>首先，如果<strong>s1[i] = s2[i]</strong>, 那么该位置不用作交换</p></blockquote><p>如果<strong>s1[i] != s2[i]</strong>, 那么需要做一次交换使得它们相等。怎么交换呢？<br>按照贪心的策略, 我们肯定希望这一次交换除了使得<strong>i</strong>位置的两个字符相等, 也能使得被交换的<strong>j</strong>位置的两个字符相等.</p><p>进一步观察，我们发现，如果  </p><blockquote><p>s1[i] = x, s1[j] = x<br>s2[i] = y, s2[j] = y</p></blockquote><p>那么将s1[i]与s2[j]一次交换便可以使得i、j这两个位置满足相等条件。<br>同理，如果</p><blockquote><p>s1[i] = y, s1[j] = y<br>s2[i] = x, s2[j] = x</p></blockquote><p>那么将s1[i]与s2[j]一次交换便可以使得i、j这两个位置满足相等条件。</p><p>在其它情况下，做一次交换只能使得一个位置满足相等条件，例如</p><blockquote><p>s1[i] = x, s1[j] = y<br>s2[i] = y, s2[j] = x</p></blockquote><p>这种情况下，先将s1[i]与s2[i]交换，变成</p><blockquote><p>s1[i] = y, s1[j] = y<br>s2[i] = x, s2[j] = x</p></blockquote><p>然后再将s1[i]与s2[j]交换</p><p>这样思路就很清晰了，我们先去交换那些一次能满足两个位置的情况，再去交换那些一次满足一个位置的情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimumSwap</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt1 = <span class="number">0</span>, cnt2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1[i] == <span class="string">'x'</span> &amp;&amp; s2[i] == <span class="string">'y'</span>) ++cnt1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s1[i] == <span class="string">'y'</span> &amp;&amp; s2[i] == <span class="string">'x'</span>) ++cnt2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不相等的位置必须为偶数个</span></span><br><span class="line">    <span class="keyword">if</span> ((cnt1 + cnt2) % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    ans += cnt1 / <span class="number">2</span>;</span><br><span class="line">    ans += cnt2 / <span class="number">2</span>;</span><br><span class="line">    ans += cnt1 % <span class="number">2</span> + cnt2 % <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;You are given two strings s1 and s2 of equal length consi
      
    
    </summary>
    
      <category term="刷题" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
      <category term="LeetCode" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/LeetCode/"/>
    
    
      <category term="字符串" scheme="965087276.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
</feed>
