<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Interstellar</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="965087276.github.io/"/>
  <updated>2021-03-05T12:18:10.179Z</updated>
  <id>965087276.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 395 至少有K个重复字符的最长子串</title>
    <link href="965087276.github.io/2021/03/04/LeetCode-395-%E8%87%B3%E5%B0%91%E6%9C%89K%E4%B8%AA%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>965087276.github.io/2021/03/04/LeetCode-395-至少有K个重复字符的最长子串/</id>
    <published>2021-03-04T13:02:47.000Z</published>
    <updated>2021-03-05T12:18:10.179Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个字符串 <code>s</code> 和一个整数 <code>k</code> ，请你找出 <code>s</code> 中的最长子串， 要求该子串中的每一字符出现次数都不少于 <code>k</code> 。返回这一子串的长度。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;aaabb&quot;, k &#x3D; 3</span><br><span class="line">输出：3</span><br><span class="line">解释：最长子串为 &quot;aaa&quot; ，其中 &#39;a&#39; 重复了 3 次。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;ababbc&quot;, k &#x3D; 2</span><br><span class="line">输出：5</span><br><span class="line">解释：最长子串为 &quot;ababb&quot; ，其中 &#39;a&#39; 重复了 2 次， &#39;b&#39; 重复了 3 次。</span><br></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>如果直接使用二重循环遍历每个子串，总的时间复杂度为 $O(n^3 * |\Sigma|)$，其中，$|\Sigma|$ 为小写字母的个数，这里为 26。对于 $n = 50000$ 的数据规模，这种方式显然复杂度太高了。</p><p>对于字符串 $s$，如果其中某个字符 $c$ 的出现次数小于 $k$，那么 $s$ 中所有包含字符 $c$ 的子串都不可能满足要求。根据这个性质，我们可以将 $s$ 按照字符 $c$ 切分成若干段，切分后，满足要求的字符串一定会出现在某一个被切分的段内。我们可以对每个小字符串再递归地执行上面的过程，直到字符串中所有字符出现次数都大于等于 $k$ 时停止。这也就是分而治之的思想。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeetCode395</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="keyword">return</span> dfs(ch, <span class="number">0</span>, ch.length-<span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[] ch, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r - l + <span class="number">1</span> &lt; k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] times = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">            times[ch[i] - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不满足要求的字符的位置</span></span><br><span class="line">        List&lt;Integer&gt; splits = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 这一句的-1和下面的r+1，是为了后面遍历时方便处理</span></span><br><span class="line">        splits.add(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (times[ch[i] - <span class="string">'a'</span>] &lt; k) &#123;</span><br><span class="line">                splits.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        splits.add(r + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (splits.size() == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> r - l + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; splits.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            ans = Math.max(ans, dfs(ch, splits.get(i) + <span class="number">1</span>, splits.get(i+<span class="number">1</span>) - <span class="number">1</span>, k));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt; 和一个整数 &lt;code&gt;k&lt;/code&gt; ，请你找出 &lt;code&gt;s&lt;/code&gt; 中的最长子
      
    
    </summary>
    
      <category term="刷题" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
      <category term="LeetCode" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/LeetCode/"/>
    
    
      <category term="分治" scheme="965087276.github.io/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 354 俄罗斯套娃信封问题</title>
    <link href="965087276.github.io/2021/03/04/LeetCode-354-%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98/"/>
    <id>965087276.github.io/2021/03/04/LeetCode-354-俄罗斯套娃信封问题/</id>
    <published>2021-03-04T11:54:44.000Z</published>
    <updated>2021-03-04T12:49:10.646Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个二维整数数组 <code>envelopes</code> ，其中 <code>envelopes[i] = [wi, hi]</code> ，表示第 <code>i</code> 个信封的宽度和高度。</p><p>当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。</p><p>请计算 <strong>最多能有多少个</strong> 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。</p><p><strong>注意</strong>：不允许旋转信封。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：envelopes &#x3D; [[5,4],[6,4],[6,7],[2,3]]</span><br><span class="line">输出：3</span><br><span class="line">解释：最多信封的个数为 3, 组合为: [2,3] &#x3D;&gt; [5,4] &#x3D;&gt; [6,7]。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：envelopes &#x3D; [[1,1],[1,1],[1,1]]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= envelopes.length &lt;= 5000</code></li><li><code>envelopes[i].length == 2</code></li><li><code>1 &lt;= wi, hi &lt;= 104</code></li></ul><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>本题可以建模为一个二维的最长上升子序列问题，即选择 $k$ 个信封：$e_1, e_2, … , e_k$，使其满足</p><script type="math/tex; mode=display">\left \{\begin{array}{**lr**}w_{e_1} < w_{e_2} < w_{e_3} < ... < w_{e_k} \\h_{e_1} < h_{e_2} < h_{e_3} < ... < h_{e_k} \\\end{array}\right.</script><p>直接处理这个两维问题较为困难，为了简化问题，我们可以先将所有信封按照宽度 $w$ 从小到大排序，这样就可以把问题转换为求高度数组 $h$ 的最长上升子序列问题。</p><p>然后，我们这样的做法未考虑到两个信封宽度相等的情况。例如，排序后信封 1 的尺寸为 [w = 1, h = 3]，信封 2 的尺寸为 [w = 1, h = 4]，这种信封 1 是不可以装进信封 2 的。如何避免这种情况呢？很简单，当两个或多个信封的宽度相等时，我们只需要让高度较大的新增排在高度较小的信封前面即可。这样我们就可以完全忽略掉 $w$ 维度，只考虑 $h$ 维度，问题也就建模成了一个一维的最长上升子序列问题。</p><p>对于最长上升子序列，目前最优的解法是一种基于动态规划的时间复杂度为 $O(nlogn)$ 的解法。</p><p>我们令 $dp[i]$ 表示长度为 $i$ 的最长递增子序列末尾元素的最小值，易知 $dp$ 数组是一个单调递增的数组。我们可以通过顺序遍历 $h$ 数组来更新 $dp$ 数组各元素的值，步骤如下</p><ul><li>设当前求得的最长递增子序列长度为 $j$，初始时 $j$ 的长度为 $0$</li><li><p>顺序遍历数组，对于元素 $h_i$</p><ul><li>如果 $h_i &gt; dp[j]$，那么 $h_i$ 就可以接在 $dp[j]$ 之后，形成一个长度更长的递增子序列。此时设置 $dp[j+1] = h_i$，更新递增子序列的最大长度为 $j + 1$。</li><li>如果 $h_i &lt;= dp[j]$，那么需要找到 $j$ 左边第一个大于 $h$ 的元素 $dp[k]$，并更新 $dp[k] = h_i$。由于 $dp$ 数组是单调递增的，因此这个查找的过程可以使用二分法来解决。</li></ul></li><li><p>最终求得最长递增子序列的长度为 $j$ </p></li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeetCode354</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="keyword">int</span>[][] envelopes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (envelopes.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = envelopes.length;</span><br><span class="line">        <span class="comment">// 按照宽度w从小到大排列，宽度相同的按照高度h从大到小排列</span></span><br><span class="line">        Arrays.sort(envelopes, (e1, e2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (e1[<span class="number">0</span>] != e2[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> e1[<span class="number">0</span>] - e2[<span class="number">0</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> e2[<span class="number">1</span>] - e1[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// dp[i] 表示长度为 i 的最长递增子序列末尾元素的最小值</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 长度为0无意义，因此设置为-1</span></span><br><span class="line">        dp[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; envelopes.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> h = envelopes[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (h &gt; dp[j]) &#123;</span><br><span class="line">                dp[j+<span class="number">1</span>] = h;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> index = binarySearch(dp, j, h);</span><br><span class="line">                dp[index] = h;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] dp, <span class="keyword">int</span> right, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (dp[mid] &lt; num) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给你一个二维整数数组 &lt;code&gt;envelopes&lt;/code&gt; ，其中 &lt;code&gt;envelopes[i] = [wi, hi]&lt;/c
      
    
    </summary>
    
      <category term="刷题" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
      <category term="LeetCode" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/LeetCode/"/>
    
    
      <category term="动态规划" scheme="965087276.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 二叉树遍历的迭代算法</title>
    <link href="965087276.github.io/2021/02/22/LeetCode-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E7%9A%84%E8%BF%AD%E4%BB%A3%E7%AE%97%E6%B3%95/"/>
    <id>965087276.github.io/2021/02/22/LeetCode-二叉树遍历的迭代算法/</id>
    <published>2021-02-22T13:39:54.000Z</published>
    <updated>2021-03-08T05:42:15.028Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-144-二叉树的前序遍历"><a href="#LeetCode-144-二叉树的前序遍历" class="headerlink" title="LeetCode 144 二叉树的前序遍历"></a>LeetCode 144 二叉树的前序遍历</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode *node = root;</span><br><span class="line">        <span class="keyword">while</span> (!st.empty() || node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// 遍历到最左节点</span></span><br><span class="line">            <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                res.push_back(node-&gt;val);</span><br><span class="line">                st.push(node);</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = st.top(); </span><br><span class="line">            st.pop();</span><br><span class="line">            <span class="comment">// 设置右节点继续遍历</span></span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="LeetCode-94-二叉树的中序遍历"><a href="#LeetCode-94-二叉树的中序遍历" class="headerlink" title="LeetCode 94 二叉树的中序遍历"></a>LeetCode 94 二叉树的中序遍历</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">    TreeNode *node = root;</span><br><span class="line">    <span class="keyword">while</span> (!st.empty() || node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            st.push(node);</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        node = st.top(); st.pop();</span><br><span class="line">        res.push_back(node-&gt;val);</span><br><span class="line">        node = node-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="LeetCode-145-二叉树的后序遍历"><a href="#LeetCode-145-二叉树的后序遍历" class="headerlink" title="LeetCode 145 二叉树的后序遍历"></a>LeetCode 145 二叉树的后序遍历</h1><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><blockquote><p>作者：dian-dao-de-hu-die<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/er-cha-shu-qian-zhong-hou-xu-die-dai-bia-ozsw/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/er-cha-shu-qian-zhong-hou-xu-die-dai-bia-ozsw/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序遍历顺序为：根 -&gt; 左 -&gt; 右</span></span><br><span class="line"><span class="comment">// 后序遍历顺序为：左 -&gt; 右 -&gt; 根</span></span><br><span class="line"><span class="comment">// 所以, 我们可以把前序遍历的稍作修改: 根 -&gt; 右 -&gt; 左, </span></span><br><span class="line"><span class="comment">// 然后结果存放到栈里进行倒序, 之后再遍历结果栈就可以输出后序遍历了</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; res_st;</span><br><span class="line">    TreeNode *node = root;</span><br><span class="line">    <span class="keyword">while</span> (!st.empty() || node) &#123;</span><br><span class="line">        <span class="keyword">while</span> (node) &#123;</span><br><span class="line">            res_st.push(node);</span><br><span class="line">            st.push(node);</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        node = st.top(); st.pop();</span><br><span class="line">        node = node-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!res_st.empty()) &#123;</span><br><span class="line">        res.push_back(res_st.top()-&gt;val);</span><br><span class="line">        res_st.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">    TreeNode *node = root;</span><br><span class="line">    <span class="comment">// 记录上一次访问的右节点</span></span><br><span class="line">    TreeNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!st.empty() || node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 1.遍历到最左子节点</span></span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            st.push(node);</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        node = st.top(); st.pop();</span><br><span class="line">        <span class="comment">// 2.遍历最左子节点的右子树(右子树存在 &amp;&amp; 未访问过)</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right  &amp;&amp; node-&gt;right != pre) &#123;</span><br><span class="line">            <span class="comment">// 重复压栈以记录当前路径分叉节点</span></span><br><span class="line">            st.push(node);</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 后序：填充vec在node-&gt;left和node-&gt;right后面</span></span><br><span class="line">            <span class="comment">// 注意：此时node的左右子树应均已完成访问 </span></span><br><span class="line">            res.push_back(node-&gt;val);</span><br><span class="line">            <span class="comment">// 避免重复访问右子树[记录当前节点便于下一步对比]</span></span><br><span class="line">            pre = node;</span><br><span class="line">            <span class="comment">// 避免重复访问左子树[设空节点]</span></span><br><span class="line">            node = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LeetCode-144-二叉树的前序遍历&quot;&gt;&lt;a href=&quot;#LeetCode-144-二叉树的前序遍历&quot; class=&quot;headerlink&quot; title=&quot;LeetCode 144 二叉树的前序遍历&quot;&gt;&lt;/a&gt;LeetCode 144 二叉树的前序遍历&lt;/
      
    
    </summary>
    
      <category term="刷题" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
      <category term="剑指Offer" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="二叉树" scheme="965087276.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 772 基本计算器III</title>
    <link href="965087276.github.io/2021/02/20/LeetCode-772-%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8III/"/>
    <id>965087276.github.io/2021/02/20/LeetCode-772-基本计算器III/</id>
    <published>2021-02-20T11:56:05.000Z</published>
    <updated>2021-02-24T09:30:05.170Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>实现一个基本的计算器来计算简单的表达式字符串。</p><p>表达式字符串只包含非负整数， <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> 操作符，左括号 <code>(</code> ，右括号 <code>)</code>和空格 。整数除法需要向下截断。</p><p>你可以假定给定的字符串总是有效的。所有的中间结果的范围为 <code>[-2147483648, 2147483647]</code>。</p><p><strong>进阶：</strong>你可以在不使用内置库函数的情况下解决此问题吗？</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;1 + 1&quot;</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot; 6-4 &#x2F; 2 &quot;</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;2*(5+5*2)&#x2F;3+(6&#x2F;2+8)&quot;</span><br><span class="line">输出：21</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;(2+6* 3+5- (3*14&#x2F;7+2)*5)+3&quot;</span><br><span class="line">输出：-12</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;0&quot;</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><h1 id="解法一：递归法"><a href="#解法一：递归法" class="headerlink" title="解法一：递归法"></a>解法一：递归法</h1><p>顺序遍历表达式串：</p><ul><li>若当前字符为数字，则迭代地将字符串转化为数字num</li><li><p>若当前字符是符号或已经访问到字符串末尾，则考虑<strong>前一个符号 sign</strong>。</p><ul><li>若 sign 为 <code>+</code> 或 <code>-</code> ，则将 <code>+num</code> 或 <code>-num</code> 压入栈中</li><li>若 sign 为 <code>*</code> 或 <code>\</code> ，则将栈顶元素弹出，与 num 相乘或相除，并将结果压入栈中。</li></ul></li><li><p>若当前符号是 <code>(</code>，则递归算出括号内表达式的值</p></li><li>若当前符号是 <code>)</code>，则返回栈中各元素的和，表示结束了一层递归</li></ul><p>最后计算栈中各元素的和，即为最终的和。代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeetCode772</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(s.toCharArray());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[] ch)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Integer&gt; st = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> sign = <span class="string">'+'</span>;</span><br><span class="line">        <span class="keyword">for</span> (; pos &lt; ch.length; pos++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = ch[pos];</span><br><span class="line">            <span class="keyword">if</span> (Character.isDigit(c)) &#123;</span><br><span class="line">                num *= <span class="number">10</span>;</span><br><span class="line">                num += c - <span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'('</span>) &#123;</span><br><span class="line">                ++pos;</span><br><span class="line">                num += dfs(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pos == ch.length - <span class="number">1</span> || (!Character.isDigit(c) &amp;&amp; c != <span class="string">' '</span>)) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (sign) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'+'</span>: st.push(num); <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'-'</span>: st.push(-num); <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'*'</span>: st.push(st.pop() * num); <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'/'</span>: st.push(st.pop() / num); <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sign = c;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">')'</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> getSum(st);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getSum(st);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(Deque&lt;Integer&gt; q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            sum += q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解法二-非递归法"><a href="#解法二-非递归法" class="headerlink" title="解法二 非递归法"></a>解法二 非递归法</h1><p>使用两个栈 <code>num_stack</code> 和 <code>op_stack</code> ，其中 <code>num_stack</code> 用来存储数字，<code>op_stack</code> 用来存储操作符。</p><p>顺序遍历表达式串：</p><ul><li><p>若当前字符为数字，则将数字放入 <code>num_stack</code> 栈，此处要考虑多位数字的情况</p></li><li><p>若当前字符为 <code>(</code>，直接入 <code>op_stack</code> 栈</p></li><li><p>若当前字符为 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>。比较 <code>op_stack</code> 栈顶操作符的优先级与当前操作符的优先级，如果栈顶操作符的优先级大于等于当前操作符的优先级，则从 <code>num_stack</code> 栈中 pop 两个元素，<code>op_stack</code> 中 pop 一个元素，将计算结果存入 <code>num_stack</code> 中。重复这个过程，直到 <code>op_stack</code> 栈空或者其栈顶操作符的优先级小于当前操作符的优先级，此时再将当前操作符存入 <code>op_stack</code>。</p><p>  各操作符优先级中，<code>()</code> 最小，<code>-+</code> 次之，<code>*/</code> 最大。</p></li><li><p>若当前字符为 <code>)</code>，则依次取出 <code>num_stack</code> 栈顶两元素，与 <code>op_stack</code> 栈顶操作符运算后，将结果压入 <code>num_stack</code> 栈中。重复该过程，直到 <code>op_stack</code> 栈顶元素为 <code>(</code>。</p></li></ul><p>最后，再执行一次计算操作：依次取出 <code>num_stack</code> 栈顶两元素，与 <code>op_stack</code> 栈顶操作符运算后，将结果压入 <code>num_stack</code> 栈中。重复该过程，直到 <code>op_stack</code> 栈空。</p><p>最终<code>num_stack</code> 栈顶元素即为最终结果。代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    Deque&lt;Integer&gt; num_stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Deque&lt;Character&gt; op_stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, a, b;</span><br><span class="line">    <span class="keyword">char</span> op;</span><br><span class="line">    <span class="keyword">char</span>[] ch = s.toCharArray();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; ch.length) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = ch[i];</span><br><span class="line">        <span class="keyword">if</span> (Character.isDigit(c)) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; ch.length &amp;&amp; Character.isDigit(ch[i])) &#123;</span><br><span class="line">                num *= <span class="number">10</span>;</span><br><span class="line">                num += ch[i] - <span class="string">'0'</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            num_stack.push(num);</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'('</span>) &#123;</span><br><span class="line">            op_stack.push(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">')'</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> ((op = op_stack.pop()) != <span class="string">'('</span>) &#123;</span><br><span class="line">                b = num_stack.pop();</span><br><span class="line">                a = num_stack.pop();</span><br><span class="line">                num_stack.push(calc(a, b, op));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c != <span class="string">' '</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!op_stack.isEmpty() &amp;&amp; priority(op_stack.peek()) &gt;= priority(c)) &#123;</span><br><span class="line">                op = op_stack.pop();</span><br><span class="line">                b = num_stack.pop();</span><br><span class="line">                a = num_stack.pop();</span><br><span class="line">                num_stack.push(calc(a, b, op));</span><br><span class="line">            &#125;</span><br><span class="line">            op_stack.push(c);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!op_stack.isEmpty()) &#123;</span><br><span class="line">        op = op_stack.pop();</span><br><span class="line">        b = num_stack.pop();</span><br><span class="line">        a = num_stack.pop();</span><br><span class="line">        num_stack.push(calc(a, b, op));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num_stack.peek();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">priority</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">'('</span> || c == <span class="string">')'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">'+'</span> || c == <span class="string">'-'</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">'*'</span> || c == <span class="string">'/'</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">char</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'+'</span>: <span class="keyword">return</span> a + b;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'-'</span>: <span class="keyword">return</span> a - b;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'*'</span>: <span class="keyword">return</span> a * b;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/'</span>: <span class="keyword">return</span> a / b;</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;实现一个基本的计算器来计算简单的表达式字符串。&lt;/p&gt;
&lt;p&gt;表达式字符串只包含非负整数， &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;
      
    
    </summary>
    
      <category term="刷题" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
      <category term="程序员面试金典" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8/"/>
    
    
      <category term="栈" scheme="965087276.github.io/tags/%E6%A0%88/"/>
    
      <category term="模拟" scheme="965087276.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 227 基本计算器II</title>
    <link href="965087276.github.io/2021/02/20/LeetCode-227-%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8II/"/>
    <id>965087276.github.io/2021/02/20/LeetCode-227-基本计算器II/</id>
    <published>2021-02-20T11:47:56.000Z</published>
    <updated>2021-02-20T11:54:53.439Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>实现一个基本的计算器来计算一个简单的字符串表达式的值。</p><p>字符串表达式仅包含非负整数，<code>+</code>， <code>-</code> ，<code>*</code>，<code>/</code> 四种运算符和空格 <code> </code>。 整数除法仅保留整数部分。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;3+2*2&quot;</span><br><span class="line">输出: 7</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot; 3&#x2F;2 &quot;</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot; 3+5 &#x2F; 2 &quot;</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>本题可以用一个栈来存储中间结果。</p><ul><li>当遇到 + 号时，将后面的数字 $num$ 存入栈中</li><li>当遇到 - 号时，将后面的数字变为 $-num$ 存入栈中</li><li>当遇到 <em> 号时，取出栈顶元素 $num1$，获取后面的数字 $num2$，将结果 $num1 </em> num2$ 存入栈中</li><li>当遇到 / 号时，取出栈顶元素 $num1$，获取后面的数字 $num2$，将结果 $num1 / num2$ 存入栈中</li></ul><p>最后，将栈中所有元素相加即为最后的答案。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeetCode16_26</span> </span>&#123;</span><br><span class="line"><span class="comment">// 当前的位置</span></span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析从pos位置开始的数字</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">(<span class="keyword">char</span>[] ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; pos &lt; ch.length &amp;&amp; Character.isDigit(ch[pos]); pos++) &#123;</span><br><span class="line">            ans *= <span class="number">10</span>;</span><br><span class="line">            ans += ch[pos] - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="comment">// 正负号</span></span><br><span class="line">        <span class="keyword">int</span> symbol = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (pos = <span class="number">0</span>; pos &lt; ch.length; pos++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch[pos] == <span class="string">' '</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (Character.isDigit(ch[pos])) &#123;</span><br><span class="line">                stack.push(symbol * getNumber(ch));</span><br><span class="line">                pos--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">switch</span> (ch[pos]) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                    symbol = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                    symbol = -<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">                    pos++;</span><br><span class="line">                    <span class="keyword">while</span> (ch[pos] == <span class="string">' '</span>) pos++;</span><br><span class="line">                    stack.push(stack.pop() * getNumber(ch));</span><br><span class="line">                    pos--;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">                    pos++;</span><br><span class="line">                    <span class="keyword">while</span> (ch[pos] == <span class="string">' '</span>) pos++;</span><br><span class="line">                    stack.push(stack.pop() / getNumber(ch));</span><br><span class="line">                    pos--;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) ans += stack.pop();</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;实现一个基本的计算器来计算一个简单的字符串表达式的值。&lt;/p&gt;
&lt;p&gt;字符串表达式仅包含非负整数，&lt;code&gt;+&lt;/code&gt;， &lt;code
      
    
    </summary>
    
      <category term="刷题" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
      <category term="程序员面试金典" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8/"/>
    
    
      <category term="栈" scheme="965087276.github.io/tags/%E6%A0%88/"/>
    
      <category term="模拟" scheme="965087276.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 84-85 最大矩形</title>
    <link href="965087276.github.io/2021/02/04/LeetCode-85-%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/"/>
    <id>965087276.github.io/2021/02/04/LeetCode-85-最大矩形/</id>
    <published>2021-02-04T00:34:15.000Z</published>
    <updated>2021-02-06T03:02:23.316Z</updated>
    
    <content type="html"><![CDATA[<h1 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84 柱状图中最大的矩形"></a>84 柱状图中最大的矩形</h1><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><img src="1.png" alt=""></p><p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 <code>[2,1,5,6,2,3]</code>。</p><p><img src="2.png" alt=""></p><p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 <code>10</code> 个单位。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,1,5,6,2,3]</span><br><span class="line">输出: 10</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>我们可以枚举每一根柱子的高 $h_i$，计算以 $h_i$ 为高的矩形的面积 $area_i$，那么最终矩形的最大面积即为 各 $area_i$ 的最大值。</p><p>具体做法是：使用一重循环枚举每一根柱子，将其固定为矩形的高度 $h$。随后我们从这根柱子开始向左右两侧燕伸，直到遇到高度小于 $h$ 的柱子，这样就确定了矩形的左右边界。如果左右边界之间的宽度为 $\omega$，那么对应的矩形面积即为 $\omega * h$。</p><p>为此，我们维护两个数组 $left$ 和 $right$，其中：</p><ul><li>$left[i]$ 表示从柱子 $i$ 向左边延伸，找到的第一个高度小于 $h_i$ 的柱子。边界条件为 $left[0] = -1$</li><li>$right[i]$ 表示从柱子 $i$ 向右边延伸，找到的第一个高度小于 $h_i$ 的柱子。边界条件为 $right[n-1] = n$</li></ul><p>例如，对于下面的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">h &#x3D; [2, 4, 5, 6, 2, 3]</span><br><span class="line">高度为5的柱子下标为2，左边第一个比它小的柱子下标为1，右边第一个比它小的柱子下标为4。</span><br><span class="line">因此：left[2] &#x3D; 1; right[2] &#x3D; 4</span><br></pre></td></tr></table></figure><p>那么，如何计算 $left[i]$ 呢？</p><p>我们首先比较 $i$ 左边柱子的高度 $h[i-1]$ 与 $i$ 的高度 $h[i]$ 的大小，若 $h[i-1] &lt; h[i]$，那么 $left[i] = i - 1$。如果 $h[i-1] &gt;= h[i]$，那么我们可以向左找到第一个高度小于 $h[i-1]$ 的柱子再跟柱子 $i$ 比较。那左边第一个第一个高度小于 $h[i-1]$ 的柱子如何找呢？其实不用找，这个柱子就是 $left[i-1]$ 。</p><p>根据这个思路，我们可以在 $O(n)$ 的时间复杂度内计算出 $left$ 数组的值，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">left[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> j = i - <span class="number">1</span>; <span class="comment">// i左边的柱子</span></span><br><span class="line">    <span class="keyword">while</span> (j != -<span class="number">1</span> &amp;&amp; h[j] &gt;= h[i]) &#123;</span><br><span class="line">        j = left[j];</span><br><span class="line">    &#125;</span><br><span class="line">    left[i] = j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似的，$right$ 数组的值也可以在 $O(n)$ 的时间复杂度内求出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">right[n-<span class="number">1</span>] = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">int</span> j = n + <span class="number">1</span>; <span class="comment">// i右边的柱子</span></span><br><span class="line">    <span class="keyword">while</span> (j != -<span class="number">1</span> &amp;&amp; h[j] &gt;= h[i]) &#123;</span><br><span class="line">        j = right[j];</span><br><span class="line">    &#125;</span><br><span class="line">    right[i] = j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算出这两个数组后，对于每根柱子 $i$，以其高度 $h[i]$ 为高的矩形面积即为</p><script type="math/tex; mode=display">\begin{align}area_i &= h[i] * [(right[i] - 1) - (left[i] + 1) + 1] \\       &= h[i] * (right[i] - left[i] + 1)\end{align}</script><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">            使用 left 和 right 数组 记录 从 i 左右两边延伸，第一个比 i 位置小的柱子索引位置</span></span><br><span class="line"><span class="comment">            那么第 i 根柱子能组成面积的宽度就是 right[i] - left[i] - 1</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">int</span> n = heights.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="comment">// 第一根柱子，左边不存在比它小的</span></span><br><span class="line">        left[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 第二根柱子，右边不存在比它大的</span></span><br><span class="line">        right[n-<span class="number">1</span>] = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j != -<span class="number">1</span> &amp;&amp; heights[j] &gt;= heights[i]) &#123;</span><br><span class="line">                j = left[j];</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j != n &amp;&amp; heights[j] &gt;= heights[i]) &#123;</span><br><span class="line">                j = right[j];</span><br><span class="line">            &#125;</span><br><span class="line">            right[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> width = right[i] - left[i] - <span class="number">1</span>;</span><br><span class="line">            maxArea = Math.max(maxArea, heights[i] * width);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="85-最大矩形"><a href="#85-最大矩形" class="headerlink" title="85 最大矩形"></a>85 最大矩形</h1><p>给定一个仅包含 <code>0</code> 和 <code>1</code> 、大小为 <code>rows x cols</code> 的二维二进制矩阵，找出只包含 <code>1</code> 的最大矩形，并返回其面积。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">                [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],</span><br><span class="line">                [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],</span><br><span class="line">                [&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]</span><br><span class="line">输出：6</span><br><span class="line">解释：最大矩形如上图所示。</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>rows == matrix.length</code></li><li><code>cols == matrix[0].length</code></li><li><code>0 &lt;= row, cols &lt;= 200</code></li><li><code>matrix[i][j]</code> 为 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li></ul><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>这个题目其实是上面一题的二维版，我们可以每次把前 $i$ 行看成一个柱形图，然后调用上面一题的解法算出一个面积，最终取一个最大值。</p><p>例如，对于示例1中的例子：</p><ul><li>第 1 行可以看作是一个高度 $h = [1, 0, 1, 0, 0]$ 的柱形图，求得最大面积为 $1$。</li><li>前 2 行可以看作是一个高度 $h = [2, 0, 2, 1, 1]$ 的柱形图，求得最大面积为 $3$。</li><li>前 3 行可以看作是一个高度 $h = [3, 1, 3, 2, 2]$ 的柱形图，求得最大面积为 $6$。</li><li>前 4 行可以看作是一个高度 $h = [4, 0, 0, 3, 0]$ 的柱形图，求得最大面积为 $4$。</li></ul><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.length, n;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span> || ((n = matrix[<span class="number">0</span>].length) == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 柱状图高度</span></span><br><span class="line">    <span class="keyword">int</span>[] heights = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="string">'0'</span>) &#123;</span><br><span class="line">                heights[j] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 这句等价于 heights[i][j] = (i == 0 ? 1 : heights[i-1][j] + 1); </span></span><br><span class="line">                heights[j] = (i == <span class="number">0</span> ? <span class="number">1</span> : heights[j] + <span class="number">1</span>); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> area = largestRectangleArea(heights);</span><br><span class="line">        maxArea = Math.max(maxArea, area);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">        使用 left 和 right 数组 记录 从 i 左右两边延伸，第一个比 i 位置小的柱子索引位置</span></span><br><span class="line"><span class="comment">        那么第 i 根柱子能组成面积的宽度就是 right[i] - left[i] - 1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> n = heights.length;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="comment">// 第一根柱子，左边不存在比它小的</span></span><br><span class="line">    left[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 第二根柱子，右边不存在比它大的</span></span><br><span class="line">    right[n-<span class="number">1</span>] = n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j != -<span class="number">1</span> &amp;&amp; heights[j] &gt;= heights[i]) &#123;</span><br><span class="line">            j = left[j];</span><br><span class="line">        &#125;</span><br><span class="line">        left[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j != n &amp;&amp; heights[j] &gt;= heights[i]) &#123;</span><br><span class="line">            j = right[j];</span><br><span class="line">        &#125;</span><br><span class="line">        right[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> width = right[i] - left[i] - <span class="number">1</span>;</span><br><span class="line">        maxArea = Math.max(maxArea, heights[i] * width);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;84-柱状图中最大的矩形&quot;&gt;&lt;a href=&quot;#84-柱状图中最大的矩形&quot; class=&quot;headerlink&quot; title=&quot;84 柱状图中最大的矩形&quot;&gt;&lt;/a&gt;84 柱状图中最大的矩形&lt;/h1&gt;&lt;p&gt;给定 &lt;em&gt;n&lt;/em&gt; 个非负整数，用来表示柱状图中各个
      
    
    </summary>
    
      <category term="刷题" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
      <category term="LeetCode" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/LeetCode/"/>
    
    
      <category term="难题" scheme="965087276.github.io/tags/%E9%9A%BE%E9%A2%98/"/>
    
      <category term="单调栈" scheme="965087276.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
      <category term="动态规划" scheme="965087276.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>面试中的概率题</title>
    <link href="965087276.github.io/2021/02/03/%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E6%A6%82%E7%8E%87%E9%A2%98/"/>
    <id>965087276.github.io/2021/02/03/面试中的概率题/</id>
    <published>2021-02-03T08:16:49.000Z</published>
    <updated>2021-02-03T08:59:48.259Z</updated>
    
    <content type="html"><![CDATA[<h1 id="递推公式"><a href="#递推公式" class="headerlink" title="递推公式"></a>递推公式</h1><h2 id="抛硬币"><a href="#抛硬币" class="headerlink" title="抛硬币"></a>抛硬币</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>甲乙两人玩抛硬币的游戏（硬币只有 1 枚），规定抛出“正正反”这样的序列时，则甲获胜，游戏结束；规定抛出“正 反反”这样的序列时，则乙获胜，游戏结束。问：甲获胜的概率是多大？</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>参考下面一篇博客</p><blockquote><p><a href="https://blog.csdn.net/star_38/article/details/105903884" target="_blank" rel="noopener">https://blog.csdn.net/star_38/article/details/105903884</a></p></blockquote><p>用数字 1 代表正面，0 代表反面。</p><p>前两次抛硬币结束后，会出现四种情况（00，01，10，11），这四种情况的概率相等，都为 0.25。</p><p>对于这四种情况，我们假设：</p><ul><li>前两轮为 00 时，甲获胜的概率为 $P1$</li><li>前两轮为 01 时，甲获胜的概率为 $P2$</li><li>前两轮为 10 时，甲获胜的概率为 $P3$</li><li>前两轮为 11 时，甲获胜的概率为 $P4$</li></ul><p>首先来看第一种情况</p><ul><li>若第三轮抛出的还是 0，三轮为 000。那么甲获胜的概率等价于前两轮为 00 的情况（因为我们只需关注最后两位的值即可），所以概率是 $P1$</li><li>若第三轮抛出的是 1，三轮为 001。那么甲获胜的概率等价于前两轮为 01 的情况，所以概率是 $P2$</li><li>综上得到 $P1 = 0.5P1 + 0.5P2$</li></ul><p>再来看第二种情况</p><ul><li>若第三轮抛出的是 0，三轮为 010。那么按照前面的分析，甲获胜的概率等价于前两轮为 10 的情况，所以概率是 $P3$</li><li>若第三轮抛出的是 1，三轮为 011。那么甲获胜的概率等价于前两轮为 11 的情况，所以概率是 $P4$</li><li>综上得到 $P2 = 0.5P3 + 0.5P4$</li></ul><p>再来看第三种情况</p><ul><li>若第三轮抛出的是 0，三轮为 100。此时乙获胜，因此甲获胜概率为 0</li><li>若第三轮抛出的是 1，三轮为 101。那么甲获胜的概率等价于前两轮为 01 的情况，所以概率是 $P2$</li><li>综上得到 $P3 = 0.5P2$</li></ul><p>最后看第四种情况</p><ul><li>若第三轮抛出的是 0，三轮为 110。此时甲获胜，因此甲获胜概率为 1</li><li>若第三轮抛出的是 1，三轮为 111。那么甲获胜的概率等价于前两轮为 11 的情况，所以概率是 $P4$</li><li>综上得到 $P4 = 0.5 * 1 + 0.5P4$</li></ul><p>通过 $P4 = 0.5 * 1 + 0.5P4$ 可以发现，第四种情况下甲获胜的概率是 100%。其实确实是这样子的，因为前两轮已经抛出了 11，乙若想获胜必须要出现 100 才行，也就是说要连续出现两个 0 才行。然而，当第 1 个 0 出现时，最后三位的序列就是 110，此时甲已经获胜了，因此不可能再出现连续两个 0 的情况，所以在这种情况下乙是不可能赢的。</p><p>根据这四个公式</p><script type="math/tex; mode=display">\left\{            \begin{array}{ll}              P1 = 0.5P1 + 0.5P2\\              P2 = 0.5P3 + 0.5P4\\              P3 = 0.5P2\\              P4 = 0.5 * 1 + 0.5P4            \end{array}          \right.</script><p>可以解出</p><script type="math/tex; mode=display">\left\{            \begin{array}{ll}              P1 = \frac{2}{3}\\              P2 = \frac{2}{3}\\              P3 = \frac{1}{3}\\              P4 = 1            \end{array}          \right.</script><p>因此，甲获胜的概率</p><script type="math/tex; mode=display">P = 0.25(P1 + P2 + P3 + P4) = \frac{2}{3}</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;递推公式&quot;&gt;&lt;a href=&quot;#递推公式&quot; class=&quot;headerlink&quot; title=&quot;递推公式&quot;&gt;&lt;/a&gt;递推公式&lt;/h1&gt;&lt;h2 id=&quot;抛硬币&quot;&gt;&lt;a href=&quot;#抛硬币&quot; class=&quot;headerlink&quot; title=&quot;抛硬币&quot;&gt;&lt;/a&gt;抛硬
      
    
    </summary>
    
      <category term="面试" scheme="965087276.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="概率与数学期望" scheme="965087276.github.io/tags/%E6%A6%82%E7%8E%87%E4%B8%8E%E6%95%B0%E5%AD%A6%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 4 寻找两个正序数组的中位数</title>
    <link href="965087276.github.io/2021/02/03/LeetCode-4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>965087276.github.io/2021/02/03/LeetCode-4-寻找两个正序数组的中位数/</id>
    <published>2021-02-03T01:22:46.000Z</published>
    <updated>2021-02-03T02:24:07.398Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定两个大小为 m 和 n 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的中位数。</p><p><strong>进阶：</strong>你能设计一个时间复杂度为 <code>O(log (m+n))</code> 的算法解决此问题吗？</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 &#x3D; [1,3], nums2 &#x3D; [2]</span><br><span class="line">输出：2.00000</span><br><span class="line">解释：合并数组 &#x3D; [1,2,3] ，中位数 2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 &#x3D; [1,2], nums2 &#x3D; [3,4]</span><br><span class="line">输出：2.50000</span><br><span class="line">解释：合并数组 &#x3D; [1,2,3,4] ，中位数 (2 + 3) &#x2F; 2 &#x3D; 2.5</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 &#x3D; [0,0], nums2 &#x3D; [0,0]</span><br><span class="line">输出：0.00000</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 &#x3D; [], nums2 &#x3D; [1]</span><br><span class="line">输出：1.00000</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 &#x3D; [2], nums2 &#x3D; []</span><br><span class="line">输出：2.00000</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>nums1.length == m</code></li><li><code>nums2.length == n</code></li><li><code>0 &lt;= m &lt;= 1000</code></li><li><code>0 &lt;= n &lt;= 1000</code></li><li><code>1 &lt;= m + n &lt;= 2000</code></li><li><code>-10^6 &lt;= nums1[i], nums2[i] &lt;= 10^6</code></li></ul><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这里转载下面一篇题解。</p><blockquote><p>作者：windliang<br>链接：<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><p>题目规定的时间复杂度是 $O(log(m+n))$，而 <code>log</code> 这个复杂度，只有使用二分算法才可以达到。</p><p>我们可以换一种思路，题目要求是求中位数，其实就是求第 $k$ 小数的一种特殊情况，而求第 $k$ 小的数有一种非常优秀的算法。</p><p>对于两个有序数组，如果我们要从中找出第 $k$ 小的数，那么我们可以一半儿一半儿的排除掉不符合条件的数，每次去掉 $k / 2$ 个数。例如下面的例子</p><p>假设我们要找第 $7$ 小的数</p><p><img src="1.png" alt=""></p><p>我们比较两个数组的第 <code>k/2</code> 个数字，如果 <code>k</code> 是奇数，向下取整。也就是比较第 3 个数字，上边数组中的 4 和下边数组中的 3，如果哪个小，就表明该数组的前 <code>k/2</code> 个数字都不是第 <code>k</code> 小数字，所以可以排除。也就是 1，2，3 这三个数字不可能是第 7 小的数字，我们可以把它排除掉。将 1349 和 45678910 两个数组作为新的数组进行比较。</p><p>更一般的情况 <code>A[1]</code> ，<code>A[2]</code> ，<code>A[3]</code>，<code>A[k/2]</code> … ，<code>B[1]</code>，<code>B[2]</code>，<code>B[3]</code>，<code>B[k/2]</code>… ，如果 <code>A[k/2]</code>&lt;<code>B[k/2]</code> ，那么<code>A[1]</code>，<code>A[2]</code>，<code>A[3]</code>，<code>A[k/2]</code> 都不可能是第 <code>k</code> 小的数字。</p><p>橙色的部分表示已经去掉的数字。</p><p><img src="2.png" alt=""></p><p>由于我们已经排除掉了 3 个数字，就是这 3 个数字一定在最前边，所以在两个新数组中，我们只需要找第 7 - 3 = 4 小的数字就可以了，也就是 k = 4。此时两个数组，比较第 2 个数字，3 &lt; 5，所以我们可以把小的那个数组中的 1 ，3 排除掉了。</p><p><img src="3.png" alt=""></p><p>我们又排除掉 2 个数字，所以现在找第 4 - 2 = 2 小的数字就可以了。此时比较两个数组中的第 k / 2 = 1 个数，4 == 4，怎么办呢？由于两个数相等，所以我们无论去掉哪个数组中的都行，因为去掉 1 个总会保留 1 个的，所以没有影响。为了统一，我们就假设 4 &gt; 4 吧，所以此时将下边的 4 去掉。</p><p><img src="4.png" alt=""></p><p>由于又去掉 1 个数字，此时我们要找第 1 小的数字，所以只需判断两个数组中第一个数字哪个小就可以了，也就是 4。</p><p>所以第 7 小的数字是 4。</p><p>我们每次都是取 <code>k/2</code> 的数进行比较，有时候可能会遇到数组长度小于 <code>k/2</code>的时候。</p><p><img src="5.png" alt=""></p><p>此时 k / 2 等于 3，而上边的数组长度是 2，我们此时将箭头指向它的末尾就可以了。这样的话，由于 2 &lt; 3，所以就会导致上边的数组 1，2 都被排除。造成下边的情况。</p><p>由于 2 个元素被排除，所以此时 k = 5，又由于上边的数组已经空了，我们只需要返回下边的数组的第 5 个数字就可以了。</p><p>从上边可以看到，无论是找第奇数个还是第偶数个数字，对我们的算法并没有影响，而且在算法进行中，k 的值都有可能从奇数变为偶数，最终都会变为 1 或者由于一个数组空了，直接返回结果。</p><p>所以我们采用递归的思路，为了防止数组长度小于 <code>k/2</code>，所以每次比较 <code>min(k/2</code>，<code>len</code>(数组) 对应的数字，把小的那个对应的数组的数字排除，将两个新数组进入递归，并且 <code>k</code> 要减去排除的数字的个数。递归出口就是当 <code>k=1</code> 或者其中一个数字长度是 <code>0</code> 了。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums1.length;</span><br><span class="line">    <span class="keyword">int</span> m = nums2.length;</span><br><span class="line">    <span class="keyword">int</span> left = (n + m + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> right = (n + m + <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//将偶数和奇数的情况合并，如果是奇数，会求两次同样的 k 。</span></span><br><span class="line">    <span class="keyword">return</span> (getKth(nums1, <span class="number">0</span>, n - <span class="number">1</span>, nums2, <span class="number">0</span>, m - <span class="number">1</span>, left) + getKth(nums1, <span class="number">0</span>, n - <span class="number">1</span>, nums2, <span class="number">0</span>, m - <span class="number">1</span>, right)) * <span class="number">0.5</span>;  </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getKth</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> start1, <span class="keyword">int</span> end1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> start2, <span class="keyword">int</span> end2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = end1 - start1 + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> len2 = end2 - start2 + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//让 len1 的长度小于 len2，这样就能保证如果有数组空了，一定是 len1 </span></span><br><span class="line">    <span class="keyword">if</span> (len1 &gt; len2) <span class="keyword">return</span> getKth(nums2, start2, end2, nums1, start1, end1, k);</span><br><span class="line">    <span class="keyword">if</span> (len1 == <span class="number">0</span>) <span class="keyword">return</span> nums2[start2 + k - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> Math.min(nums1[start1], nums2[start2]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = start1 + Math.min(len1, k / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = start2 + Math.min(len2, k / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">        <span class="keyword">return</span> getKth(nums1, start1, end1, nums2, j + <span class="number">1</span>, end2, k - (j - start2 + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getKth(nums1, i + <span class="number">1</span>, end1, nums2, start2, end2, k - (i - start1 + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定两个大小为 m 和 n 的正序（从小到大）数组 &lt;code&gt;nums1&lt;/code&gt; 和 &lt;code&gt;nums2&lt;/code&gt;。请你找出
      
    
    </summary>
    
      <category term="刷题" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
      <category term="剑指Offer" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="二分法" scheme="965087276.github.io/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 440 字典序的第K小数字</title>
    <link href="965087276.github.io/2021/02/02/LeetCode-440-%E5%AD%97%E5%85%B8%E5%BA%8F%E7%9A%84%E7%AC%ACK%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <id>965087276.github.io/2021/02/02/LeetCode-440-字典序的第K小数字/</id>
    <published>2021-02-02T01:28:52.000Z</published>
    <updated>2021-02-03T09:18:15.127Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定整数 <code>n</code> 和 <code>k</code>，找到 <code>1</code> 到 <code>n</code> 中字典序第 <code>k</code> 小的数字。</p><p>注意：$1 ≤ k ≤ n ≤ 10^9$。</p><p><strong>示例 :</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">n: 13   k: 2</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">10</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。</span><br></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>所谓字典序其实就是按照数字的前缀进行排序。如果我们将 $1-n$ 这 $n$ 个数字组成一棵前缀树（或者叫“字典树”，其根节点为空节点）Trie，那么对这棵树进行先序遍历时，第 $k$ （不包括根节点）个节点即对应了字典序的第 $k$ 小的数字。然而，构造字典树并进行先序遍历需要花费 $O(n)$ 的时间以及 $O(n)$ 的空间，这对于本题来说是不允许的。因此，我们需要针对这两个过程进行优化。</p><p>首先，我们在先序遍历时，首先会遍历以 $1$ 为前缀的数字。如果以 $1$ 为前缀的数字个数小于 $k$ ，就说明第 $k$ 个的数字的前缀肯定大于1。然后，我们继续遍历以 $2$ 为前缀的数字，若 <code>前缀为1的数字个数 + 前缀为2的数字个数 &gt;= k</code>，就说明第 $k$ 个的数字的前缀肯定为 $2$，否则继续去遍历前缀为3的数字，以此类推。</p><p>在上面的过程中，我们能够推断出第 $k$ 个数字的前缀是多少，而推断的关键在于<strong>如何计算指定前缀下的数字的个数</strong>。按照上面的计算方式，这个时间复杂度是 $O(n)$，肯定不符合要求，因此，这一步计算是我们优化的关键。</p><h2 id="计算指定前缀下的数字的个数"><a href="#计算指定前缀下的数字的个数" class="headerlink" title="计算指定前缀下的数字的个数"></a>计算指定前缀下的数字的个数</h2><p>假设 $n = 1248$，我们要计算以 $1$ 为前缀的数字的个数。</p><p>我们可以用数学的方法来一步步算一下：</p><ul><li>长度为 1 的数字有 1 个：1。写成区间为 $[1, 2)$。</li><li>长度为 2 的数字有 10 个：$10 \sim 19$。写成区间为 $[10, 20)$。</li><li>长度为 3 的数字有 100 个：$100 \sim 199$。写成区间为 $[100, 200)$。</li><li>长度为 4 的数字有 249 个：$1000 \sim 1248$。写成区间为 $[1000, 1248]$。</li></ul><p>可以看到，除了第 4 个外，前三个都是有规律的，其数字个数等于 $10^{l-1}$（其中 $l$ 指的是数字的长度）。到了最后的第四层，因为 $1999 &gt; 1248$，所以最后一层数字的个数要用 $n - 1000 + 1 = 249$ 来计算。</p><p>把上面的步骤翻译成代码，就可以在 $O(log_{10}n)$ 的复杂度内算出指定前缀下的数字个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以prefix为前缀（包括prefix本身）并且小于等于n的数字的个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> prefix</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getCount</span><span class="params">(<span class="keyword">long</span> prefix, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最终的答案</span></span><br><span class="line">    <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 每一层数字的最大个数。其值为10的幂次：1、10、100、1000...</span></span><br><span class="line">    level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (prefix &lt;= n) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 分别计算每一层，以prefix为前缀并且小于等于n的数字的个数。</span></span><br><span class="line"><span class="comment">         * 下面一层的数字一定大于上面一层的所有数字（越往下位数越大）；因此，若某一层的数字已经超过n了，就不需要往下找了.</span></span><br><span class="line"><span class="comment">         * 假设n=1248, 找前缀为1的数</span></span><br><span class="line"><span class="comment">         * 那么第一层是 [1, 2) 有一个数，也就是10^0</span></span><br><span class="line"><span class="comment">         * 第二层是 [10, 20) 有10个数，也就是10^1</span></span><br><span class="line"><span class="comment">         * 第三层是 [100, 200) 有100个数，也就是10^2</span></span><br><span class="line"><span class="comment">         * 第四层就不能是[1000, 2000)了，因为2000已经超了1248, 所以是[1000, 1248)，也就是 n - prefix + 1。这里 n=1248, prefix = 1000</span></span><br><span class="line"><span class="comment">         [1, 2) -&gt; [10, 20) -&gt; [100, 200) -&gt; [1000, 1248]</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ans += Math.min(level, n - prefix + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 往下面走一层，数字个数为1、10、100、1000...。</span></span><br><span class="line"><span class="comment">         * 例如：[1, 2) -&gt; [10, 20) -&gt; [100, 200)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        prefix *= <span class="number">10</span>;</span><br><span class="line">        level *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何定位-k-的位置"><a href="#如何定位-k-的位置" class="headerlink" title="如何定位 k 的位置"></a>如何定位 k 的位置</h2><p>计算出指定前缀下的数字的个数，我们可以逐步地确定出 $k$ 的具体位置。</p><p>我们首先计算以数字 $1$ 为前缀的数字的个数，这里有两种情况</p><ul><li>如果个数大于等于 $k$，说明以数字 $1$ 开头的数字串太多了，并且第 $k$ 个数字一定是以数字 $1$ 开头。此时，我们可以缩小范围，向下走一层，将前缀乘10，计算以数字 $10$ 为前缀的数字的个数。</li><li>如果个数小于 $k$ ，说明以数字 $1$ 开头的数字串都算进去，也不够。此时我们应该向右走一步，将前缀 + 1，计算以数字 $2$ 为前缀的数字的个数。</li></ul><p>在向下或向右走的过程中，继续按照上面的两种情况进行处理，直到找到第 $k$ 个位置为止。</p><p>实现的代码如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthNumber</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> prefix = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">long</span> p = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p &lt; k) &#123;</span><br><span class="line">        <span class="comment">// 以prefix为前缀的数字的个数</span></span><br><span class="line">        <span class="keyword">long</span> cnt = getCount(prefix, n);</span><br><span class="line">        <span class="keyword">if</span> (p + cnt - <span class="number">1</span> &gt;= k) &#123; <span class="comment">// 这里的p已经包含了prefix自身，为了避免重复计算，最后要减1</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 进到if里说明以prefix为前缀的数太多了。</span></span><br><span class="line"><span class="comment">             * 因此第k小的数一定以prefix为前缀。</span></span><br><span class="line"><span class="comment">             * 因此只向下寻找prefix前缀的数即可。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            p++; <span class="comment">// 往下走一步；p加1是因为要加下一个节点</span></span><br><span class="line">            prefix *= <span class="number">10</span>; <span class="comment">// 下一层的前缀</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 以prefix为前缀的数都算进去，也不够。</span></span><br><span class="line"><span class="comment">             * 说明第k小的数不是以prefix为前缀。</span></span><br><span class="line"><span class="comment">             * 所以需要从下一个前缀开始找</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            p += cnt; <span class="comment">// 往右走一步；p加上当前prefix的数字个数cnt-1，以及下一个节点（右边节点），一共是cnt个节点</span></span><br><span class="line">            prefix++; <span class="comment">// 找下一个前缀</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) prefix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>最终的代码如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以prefix为前缀（包括prefix本身）并且小于等于n的数字的个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> prefix</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getCount</span><span class="params">(<span class="keyword">long</span> prefix, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最终的答案</span></span><br><span class="line">    <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 每一层数字的最大个数。其值为10的幂次：1、10、100、1000...</span></span><br><span class="line">    level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (prefix &lt;= n) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 分别计算每一层，以prefix为前缀并且小于等于n的数字的个数。</span></span><br><span class="line"><span class="comment">         * 下面一层的数字一定大于上面一层的所有数字（越往下位数越大）；因此，若某一层的数字已经超过n了，就不需要往下找了</span></span><br><span class="line"><span class="comment">         [1, 2) -&gt; [10, 20) -&gt; [100, 200) -&gt; [1000, 1248]</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ans += Math.min(level, n - prefix + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 往下面走一层，数字个数为1、10、100、1000...。</span></span><br><span class="line"><span class="comment">         * 例如：[1, 2) -&gt; [10, 20) -&gt; [100, 200)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        prefix *= <span class="number">10</span>;</span><br><span class="line">        level *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthNumber</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> prefix = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">long</span> p = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p &lt; k) &#123;</span><br><span class="line">        <span class="comment">// 以prefix为前缀的数字的个数</span></span><br><span class="line">        <span class="keyword">long</span> cnt = getCount(prefix, n);</span><br><span class="line">        <span class="keyword">if</span> (p + cnt - <span class="number">1</span> &gt;= k) &#123; <span class="comment">// 这里的p已经包含了prefix自身，为了避免重复计算，最后要减1</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 进到if里说明以prefix为前缀的数太多了。</span></span><br><span class="line"><span class="comment">             * 因此第k小的数一定以prefix为前缀。</span></span><br><span class="line"><span class="comment">             * 因此只向下寻找prefix前缀的数即可。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            p++; <span class="comment">// 往下走一步；p加1是因为要加下一个节点</span></span><br><span class="line">            prefix *= <span class="number">10</span>; <span class="comment">// 下一层的前缀</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 以prefix为前缀的数都算进去，也不够。</span></span><br><span class="line"><span class="comment">             * 说明第k小的数不是以prefix为前缀。</span></span><br><span class="line"><span class="comment">             * 所以需要从下一个前缀开始找</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            p += cnt; <span class="comment">// 往右走一步；p加上当前prefix的数字个数cnt-1，以及下一个节点（右边节点），一共是cnt个节点</span></span><br><span class="line">            prefix++; <span class="comment">// 找下一个前缀</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) prefix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定整数 &lt;code&gt;n&lt;/code&gt; 和 &lt;code&gt;k&lt;/code&gt;，找到 &lt;code&gt;1&lt;/code&gt; 到 &lt;code&gt;n&lt;/code
      
    
    </summary>
    
      <category term="刷题" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
      <category term="LeetCode" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/LeetCode/"/>
    
    
      <category term="思路" scheme="965087276.github.io/tags/%E6%80%9D%E8%B7%AF/"/>
    
      <category term="构造" scheme="965087276.github.io/tags/%E6%9E%84%E9%80%A0/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 37 解数独</title>
    <link href="965087276.github.io/2021/02/01/LeetCode-37-%E8%A7%A3%E6%95%B0%E7%8B%AC/"/>
    <id>965087276.github.io/2021/02/01/LeetCode-37-解数独/</id>
    <published>2021-02-01T02:43:25.000Z</published>
    <updated>2021-02-01T14:38:56.844Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>编写一个程序，通过填充空格来解决数独问题。</p><p>一个数独的解法需<strong>遵循如下规则</strong>：</p><ol><li>数字 <code>1-9</code> 在每一行只能出现一次。</li><li>数字 <code>1-9</code> 在每一列只能出现一次。</li><li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。</li></ol><p>空白格用 <code>&#39;.&#39;</code> 表示。</p><p><img src="1.png" alt=""></p><p>一个数独。</p><p><img src="2.png" alt=""></p><p>答案被标成红色。</p><p><strong>提示：</strong></p><ul><li>给定的数独序列只包含数字 <code>1-9</code> 和字符 <code>&#39;.&#39;</code> 。</li><li>你可以假设给定的数独只有唯一解。</li><li>给定数独永远是 <code>9x9</code> 形式的。</li></ul><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这个题目显然是用回溯法来求解。我们可以依次枚举每一个空白格中填的数字，通过递归 + 回溯的方式枚举所有的填法。当递归填完最后一个空白格后，如果仍没有冲突发生，说明数独已经解出。如果在递归过程中，当前的空白格不能填下任何一个数字，说明之前某次填的有问题，那么就进行回溯。</p><p>如何判断一个空白格中能否填写某个数字呢，这需要去记录该空白格所在的行、列以及九宫格中已经填写过的数字，每个数字在同一行、同一列、同一个九宫格中只能出现一次。因此我们可以使用 <code>rows[i], columns[j], blocks[x][y]</code> 分别表示第 $i$ 行，第 $j$ 列，第$(x, y)$ 个九宫格中填写数字的情况。表示数字填写的方法有两种：一种是使用类似哈希表的方法，用长度为9的布尔数组记录分别记录数字 1-9 是否填写过；另一种是使用一个 9 bit的整数来记录，第 $i$ 位代表数字 $i+1$ 是否填写过，该位为0表示未填写过，1表示填写过。</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="原始回溯解法"><a href="#原始回溯解法" class="headerlink" title="原始回溯解法"></a>原始回溯解法</h2><p>使用一个长度为 9 的布尔数组记录数字 [1, 9] 是否出现过，数组第 $i$ 个元素的值为 true 当且仅当数字 $i+1$ 出现过。例如 <code>rows[2][3] = true</code> 表示数字 4 在第 2 行已经出现过，那么在遍历第二行的空白格时，就不能填入数字 4。</p><p>我们首先找到所有的空白格，放到数组 <code>emptys</code> 中，而对于有数字的格子，分别更新 <code>rows, cols, blocks</code> 这三个数组的状态值。然后，依次对每个空白格子递归填数即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 行、列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[][] rows, cols;</span><br><span class="line"><span class="comment">// 九宫格</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[][][] blocks;</span><br><span class="line"><span class="comment">// 记录空白格子的下标</span></span><br><span class="line"><span class="keyword">private</span> List&lt;<span class="keyword">int</span>[]&gt; emptys;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">    rows = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">    cols = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">    blocks = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">3</span>][<span class="number">3</span>][<span class="number">9</span>];</span><br><span class="line">    emptys = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">'.'</span>) &#123;</span><br><span class="line">            emptys.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将数字范围规定在0-8，因此减1</span></span><br><span class="line">            <span class="keyword">int</span> v = board[i][j] - <span class="string">'0'</span> - <span class="number">1</span>;</span><br><span class="line">            rows[i][v] = cols[j][v] = blocks[i / <span class="number">3</span>][j / <span class="number">3</span>][v] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(board, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos == emptys.size()) &#123;</span><br><span class="line">        <span class="comment">// 空白格子都填完了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> r = emptys.get(pos)[<span class="number">0</span>], c = emptys.get(pos)[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123; <span class="comment">// 尝试数字i+1能否填写</span></span><br><span class="line">        <span class="keyword">if</span> (!rows[r][i] &amp;&amp; !cols[c][i] &amp;&amp; !blocks[r / <span class="number">3</span>][c / <span class="number">3</span>][i]) &#123;</span><br><span class="line">            <span class="comment">// board[r][c] = i</span></span><br><span class="line">            rows[r][i] = cols[c][i] = blocks[r / <span class="number">3</span>][c / <span class="number">3</span>][i] = <span class="keyword">true</span>;</span><br><span class="line">            board[r][c] = (<span class="keyword">char</span>) (i + <span class="string">'0'</span> + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dfs(board, pos + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 填写数字i+1可以使得数独有解</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 不可填写数字i+1，恢复原状态</span></span><br><span class="line">            rows[r][i] = cols[c][i] = blocks[r / <span class="number">3</span>][c / <span class="number">3</span>][i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数字1-9都不能填，说明前面某次填写有问题，因此回溯</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用位运算进行状态压缩"><a href="#使用位运算进行状态压缩" class="headerlink" title="使用位运算进行状态压缩"></a>使用位运算进行状态压缩</h2><p>上面的解法中，使用了长度为 9 的数组来表示每个数字是否出现过，算法的空间复杂度并不优秀。为了减少空间复杂度，我们可以使用一个整数来表示每个数字是否出现过。</p><p>具体地，数 $b$ 的二进制表示的第 $i$ 位（从低到高，最低位为第 $0$ 位）为 $1$，当且仅当数字 $i+1$ 出现过。例如当 $b$ 的二进制为 $(011000100)_2$ 时，就表示数字 $3, 7, 8$ 已经出现过了。</p><p>在本题中会用到下面几种位运算的技巧：</p><ul><li><p><strong>将数字 $digit$ 的第 $i$ 位设为1，并且能够再将第 $i$ 位恢复为0</strong>：</p><p>  使用 <code>digit ^ (1&lt;&lt; i)</code>。若原来是0，则第一次会将第 $i$ 位设为 1，第二次会将第 $i$ 位设为 0。</p></li><li><p><strong>计算第 $(i, j)$ 个空白格子可以填写哪些数字</strong></p><p>  首先计算  <code>rows[i] | cols[j] | blocks[i / 3][j / 3]</code> 得到当前已经填写过的所有数字。然后对这个值<strong>按位取反</strong>，取反后第 $k$ 位为1就表示该位置可以填入数字 $k+1$，因此我们可以通过寻找 1 来进行枚举。但由于按位取反后，这个数的高位（第10-31位）也全都变成了 1，而这些位置是我们不应该枚举到的。为了排除这些位置，我们可以将按位取反后的值与 $(111111111)<em>2 = (1FF)</em>{16}$ 进行<strong>按位与</strong>运算，将所有无关的位置设为 0。</p><p>  可以使用 <code>mask &amp;= (mask - 1)</code> 来枚举二进制中的所有 1。</p><p>  可以使用 $b \ \&amp; \ (-b) $ 或 $b \ \&amp; \ (\sim b + 1) $  得到 $b$ 二进制表示中最低位的 1。 例如 <code>(010100) &amp; (101100) = 000100</code>。</p><p>  当我们得到这个最低位的 1 时，我们可以通过一些语言自带的函数得到这个最低位的 1究竟是第几位，例如 <code>Integer.bitCount(digit - 1)</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] rows, cols;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] blocks;</span><br><span class="line"><span class="keyword">private</span> List&lt;<span class="keyword">int</span>[]&gt; spaces;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">    rows = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>];</span><br><span class="line">    cols = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>];</span><br><span class="line">    blocks = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    spaces = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">'.'</span>) &#123;</span><br><span class="line">            spaces.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i, j&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> digit = board[i][j] - <span class="string">'0'</span> - <span class="number">1</span>;</span><br><span class="line">            flip(i, j, digit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(board, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos == spaces.size()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = spaces.get(pos)[<span class="number">0</span>], j = spaces.get(pos)[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 若mask的第i位为1，则说明可以填写数字i+1</span></span><br><span class="line">    <span class="keyword">int</span> mask = ~(rows[i] | cols[j] | blocks[i / <span class="number">3</span>][j / <span class="number">3</span>]) &amp; <span class="number">0x1ff</span>;</span><br><span class="line">    <span class="keyword">for</span> (; mask != <span class="number">0</span>; mask &amp;= (mask - <span class="number">1</span>)) &#123; <span class="comment">// 枚举所有的1，并不断消除最低位的1</span></span><br><span class="line">        <span class="comment">// 找到当前最低位的1</span></span><br><span class="line">        <span class="keyword">int</span> digitMask = mask &amp; -mask;</span><br><span class="line">        <span class="comment">// 当前这个最低位的1是第几位</span></span><br><span class="line">        <span class="keyword">int</span> digit = Integer.bitCount(digitMask - <span class="number">1</span>);</span><br><span class="line">        flip(i, j, digit);</span><br><span class="line">        board[i][j] = (<span class="keyword">char</span>) (digit + <span class="string">'0'</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (dfs(board, pos + <span class="number">1</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        flip(i, j, digit);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flip</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> digit)</span> </span>&#123;</span><br><span class="line">    rows[i] ^= (<span class="number">1</span> &lt;&lt; digit);</span><br><span class="line">    cols[j] ^= (<span class="number">1</span> &lt;&lt; digit);</span><br><span class="line">    blocks[i / <span class="number">3</span>][j / <span class="number">3</span>] ^= (<span class="number">1</span> &lt;&lt; digit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="预填确定值"><a href="#预填确定值" class="headerlink" title="预填确定值"></a>预填确定值</h2><p>在数独中，如果一个空白格子只有唯一的数可以填入，即其对应的 <code>mask &amp;= (mask - 1) = 0</code>。此时，我们可以直接在这个空白格中填入这个数，不用等到后续的递归遍历，这样可以进一步减少递归的层数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] rows, cols;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] blocks;</span><br><span class="line"><span class="keyword">private</span> List&lt;<span class="keyword">int</span>[]&gt; spaces;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">    rows = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>];</span><br><span class="line">    cols = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>];</span><br><span class="line">    blocks = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    spaces = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] != <span class="string">'.'</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> digit = board[i][j] - <span class="string">'0'</span> - <span class="number">1</span>;</span><br><span class="line">            flip(i, j, digit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">'.'</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> mask = ~(rows[i] | cols[j] | blocks[i / <span class="number">3</span>][j / <span class="number">3</span>]) &amp; <span class="number">0x1ff</span>;</span><br><span class="line">                <span class="comment">// mask &amp; (mask - 1) 这个式子可以消除mask最低位的1</span></span><br><span class="line">                <span class="comment">// 若消除后变为0，则说明mask中只有一个1</span></span><br><span class="line">                <span class="keyword">if</span> ((mask &amp; (mask - <span class="number">1</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> digit = Integer.bitCount(mask - <span class="number">1</span>);</span><br><span class="line">                    flip(i, j, digit);</span><br><span class="line">                    board[i][j] = (<span class="keyword">char</span>) (digit + <span class="string">'0'</span> + <span class="number">1</span>);</span><br><span class="line">                    modified = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!modified) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">'.'</span>) &#123;</span><br><span class="line">            spaces.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i, j&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(board, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flip</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> digit)</span> </span>&#123;</span><br><span class="line">    rows[i] ^= (<span class="number">1</span> &lt;&lt; digit);</span><br><span class="line">    cols[j] ^= (<span class="number">1</span> &lt;&lt; digit);</span><br><span class="line">    blocks[i / <span class="number">3</span>][j / <span class="number">3</span>] ^= (<span class="number">1</span> &lt;&lt; digit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos == spaces.size()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = spaces.get(pos)[<span class="number">0</span>], j = spaces.get(pos)[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> mask = ~(rows[i] | cols[j] | blocks[i / <span class="number">3</span>][j / <span class="number">3</span>]) &amp; <span class="number">0x1ff</span>;</span><br><span class="line">    <span class="keyword">for</span> (; mask != <span class="number">0</span>; mask &amp;= (mask - <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">int</span> digitMask = mask &amp; -mask;</span><br><span class="line">        <span class="keyword">int</span> digit = Integer.bitCount(digitMask - <span class="number">1</span>);</span><br><span class="line">        flip(i, j, digit);</span><br><span class="line">        board[i][j] = (<span class="keyword">char</span>) (digit + <span class="string">'0'</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (dfs(board, pos + <span class="number">1</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        flip(i, j, digit);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;编写一个程序，通过填充空格来解决数独问题。&lt;/p&gt;
&lt;p&gt;一个数独的解法需&lt;strong&gt;遵循如下规则&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
      
    
    </summary>
    
      <category term="刷题" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
      <category term="LeetCode" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/LeetCode/"/>
    
    
      <category term="回溯" scheme="965087276.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
      <category term="位运算" scheme="965087276.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机学习</title>
    <link href="965087276.github.io/2020/10/22/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0/"/>
    <id>965087276.github.io/2020/10/22/Java虚拟机学习/</id>
    <published>2020-10-22T04:25:37.000Z</published>
    <updated>2020-10-22T12:49:01.535Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h1><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>Java 虚拟机所管理的内存主要包括以下五个运行时区域：</p><ul><li>程序计数器（Program Counter Register）</li><li>虚拟机栈（VM Stack）</li><li>本地方法栈（Native Method Stack）</li><li>方法区（Method Area）</li><li>堆（Heap）</li></ul><p>其中，每个线程都会有自己的 <code>程序计数器</code>、<code>虚拟机栈</code> 和 <code>本地方法栈</code>。<code>堆</code> 和 <code>方法区</code> 由所有线程共享。</p><p><img src="1.png" alt=""></p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器可以看作是当前线程所执行的字节码的行号指示器。<strong>每个线程都有自己的程序计数器</strong>，以便线程切换后相应线程能恢复到正确的执行位置。</p><p>如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地 (Native) 方法，这个计数器值则应为空。</p><p>程序计数器是<strong>唯一一个</strong>没有规定任何 OutOfMemoryError 情况的区域。</p><h3 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h3><p>Java 虚拟机栈描述的是 Java 方法执行的线程内存模型。每个方法执行的时候，Java 虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><p>局部变量表存放了编译器可知的各种 Java 虚拟机基本数据类型（ boolean, byte, char, short, int, float, long, double）、对象引用（reference 类型）和 returnAddress 类型（指向了一条字节码指令的地址）。</p><p>这些数据类型再局部变量表中的存储空间以局部变量槽（Slot）来表示，其中64位的long 和 double 类型的数据会占用两个变量槽，其余数据类型占用一个变量槽。<strong>局部变量表所需的内存空间在编译期间完成分配</strong>。在方法运行期间不会改变局部变量表的大小（这里的 “大小” 是指变量槽的数量）。</p><p>Java 虚拟机栈会有两类异常状况：</p><ul><li>如果线程请求的栈深度大于虚拟机所允许的深度，将会抛出 StackOverflowError 异常</li><li>如果线程申请栈空间 或 栈扩展（要注意HotSpot虚拟机的栈容量不可以动态扩展）失败时，会抛出 OutOfMemoryError 异常。</li></ul><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈 与 Java虚拟机栈所发挥的作用很相似，区别是虚拟机栈为虚拟机执行 Java 方法服务，而本地方法栈为虚拟机用到的本地（Native）方法服务。</p><h3 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h3><p>Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><h2 id="Java对象的分配、布局和访问"><a href="#Java对象的分配、布局和访问" class="headerlink" title="Java对象的分配、布局和访问"></a>Java对象的分配、布局和访问</h2><p>sdf</p><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java内存区域&quot;&gt;&lt;a href=&quot;#Java内存区域&quot; class=&quot;headerlink&quot; title=&quot;Java内存区域&quot;&gt;&lt;/a&gt;Java内存区域&lt;/h1&gt;&lt;h2 id=&quot;运行时数据区域&quot;&gt;&lt;a href=&quot;#运行时数据区域&quot; class=&quot;header
      
    
    </summary>
    
      <category term="面试" scheme="965087276.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="java" scheme="965087276.github.io/categories/%E9%9D%A2%E8%AF%95/java/"/>
    
    
      <category term="面试" scheme="965087276.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 802 找到最终的安全状态</title>
    <link href="965087276.github.io/2020/07/18/LeetCode-802-%E6%89%BE%E5%88%B0%E6%9C%80%E7%BB%88%E7%9A%84%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81/"/>
    <id>965087276.github.io/2020/07/18/LeetCode-802-找到最终的安全状态/</id>
    <published>2020-07-18T11:11:45.000Z</published>
    <updated>2020-07-18T13:01:36.788Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>在有向图中, 我们从某个节点和每个转向处开始, 沿着图的有向边走。 如果我们到达的节点是终点 (即它没有连出的有向边), 我们停止。现在, 如果我们最后能走到终点，那么我们的起始节点是<em>最终安全</em>的。 更具体地说, 存在一个自然数 <code>K</code>, 无论选择从哪里开始行走, 我们走了不到 <code>K</code> 步后必能停止在一个终点。</p><p>哪些节点最终是安全的？ 结果返回一个有序的数组。</p><p>该有向图有 <code>N</code> 个节点，标签为 <code>0, 1, ..., N-1</code>, 其中 <code>N</code> 是 <code>graph</code> 的节点数. 图以以下的形式给出: <code>graph[i]</code>是节点 <code>j</code> 的一个列表，满足 <code>(i, j)</code> 是图的一条有向边。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">输入：graph &#x3D; [[1,2],[2,3],[5],[0],[5],[],[]]</span><br><span class="line">输出：[2,4,5,6]</span><br></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这道题的意思是判断有向图中的每个节点能否走到<strong>环</strong>中，输出所有不能走到<strong>环</strong>中的点。</p><h2 id="解法一：拓扑排序"><a href="#解法一：拓扑排序" class="headerlink" title="解法一：拓扑排序"></a>解法一：拓扑排序</h2><p>我们可以首先考虑所有出度为0的节点，它们一定都是安全的节点。 其次，仅与这些点直接相连的节点也一定都是安全的。依次类推，仅与这些安全的节点相连的节点也一定都是安全的。</p><p>那么，我们可以将所有的边全部反向。反向之后，所有入度为0的点都是安全的，我们把这些点以及与这些点相连的边全部删除，随后新的图中所有入度为0的点也都是安全的。以此类推即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; eventualSafeNodes(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = graph.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> *degree = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">bool</span> *<span class="built_in">end</span> = <span class="keyword">new</span> <span class="keyword">bool</span>[n];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) degree[i] = <span class="built_in">end</span>[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">for</span> (<span class="keyword">int</span> v : graph[i]) &#123;</span><br><span class="line">        G[v].push_back(i);</span><br><span class="line">        ++degree[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span> (!degree[i])</span><br><span class="line">        q.push(i);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">        <span class="built_in">end</span>[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : G[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--degree[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span> (<span class="built_in">end</span>[i])</span><br><span class="line">        res.push_back(i);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解法二：DFS"><a href="#解法二：DFS" class="headerlink" title="解法二：DFS"></a>解法二：DFS</h2><p>还可以用深度优先搜索的方法来判断每个节点是否能够走到环中。在遍历的过程中，对于每个节点 u，我们设置三个状态：</p><ul><li><code>vis[u] = 0</code>：该节点还未被访问</li><li><code>vis[u] = 1</code>：该节点在这一轮遍历中已经被访问过或者该节点在环中</li><li><code>vis[u] = 2</code>：该节点遍历完毕且该节点是安全节点（不能走到环中）</li></ul><p>当我们第一次访问一个节点 u 时，我们将其设置为 vis = 1，并继续搜索与该节点相连的节点。如果在搜索过程中我们遇到一个 vis = 1 的节点，那么说明找到了一个环，那么在本轮搜索中 u 以及与 u 连通的点都可以到达这个环，因此这些点都不是安全的节点，此时退出本轮搜索，保持这些点 vis = 1 的状态不变。如果搜索过程中，没有遇到 vis = 1 的节点，则说明它是一个安全的节点，此时将其设置为 vis = 2。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dfs返回true表示节点u是一个安全的节点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="keyword">int</span> *vis, <span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[u]) <span class="keyword">return</span> vis[u] == <span class="number">2</span>;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : graph[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[v] == <span class="number">1</span> || !dfs(graph, vis, v)) &#123;</span><br><span class="line">            vis[u] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 已遍历过且为安全的节点, vis=2</span></span><br><span class="line">    vis[u] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; eventualSafeNodes(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph) &#123;</span><br><span class="line">    <span class="keyword">int</span> *vis = <span class="keyword">new</span> <span class="keyword">int</span>[graph.<span class="built_in">size</span>()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.<span class="built_in">size</span>(); i++) vis[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dfs(graph, vis, i)) &#123;</span><br><span class="line">            res.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;在有向图中, 我们从某个节点和每个转向处开始, 沿着图的有向边走。 如果我们到达的节点是终点 (即它没有连出的有向边), 我们停止。现在, 
      
    
    </summary>
    
      <category term="刷题" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
      <category term="LeetCode" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/LeetCode/"/>
    
    
      <category term="拓扑排序" scheme="965087276.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
      <category term="图论" scheme="965087276.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>CMU 15-213 实验1: Data Lab</title>
    <link href="965087276.github.io/2020/05/31/CMU-15-213-%E5%AE%9E%E9%AA%8C1-Data-Lab/"/>
    <id>965087276.github.io/2020/05/31/CMU-15-213-实验1-Data-Lab/</id>
    <published>2020-05-31T01:29:59.000Z</published>
    <updated>2020-06-02T05:33:01.393Z</updated>
    
    <content type="html"><![CDATA[<p>Data Lab 都是与位运算相关的一些题目，总共有13个题。每个题都是按要求实现一个函数，题目中规定了可以使用的操作符（不能使用规定之外的操作），并对使用次数作出了限制，要求就是用这些给定的操作符，在一定次数内，完成函数所要实现的功能。</p><h1 id="整数部分"><a href="#整数部分" class="headerlink" title="整数部分"></a>整数部分</h1><p>整数部分的题目限制比较多：不允许使用条件与循环，不能使用大于8 bit 的常数，也不能使用数组、结构体等结构。</p><h2 id="1-bitXor"><a href="#1-bitXor" class="headerlink" title="1. bitXor"></a>1. bitXor</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * bitXor - x^y using only ~ and &amp; </span></span><br><span class="line"><span class="comment"> *   Example: bitXor(4, 5) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp;</span></span><br><span class="line"><span class="comment"> *   Max ops: 14</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitXor</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// exclude x’s bit is 1 and y's bit is 1</span></span><br><span class="line">    <span class="keyword">int</span> allOne = ~(x &amp; y);</span><br><span class="line">    <span class="comment">// exclude x’s bit is 0 and y's bit is 0</span></span><br><span class="line">    <span class="keyword">int</span> allZero = ~(~x &amp; ~y);</span><br><span class="line">    <span class="comment">// neither (x’s bit is 1 and y's bit is 1) nor (x’s bit is 0 and y's bit is 0)</span></span><br><span class="line">    <span class="keyword">return</span> allOne &amp; allZero;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一题要用 <code>~</code> 和 <code>&amp;</code> 两个符号实现两个数的 <code>异或</code> 操作。</p><p><strong>思路：</strong> 通过逆向法，使用一个各个 bit 均为 1 的数 $ans = (2^{31}-1)$，找出 <code>x, y</code> 相应位置均为 1 的 bit 和 <code>x, y</code> 相应位置均为 0 的 bit，在 <code>ans</code> 中这些 bit 设为 0，剩余的结果即为 <code>x ^ y</code>。</p><p>上面代码中，<code>allOne = ~(x &amp; y)</code> 相当于 $(2^{31} - 1)$ 排除掉 <code>x, y</code> 相应位置均为 1 的 bit 后的结果；<code>allZero = ~(~x &amp; ~y)</code> 是将 <code>x, y</code> 相应位置均为 0 的 bit 设置为 0 ，其它位置设为 1；<code>allOne</code> 再通过与 <code>allZero</code> 按位 and 后便将 <code>x, y</code> 均为 0 的 bit 排除掉了，剩下的便是 <code>x ^ y</code> 。</p><h2 id="2-tmin"><a href="#2-tmin" class="headerlink" title="2. tmin"></a>2. tmin</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * tmin - return minimum two's complement integer: 0x80000000</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tmin</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回二进制补码表示中最小的数。</p><p>最小的数就是 符号位为1，其余位为0，也就是 $INT_MIN = -2^{31}$。</p><h2 id="3-isTmax"><a href="#3-isTmax" class="headerlink" title="3. isTmax"></a>3. isTmax</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isTmax - returns 1 if x is the maximum, two's complement number,</span></span><br><span class="line"><span class="comment"> *     and 0 otherwise </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | +</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isTmax</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断x是否为 ~(1&lt;&lt;31)</span></span><br><span class="line">    <span class="comment">// !!(~x)排除~x为0的情况;</span></span><br><span class="line">    <span class="comment">// 若~x=(1&lt;&lt;31), 则 ~x + ~x = 0</span></span><br><span class="line">    <span class="keyword">return</span> !!(~x) &amp; !(~x + ~x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断一个数是否为二进制补码表示中最大的数。</p><p>最大的数就是 符号位为0，其余为均为1，也就是 <code>INT_MAX = ~(1&lt;&lt;31)</code> 。</p><h2 id="4-allOddBits"><a href="#4-allOddBits" class="headerlink" title="4. allOddBits"></a>4. allOddBits</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span></span><br><span class="line"><span class="comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">allOddBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> slice = <span class="number">0xAA</span>;</span><br><span class="line">    <span class="keyword">int</span> oddBits = (slice &lt;&lt; <span class="number">24</span>) | (slice &lt;&lt; <span class="number">16</span>) | (slice &lt;&lt; <span class="number">8</span>) | slice;</span><br><span class="line">    <span class="keyword">return</span> !((x &amp; oddBits) ^ (oddBits));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断一个数的二进制的奇数位是否均为1。</p><p><strong>思路：</strong>构造一个奇数位均为1，偶数位均为0的二进制数：<code>0xAAAAAAAA</code> 。将该数与 x 按位 and，若得到结果为 <code>0xAAAAAAAA</code> ，则该数的奇数二进制位均为1.</p><p>因为最终要返回 0 或 1，所以再将结果与 <code>0xAAAAAAAA</code> 异或并使用 <code>!</code> 取否，将结果变为 0 或 1。</p><h2 id="5-negate"><a href="#5-negate" class="headerlink" title="5.  negate"></a>5.  negate</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * negate - return -x </span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">negate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ~x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求 -x。</p><p>将 x 按位取反，末位 +1 即可。</p><h2 id="6-isAsciiDigit"><a href="#6-isAsciiDigit" class="headerlink" title="6. isAsciiDigit"></a>6. isAsciiDigit</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters '0' to '9')</span></span><br><span class="line"><span class="comment"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isAsciiDigit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = x + ~<span class="number">47</span> + <span class="number">1</span>; <span class="comment">// x - 47</span></span><br><span class="line">    <span class="keyword">int</span> right = x + ~<span class="number">58</span> + <span class="number">1</span>; <span class="comment">// x - 58</span></span><br><span class="line">    <span class="keyword">return</span> !!left &amp; !(left &gt;&gt; <span class="number">31</span>) &amp; (right &gt;&gt; <span class="number">31</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断 x 是否是 ASCII 中的数字字符。</p><p><strong>思路：</strong>ASCII 数字字符的范围是 $48 \leq x \leq 57$ ，因此只需要判断 $x$ 是否在该范围即可。</p><p>将上面的左右区间各扩大 1 ，得到 $x$ 的范围为 $47 &lt; x &lt; 58$ 。若 $x$ 是一个数字字符，那么 $x - 47 &gt; 0$ 且 $x - 58 &lt; 0$ 。</p><p>分别计算出 $x - 47$ 的结果 <code>left</code> 和 $x - 58$ 的结果 <code>right</code> 。<code>left</code> 的符号位需要为0 并且 <code>left</code> 本身不能为 0，<code>right</code> 的符号位需要为 1。</p><h2 id="7-conditional"><a href="#7-conditional" class="headerlink" title="7. conditional"></a>7. conditional</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * conditional - same as x ? y : z </span></span><br><span class="line"><span class="comment"> *   Example: conditional(2,4,5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 16</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">conditional</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    x = !!x;</span><br><span class="line">    x = ~x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (x &amp; y) + (~x &amp; z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现三目运算符 <code>x ? y : z</code> 。<br><strong>思路：</strong>首先通过 <code>!!x</code> 将 <code>x</code> 变为 <code>0 或 1</code> ，然后通过 <code>~x + 1</code> 将 <code>x</code> 变为 <code>0x00000000 或 0xffffffff</code> 。当 <code>x = 0</code> 时，<code>~x + 1 = 0x00000000</code>；当 <code>x = 1</code> 时，<code>~x + 1 = 0xffffffff</code> 。</p><p><code>(x &amp; y) + (~x &amp; z)</code> 根据 <code>x</code> 的不同会等于 <code>y</code> 或 <code>z</code> 。</p><h2 id="8-isLessOrEqual"><a href="#8-isLessOrEqual" class="headerlink" title="8.  isLessOrEqual"></a>8.  isLessOrEqual</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// x &lt; 0 and y &gt;= 0</span></span><br><span class="line">    <span class="keyword">int</span> negateXandNorNegateY = (x &gt;&gt; <span class="number">31</span>) &amp; !(y &gt;&gt; <span class="number">31</span>);</span><br><span class="line">    <span class="comment">// x &gt;= 0 and y &lt; 0</span></span><br><span class="line">    <span class="keyword">int</span> norNegateXandNegateY = !(x &gt;&gt; <span class="number">31</span>) &amp; (y &gt;&gt; <span class="number">31</span>);</span><br><span class="line">    <span class="comment">// x - y</span></span><br><span class="line">    <span class="keyword">int</span> diff = x + ~y + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// x - y &lt;= 0</span></span><br><span class="line">    <span class="keyword">int</span> negateDiff = !diff | (diff &gt;&gt; <span class="number">31</span>);</span><br><span class="line">    <span class="keyword">return</span> negateXandNorNegateY | (!norNegateXandNegateY &amp; negateDiff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现 $\leq$ 运算符。</p><p><strong>思路：</strong> 这个题的关键是判断 $x - y$ 是否 $\leq $ 0 。基本思路是首先计算出 $x-y$ 的值，然后判断结果是否为 0 或者是否为负数（符号位为1）。</p><p>然而，这个题会出现运算溢出的情况，当 $x$ 与 $y$ 不同号时，二者相减可能会超出 <code>int</code> 的范围，因此需要特殊处理 $x$ 与 $y$ 不同号的情况。</p><h2 id="9-logicalNeg"><a href="#9-logicalNeg" class="headerlink" title="9. logicalNeg"></a>9. logicalNeg</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalNeg - implement the ! operator, using all of </span></span><br><span class="line"><span class="comment"> *              the legal operators except !</span></span><br><span class="line"><span class="comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">logicalNeg</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    x = x | x &gt;&gt; <span class="number">16</span>;</span><br><span class="line">    x = x | x &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    x = x | x &gt;&gt; <span class="number">4</span>;</span><br><span class="line">    x = x | x &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    x = x | x &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ~x &amp; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现 <code>!</code> 运算符。</p><p><strong>思路：</strong> 这个题的关键时判断 <code>x</code> 的二进制表示中是否含有 1 。这个解法是从网上看到的一个，比较巧妙。他用了类似分治的方法，将前16位的1放到后16位中，再将后16位中前8位的1放到后8位中，再将后8位中前4位的1放到后4位中，以此类推。若 <code>x</code> 的二进制表示中含有1，经过这一系列变化后，<code>x</code> 的二进制最后一位一定为 1 .</p><h2 id="10-howManyBits"><a href="#10-howManyBits" class="headerlink" title="10. howManyBits"></a>10. howManyBits</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* howManyBits - return the minimum number of bits required to represent x in</span></span><br><span class="line"><span class="comment"> *             two's complement</span></span><br><span class="line"><span class="comment"> *  Examples: howManyBits(12) = 5</span></span><br><span class="line"><span class="comment"> *            howManyBits(298) = 10</span></span><br><span class="line"><span class="comment"> *            howManyBits(-5) = 4</span></span><br><span class="line"><span class="comment"> *            howManyBits(0)  = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(-1) = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(0x80000000) = 32</span></span><br><span class="line"><span class="comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *  Max ops: 90</span></span><br><span class="line"><span class="comment"> *  Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">howManyBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sign, b16, b8, b4, b2, b1, b0;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sign = 0x00000000 或 0xffffffff</span></span><br><span class="line">    sign = x &gt;&gt; <span class="number">31</span>;</span><br><span class="line">    <span class="comment">// 若x非负，保持不变；否则将x按位取反</span></span><br><span class="line">    x = (sign &amp; ~x) | (~sign &amp; x);</span><br><span class="line"></span><br><span class="line">    b16 = !!(x &gt;&gt; <span class="number">16</span>) &lt;&lt; <span class="number">4</span>; <span class="comment">// 高16位是否有1</span></span><br><span class="line">    x &gt;&gt;= b16; <span class="comment">//如果有（至少需要16位），则将原数右移16位</span></span><br><span class="line">    b8 = !!(x &gt;&gt; <span class="number">8</span>) &lt;&lt; <span class="number">3</span>; <span class="comment">//剩余位高8位是否有1</span></span><br><span class="line">    x &gt;&gt;= b8; <span class="comment">// 如果还有（至少需要16+8=24位），则右移8位</span></span><br><span class="line">    b4 = !!(x &gt;&gt; <span class="number">4</span>) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">    x &gt;&gt;= b4;</span><br><span class="line">    b2 = !!(x &gt;&gt; <span class="number">2</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    x &gt;&gt;= b2;</span><br><span class="line">    b1 = !!(x &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    x &gt;&gt;= b1;</span><br><span class="line">    b0 = x;</span><br><span class="line">    <span class="keyword">return</span> b16 + b8 + b4 + b2 + b1 + b0 + <span class="number">1</span>; <span class="comment">// 最后的+1表示符号位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将一个数用补码表示最少需要几个bit？</p><p>例如 <script type="math/tex">12_{10} = 01100_2; \ -5_{10} = 1011_2; \ 0_{10} = 0_2; \ -1_{10} = 1_2</script> . <strong>最高一位为符号位</strong></p><p><strong>思路：</strong> 对于一个正数，我们需要找到它最高的一位是1的，再加上符号位即可；对于一个负数，我们则需要找到它最高一位是0的（例如 5 位的 11101 和 4 位的 1101 以及 3 位的 101 表示的都是同一个值 -3，因此最高位连续的 1 是没有意义的），再加上符号位即可。因此，我们首先做一下统一，将负数都按位取反，这样统一都去找最高位是1的，再加上最后的符号位即为最终的答案。</p><p>如何找到最高位是1的那个位置呢？我们可以采用分治（divide and conquer）的方法。</p><ul><li><p>首先将这个 32 位的数 x 分成两半：高16位，低16位。先判断高16位中是否有1。</p><ul><li>若高16位有1，则说明最终答案肯定大于16，答案就等于 16 加上（x的高16位）这个数中最高位1的位置；</li><li>若高16位中没有1，则说明最终答案肯定不超过16，答案就等于（x的低16位） 这个数中最高位1的位置；</li></ul><p>怎么判断判断高16位中是否有1呢？只需将 x 右移16位，判断剩下的数是否为0即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !!(x &gt;&gt; <span class="number">16</span>) ) &#123;</span><br><span class="line">     <span class="comment">// 高16位有1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// 高16位没有1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接下来根据上一步的结果继续对 x的高16位 或 x的低16位 重复相同的步骤：将这个 16 位的数 y 分成两半：高8位，低8位。</p><p>先判断高8位中是否有1，其它的步骤与上一步类似。</p></li><li><p>一直这么分下去即可。</p></li></ul><h1 id="浮点数部分"><a href="#浮点数部分" class="headerlink" title="浮点数部分"></a>浮点数部分</h1><p>首先复习下浮点数的相关概念。</p><p>在计算机中，浮点数以 “阶码—尾数” 的方式进行表示，一个浮点数可以写成如下形式</p><script type="math/tex; mode=display">(-1)^s \ M \ 2^E</script><p>其中，$s$ 是一个符号位，标识了浮点数的正负，其取值为 $0$ 或 $1$，当 $s = 0$ 时，浮点数为正数，当 $s = 1$ 时，浮点数为负数。</p><p>$M$ 为尾数，其取值范围为 $[1.0, 2.0)$ ，$E$ 为阶码，这两个参数可以类比十进制中的科学计数法表示。例如，对于二进制数 $x = 1001$，将其表示成上述方式后为 $x = (-1)^0 \ast 1.001 \ast 2^3$。</p><p>C语言的浮点数类型有两种：32位的 <code>float</code> 和 64位的 <code>double</code>，这些 bit 存储了上面的符号位 $s$、阶码 $E$ 和 尾数 $M$，<code>double</code> 能够表示的浮点数的范围和精度都要比 <code>float</code> 大。</p><p><code>float</code> 是单精度浮点数，如下图所示，在它的 32 位中，最高 1 位是符号位，后 8 位是阶码位 ，最后 23 位是尾数位。</p><p><img src="float.png" alt=""></p><p><code>double</code> 是双精度浮点数，如下图所示，在它的 64 位中，最高 1 位是符号位，后 11 位是阶码位，最后 52 位是尾数位。</p><p><img src="double.png" alt=""></p><p>对于阶码 $E$ 和尾数 $M$ ，<code>float</code> 和 <code>double</code> 在存储时会将其进行一定编码后存储，如上图中的 exp 和 frac 存储的就是经过编码后的阶码和尾数。例如，对于阶码 $E$，在编码时会将其加上一个偏差 bias，也就是说， <code>exp = E + bias</code>；</p><p>而根据 <code>exp</code> 取值的不同，可将浮点数分类 <code>规格化(Normalized)浮点数</code> 和 <code>非规格化(Denormalized)浮点数</code> 两大类。</p><p>当 <code>exp != 000...0</code> 并且 <code>exp != 111...1</code> 时，浮点数为<strong>规格化浮点数</strong>。</p><ul><li><p>规格化浮点数中，阶码 $E$ 的偏差 bias 等于 $2^{k-1} - 1$ ，其中 $k$ 为 阶码位的位数。对于 <code>float</code> 来说，$k = 8$， $bias = 2^{8-1}-1 = 127$；对于 <code>double</code> 来说，$k = 11$，$bias = 2^{11-1}-1=1023$。</p></li><li><p>尾数 $M$ 为 $1.xxx…x_2$，因为规格化浮点数的尾数都是一点几，所以在存储时，会舍弃掉最前面那个大家都有的 $1$，不足 23 位的要添加后导零补齐23位。也就是说，frac 中存储的是 $xxx…x_2$，并添加后导零补齐23位。</p></li><li><p>举个栗子，我们看一下十进制数 15213 存储在 float 中是什么样的。</p><ul><li>首先将其写成阶码-尾数的方式<script type="math/tex; mode=display">\begin{aligned}15213_{10} &= 11101101101101_2 \\&= (-1)^0 \times 1.1101101101101_2 \times 2^{13} \\\end{aligned}</script></li></ul></li><li><p>$M = 1.1101101101101$，去掉最前面的 1，将剩余的数添加后导零补齐23位，得到 frac 的值</p><script type="math/tex; mode=display">  frac = 11011011011010000000000_2</script></li><li><p>$E = 13$，添加 bias = 127 后，得到 exp 的值：$exp = 17 + 127 = 140 = 1001100_2$</p></li><li><p>最终得到32位的 float 如下图所示</p><p><img src="eg-normalized.png" alt=""></p></li><li><p>由于规格化浮点数中 $1 \leq M &lt; 2$，所以其无法表示 $0$ </p></li></ul><p>当 <code>exp = 000...0</code> 时，这是非规格化浮点数的一种，这时用来表示特别小的数。</p><ul><li>阶码 $E = 1 - bias$ 而不是 $0 - bias$</li><li>尾数 $M = 0.000…0_2$，没有前面的 1 了。</li><li>这种情况可以表示 0 了，当 <code>exp = 000...0</code> 且 <code>frac = 000...0</code> 时，浮点数为 0。但是，这时根据 符号位$s$ 的不同会出现 $+0$ 和 $-0$ 两种情况。</li></ul><p>当 <code>exp = 111...1</code> 时，这是非规格化浮点数的另一种，这时用来表示无穷大或NaN。</p><ul><li>当 <code>frac = 000...0</code> 时，表示 $\infty$ 。例如，$1.0 / 0.0 = -1.0 / 0.0 = +\infty, 1.0 / -0.0 = -\infty$    </li><li>当 <code>frac != 000...0</code> 时，表示 NaN（Not-a-Number）。例如，$\sqrt{-1} = NaN$ </li></ul><hr><p>浮点数相关的三个题目要求就比较松了，可以使用条件判断和循环，可以使用任何符号，定义任意大小的常数，但是不可以使用 <code>float</code> 和 <code>double</code> 。</p><h2 id="1-float-twice"><a href="#1-float-twice" class="headerlink" title="1.  float_twice"></a>1.  float_twice</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * float_twice - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int's, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_twice</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="built_in">exp</span> = (uf &gt;&gt; <span class="number">23</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">int</span> frac = uf &amp; <span class="number">0x7fffff</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0xff</span>) &#123; <span class="comment">// The ans is NaN</span></span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 直接将 uf * 2 再保留符号位即可</span></span><br><span class="line">        uf =  (<span class="number">0x80000000</span> &amp; uf) | (uf &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 阶码加1</span></span><br><span class="line">        uf += <span class="number">1</span> &lt;&lt; <span class="number">23</span>;</span><br><span class="line">        <span class="comment">// 若阶码加1后变为0xff, 则令结果为无穷大（否则就变成NaN了，这个结果显然不是NaN）</span></span><br><span class="line">        <span class="keyword">if</span> (((uf &gt;&gt; <span class="number">23</span>) &amp; <span class="number">0xff</span>) == <span class="number">0xff</span>) &#123;</span><br><span class="line">            uf &amp;= <span class="number">0xff800000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算 2 乘以 一个浮点数。浮点数为 float，以 32 位 unsigned 的形式给出。</p><p><strong>思路：</strong> 这个题主要考察浮点数的基本表示方法。首先排除无穷大、NaN 的情况，这两种情况直接返回原参数即可。对于 exp = 0 的情况，直接将原参数乘以2并保留符号位即可。对于规格化浮点数的情况，乘以2 相当于 阶码加1，由于阶码在第23位，因此其加1就相当于 <code>uf + (1 &lt;&lt; 23)</code> 。若阶码加1后变为 <code>0xff</code>，此时的结果应为无穷大，而不是 NaN，因此需要将后23位的尾数位都设为0。</p><h2 id="2-float-i2f"><a href="#2-float-i2f" class="headerlink" title="2. float_i2f"></a>2. float_i2f</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * float_i2f - Return bit-level equivalent of expression (float) x</span></span><br><span class="line"><span class="comment"> *   Result is returned as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_i2f</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sign = x &amp; (<span class="number">1</span> &lt;&lt; <span class="number">31</span>);</span><br><span class="line">    <span class="keyword">int</span> E = <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">exp</span>, frac, add, mx, back, ans;</span><br><span class="line">    <span class="keyword">int</span> diff, var, p;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sign) &#123;</span><br><span class="line">            <span class="comment">// 把x变成非负数，因为浮点数的正负由前面的符号位s决定</span></span><br><span class="line">            x = -x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到最高位的1所在的位置</span></span><br><span class="line">        <span class="keyword">while</span> (!((p = (<span class="number">1</span>&lt;&lt;E)) &amp; x)) &#123;</span><br><span class="line">            E--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exp</span> = E + <span class="number">127</span>;</span><br><span class="line">        <span class="comment">// 获取尾数(1.xxxxx 即获取小数点后面的xxxxx )</span></span><br><span class="line">        frac = x &amp; (p - <span class="number">1</span>);</span><br><span class="line">        diff = E - <span class="number">23</span>;</span><br><span class="line">        <span class="keyword">if</span> (E &lt; <span class="number">23</span>) &#123;</span><br><span class="line">            <span class="comment">// 尾数不足23位，补齐23位</span></span><br><span class="line">            frac &lt;&lt;= <span class="number">23</span> - E;</span><br><span class="line">        &#125;</span><br><span class="line">        add = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (E &gt; <span class="number">23</span>) &#123; <span class="comment">// 尾数超过23位，向偶数舍入</span></span><br><span class="line">            <span class="comment">// 设尾数为 1.xxxx...xyyyy, y需要被舍入</span></span><br><span class="line">            <span class="comment">// 这里假设y共有四位</span></span><br><span class="line">            <span class="comment">// 如果 (yyyy大于1000) 或者 (yyyy=1000且最后一个x为1)，则需要加1摄入；其它情况直接截断即可</span></span><br><span class="line">            mx = <span class="number">1</span> &lt;&lt; diff;</span><br><span class="line">            var = mx &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            back = frac &amp; (mx - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (back &gt; var || (back == var &amp;&amp; (frac &amp; mx))) &#123;</span><br><span class="line">                add = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            frac &gt;&gt;= diff;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = (sign | (<span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>) | frac) + add;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将一个整数转换为单精度浮点数。</p><p><strong>思路：</strong> 这个题思路还是比较简单的，只是实现起来细节很多。</p><ol><li>要注意把 $x$ 变为非负数，因为 float 浮点数的正负是由最前面的1个符号位 s 决定的，所以后31位的阶码和尾数都是以非负数为前提的。</li><li>找到最高位 1 所在的位置，由此可以计算出阶码 exp 的值，这个 1 后面的数作为尾数的值。</li><li>第 2 步中计算出的尾数可能不足 23 位或者超出 23 位。对于不足 32 位的情况，需要添加后置 0 凑齐23位；对于超过 23 位的情况，需要进行向偶数舍入。</li></ol><h2 id="3-float-f2i"><a href="#3-float-f2i" class="headerlink" title="3. float_f2i"></a>3. float_f2i</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * float_f2i - Return bit-level equivalent of expression (int) f</span></span><br><span class="line"><span class="comment"> *   for floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Argument is passed as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point value.</span></span><br><span class="line"><span class="comment"> *   Anything out of range (including NaN and infinity) should return</span></span><br><span class="line"><span class="comment"> *   0x80000000u.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">float_f2i</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sign = uf &amp; (<span class="number">1</span> &lt;&lt; <span class="number">31</span>);</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">exp</span> = (uf &amp; <span class="number">0x7f800000</span>) &gt;&gt; <span class="number">23</span>;</span><br><span class="line">    <span class="keyword">int</span> frac = uf &amp; <span class="number">0x7fffff</span>;</span><br><span class="line">    <span class="keyword">int</span> bias = <span class="number">127</span>;</span><br><span class="line">    <span class="keyword">int</span> outOfRange = <span class="number">0x80000000</span>u;</span><br><span class="line">    <span class="keyword">int</span> ans, E;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0xff</span>) &#123;</span><br><span class="line">        ans = outOfRange;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        E = <span class="built_in">exp</span> - bias;</span><br><span class="line">        <span class="keyword">if</span> (E &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (E &gt; <span class="number">30</span>) &#123;</span><br><span class="line">            ans = outOfRange;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            frac += <span class="number">0x800000</span>;</span><br><span class="line">            <span class="keyword">if</span> (E &gt; <span class="number">23</span>) &#123;</span><br><span class="line">                frac &lt;&lt;= E - <span class="number">23</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                frac &gt;&gt;= <span class="number">23</span> - E;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sign) &#123;</span><br><span class="line">                frac = -frac;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = frac;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将一个单精度浮点数转换为整数（向下取整，截断小数位）。</p><p><strong>思路：</strong> 这个题不难，只需要提取出 符号位 $s$，阶码 $E$，尾数 $M$。根据 $ans = (-1)^s \ast M \ast 2^E$，排除掉越界的情况，对不越界的数截断小数点后面的位即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Data Lab 都是与位运算相关的一些题目，总共有13个题。每个题都是按要求实现一个函数，题目中规定了可以使用的操作符（不能使用规定之外的操作），并对使用次数作出了限制，要求就是用这些给定的操作符，在一定次数内，完成函数所要实现的功能。&lt;/p&gt;
&lt;h1 id=&quot;整数部分&quot;
      
    
    </summary>
    
      <category term="课程学习" scheme="965087276.github.io/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="CMU 15-213" scheme="965087276.github.io/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/CMU-15-213/"/>
    
    
      <category term="CMU 15-213" scheme="965087276.github.io/tags/CMU-15-213/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 560 和为K的子数组</title>
    <link href="965087276.github.io/2020/05/15/LeetCode-560-%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>965087276.github.io/2020/05/15/LeetCode-560-和为K的子数组/</id>
    <published>2020-05-15T01:27:31.000Z</published>
    <updated>2020-05-15T01:56:02.780Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个整数数组和一个整数 <strong>k，</strong>你需要找到该数组中和为 <strong>k</strong> 的连续的子数组的个数。</p><p><strong>示例 1 :</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入:nums &#x3D; [1,1,1], k &#x3D; 2</span><br><span class="line">输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。</span><br></pre></td></tr></table></figure><p><strong>说明 :</strong></p><ol><li>数组的长度为 [1, 20,000]。</li><li>数组中元素的范围是 [-1000, 1000] ，且整数 <strong>k</strong> 的范围是 [-1e7, 1e7]。</li></ol><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>直接二重循环的时间复杂度为 $O(n^2)$，肯定是不可取的。</p><p>这个题抽象一下就是寻找不同的元组对 $(i, j)$ 的个数，满足 $i \leq j$ 且 $nums[i] + \cdots + nums[j] = k$。</p><p>考虑前缀和的形式，令 $pre[i]$ 为 $nums$ 数组中前 $i$ 个 元素的和，则有</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> i == <span class="number">0</span> </span><br><span class="line">pre[i] = <span class="number">0</span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">pre[i] = pre[i<span class="number">-1</span>] + pre[i]</span><br></pre></td></tr></table></figure><p>我们要找满足 $i \leq j$ 且 $nums[i] + \cdots + nums[j] = k$ 的元组 $(i, j)$ 的数量 ，将 $pre$ 数组带入这个式子，可得</p><script type="math/tex; mode=display">pre[j] - pre[i-1] = k</script><p>移向得</p><script type="math/tex; mode=display">pre[i-1] = pre[j] - k</script><p>我们可以顺序遍历 $j$ ，考虑以 $j$ 结尾的和为 $k$ 的子数组的数量。根据上面的式子，对于每个 $j$ ，我们只需要寻找在 $j$ 前面有多少个前缀和为 $pre[j] - k$ 的 $pre[i]$ 即可。</p><p>我们建立哈希表 $mp$，以和为键，出现次数为对应的值，记录 $pre[i]$ 的出现次数，从左往右边更新 $mp$ 边计算答案（从左往右边更新边计算的时候已经保证了 $mp[pre[j]-k]$ 里记录的 $pre[i]$ 的下标范围是 $0 \leq i &lt; j$）</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">    mp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : nums) &#123;</span><br><span class="line">        pre += x;</span><br><span class="line">        <span class="keyword">if</span> (mp.<span class="built_in">find</span>(pre - k) != mp.<span class="built_in">end</span>()) count += mp[pre - k];</span><br><span class="line">        mp[pre]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定一个整数数组和一个整数 &lt;strong&gt;k，&lt;/strong&gt;你需要找到该数组中和为 &lt;strong&gt;k&lt;/strong&gt; 的连续的子数
      
    
    </summary>
    
      <category term="刷题" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
      <category term="LeetCode" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/LeetCode/"/>
    
    
      <category term="数组" scheme="965087276.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="哈希表" scheme="965087276.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer 链表中倒数第k个节点</title>
    <link href="965087276.github.io/2020/04/08/%E5%89%91%E6%8C%87Offer-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>965087276.github.io/2020/04/08/剑指Offer-链表中倒数第k个节点/</id>
    <published>2020-04-08T01:11:00.000Z</published>
    <updated>2020-05-15T01:32:59.667Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k &#x3D; 2.</span><br><span class="line"></span><br><span class="line">返回链表 4-&gt;5.</span><br></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这个题最容易想到的思路是先将链表遍历一遍，计算出链表的长度 $n$ ，然后再遍历链表找到第 $n - k + 1$ 个元素。这种方法需要遍历链表两次，在时间上有些劣势。</p><p>其实我们可以只遍历链表一次就可以完成。算法流程如下</p><ol><li>设置两个指针：fast 和 slow。</li><li>fast 指针先向前走 $k$ 步（结束之后，fast 指针和 slow 指针间相差 $k$ 步）</li><li>两个指针共同移动（都向前走 1 步，如此循环），当 fast 指针走过链表尾节点后跳出循环</li><li>此时 slow 指针与尾节点的距离为 $k-1$,  即 slow 指针指向了链表倒数第 $k$ 个节点。</li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode fast = head, slow = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) </span><br><span class="line">        fast = fast.next;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点
      
    
    </summary>
    
      <category term="刷题" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
      <category term="剑指Offer" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="链表" scheme="965087276.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>程序员面试金典 旋转矩阵</title>
    <link href="965087276.github.io/2020/04/07/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8-%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/"/>
    <id>965087276.github.io/2020/04/07/程序员面试金典-旋转矩阵/</id>
    <published>2020-04-07T01:17:04.000Z</published>
    <updated>2020-05-15T01:35:33.212Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一幅由 <code>N × N</code> 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。<strong>不能使用额外的内存空间</strong></p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">给定 matrix &#x3D; </span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">给定 matrix &#x3D;</span><br><span class="line">[</span><br><span class="line">  [ 5, 1, 9,11],</span><br><span class="line">  [ 2, 4, 8,10],</span><br><span class="line">  [13, 3, 6, 7],</span><br><span class="line">  [15,14,12,16]</span><br><span class="line">], </span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [15,13, 2, 5],</span><br><span class="line">  [14, 3, 4, 1],</span><br><span class="line">  [12, 6, 8, 9],</span><br><span class="line">  [16, 7,10,11]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>转运下面大神的思路</strong></p><blockquote><p><a href="https://leetcode-cn.com/problems/rotate-matrix-lcci/solution/c-tu-jie-yuan-di-cao-zuo-ji-bai-shuang-bai-vv-by-t/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rotate-matrix-lcci/solution/c-tu-jie-yuan-di-cao-zuo-ji-bai-shuang-bai-vv-by-t/</a></p></blockquote><p><strong>来观察下正方形矩阵旋转90度时究竟发生了什么。</strong></p><p><img src="1.gif" alt=""></p><p>观察图中颜色相同的四个位置，当旋转90度后，对应位置的元素发生了顺时针的交换。</p><p>设四个位置中，位于<strong>左上角区域</strong>的位置坐标为 $(i,j)$，则按顺时针顺序，四个位置分别为 $(i,j)$,  $(j, n-i-1)$,  $(n-i-1,n-j-1)$,  $(n-j-1,i)$ </p><p>matrix.size() 为奇数时，位置的对应关系相同，但左上角区域并<strong>不是整个矩阵的四分之一</strong>，如下图示：</p><p><img src="2.png" alt=""></p><p>其实就是<strong>多了中间列的上半部分</strong>。</p><p>那么现在捋一下如何<strong>原地操作元素</strong>：<br>枚举左上区域的所有位置，然后通过上面总结的位置关系直接交换元素。<br>对于一个位置 (i,j)，需要<strong>交换三次</strong>：</p><ol><li><code>swap(matrix[i][j], matrix[j][n-i-1]);</code></li><li><code>swap(matrix[i][j], matrix[n-i-1][n-j-1]);</code></li><li><code>swap(matrix[i][j], matrix[n-j-1][i]);</code></li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 这里行 或 列，谁多出一个都可以。即也可以是 i &lt; (n+1) / 2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i++) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (n + <span class="number">1</span>) / <span class="number">2</span>; j++) &#123;</span><br><span class="line">        swap(matrix[i][j], matrix[j][n-i<span class="number">-1</span>]);</span><br><span class="line">        swap(matrix[i][j], matrix[n-i<span class="number">-1</span>][n-j<span class="number">-1</span>]);</span><br><span class="line">        swap(matrix[i][j], matrix[n-j<span class="number">-1</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给你一幅由 &lt;code&gt;N × N&lt;/code&gt; 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。&lt;
      
    
    </summary>
    
      <category term="刷题" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
      <category term="程序员面试金典" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8/"/>
    
    
      <category term="数组" scheme="965087276.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 42 接雨水</title>
    <link href="965087276.github.io/2020/04/04/LeetCode-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
    <id>965087276.github.io/2020/04/04/LeetCode-42-接雨水/</id>
    <published>2020-04-04T09:16:38.000Z</published>
    <updated>2021-03-29T02:31:15.602Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><img src="1.png" alt=""></p><p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 <strong>感谢 Marcos</strong> 贡献此图。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>根据木桶原理，每根柱子能够承接雨水的数量等于其两边最大高度柱子中的较小者减去当前柱子的高度。</p><p>举个栗子，对于下面的柱子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[4, 3, 1, 2, 5, 4]</span><br></pre></td></tr></table></figure><p>柱子 1 所能承接雨水的数量为 3。计算方法是：分别寻找柱子 1 左右两边高度最高的柱子——柱子 4 和 柱子 5；取两个柱子中高度较小者——柱子 4；柱子 4 的高度减去柱子 1 的高度 得到结果为3。</p><p>因此，问题求解的核心在于，对于数组中的每个元素，如何找到其左右两边元素的最大值。</p><h2 id="思路1-动态规划"><a href="#思路1-动态规划" class="headerlink" title="思路1  动态规划"></a>思路1  动态规划</h2><ul><li>令 <code>left_max[i]​</code>  表示数组 <code>height</code> 中从最左端到下标 i 最高的柱子高度，则 <code>left_max[i]  = max(left_max[i-1], height[i])​</code></li><li>令 <code>right_max[i]​</code> 表示数组 <code>height</code> 中从下标 i 到最右端最高的柱子高度，则  <code>right_max[i] = max(right_max[i+1], height[i])</code></li><li>遍历数组 $height$，将 <code>min(left_max[i], right_max[i]) - height[i]</code> 更新到答案中</li></ul><p>算法时间复杂度为 $O(n)$，空间复杂度为 $O(n)$</p><p><strong>代码如下</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">height</span> == null)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = <span class="built_in">height</span>.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left_max(<span class="built_in">size</span>), right_max(<span class="built_in">size</span>);</span><br><span class="line">    left_max[<span class="number">0</span>] = <span class="built_in">height</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">        left_max[i] = <span class="built_in">max</span>(<span class="built_in">height</span>[i], left_max[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    right_max[<span class="built_in">size</span> - <span class="number">1</span>] = <span class="built_in">height</span>[<span class="built_in">size</span> - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">size</span> - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        right_max[i] = <span class="built_in">max</span>(<span class="built_in">height</span>[i], right_max[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">size</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        ans += <span class="built_in">min</span>(left_max[i], right_max[i]) - <span class="built_in">height</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思路2-双指针"><a href="#思路2-双指针" class="headerlink" title="思路2 双指针"></a>思路2 双指针</h2><p>在上面动态规划的解法中，我们用到了 $left_max, right_max$ 两个数组，但是这两个数组中的每个元素其实我们只使用了一次，也就是说，当我们使用 $left_max[i]$ 时，$left_max[0] \ 至 \ left_max[i-1]$ 都不会再用到了。把这些不会用到的元素也存下来就有些浪费空间了，现在我们就来看一下如何去掉这两个数组。</p><p>先回顾一下两个数组是如何更新的</p><p>$left_max[i] = max(left_max[i-1], height[i])$</p><p>$right_max[i] = max(right_max[i+1], height[i])$</p><p>可以看到：left_max[i] 的值只与 left_max[i-1] 有关，与 left_max[0] 至 left_max[i-2] 的值都无关。设 left_max[i] 是本次遍历中所要计算的最大值，那么 left_max[i-1] 就是遍历所要计算的最大值，因此，我们完全可以只通过left_max这一个变量来维护这一系列的最大值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等号左边的left_max是本次要计算的left_max，相当于left_max[i]</span></span><br><span class="line"><span class="comment">// 等号右边的left_max是前一次遍历中计算的left_max, 相当于left_max[i-1]</span></span><br><span class="line">left_max = <span class="built_in">max</span>(left_max, <span class="built_in">height</span>[i])</span><br></pre></td></tr></table></figure><p>同理，right_max[i] 也可由 right_max 替代</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等号左边的right_max是本次要计算的right_max，相当于right_max[i]</span></span><br><span class="line"><span class="comment">// 等号右边的right_max是前一次遍历中计算的right_max, 相当于right_max[i+1]</span></span><br><span class="line">right_max = <span class="built_in">max</span>(right_max, <span class="built_in">height</span>[i])</span><br></pre></td></tr></table></figure><p>回到我们的题目中来，我们可以使用上面的优化，先将代码中的left_max数组去掉</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">height</span> == null)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = <span class="built_in">height</span>.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right_max(<span class="built_in">size</span>);</span><br><span class="line">    left_max = <span class="built_in">height</span>[<span class="number">0</span>];</span><br><span class="line">    right_max[<span class="built_in">size</span> - <span class="number">1</span>] = <span class="built_in">height</span>[<span class="built_in">size</span> - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">size</span> - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        right_max[i] = <span class="built_in">max</span>(<span class="built_in">height</span>[i], right_max[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">size</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        left_max = <span class="built_in">max</span>(left_max, <span class="built_in">height</span>[i]);</span><br><span class="line">        ans += <span class="built_in">min</span>(left_max, right_max[i]) - <span class="built_in">height</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，right_max数组是否也能直接去掉呢？显然是不行的，因此我们的求解过程是<strong>从左到右</strong>遍历的，left_max数组可以去掉的原因是它的计算过程也是从左到右遍历的，而right_max数组的计算过程是<strong>从右到左</strong>遍历的，因此不能直接去掉。</p><p>也就是说，无论是我们从左往右算，还是从右往左算，都只能去掉两个数组中的一个，那怎么做才能把这两个数组都去掉呢？相信你已经想到了，那就是<strong>既从左往右算，又从右往左算</strong>。</p><p>我们使用两个双指针 left 和 right 分别指向 height 数组的左右端点，同时使用上面的 left_max 和 right_max 分别维护左右两个方向的最大值。</p><p>在思路 1 中，对于位置 left 的柱子，其载水量为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">min</span>(left_max[left], right_max[left]) - <span class="built_in">height</span>[left];</span><br></pre></td></tr></table></figure><p>现在我们可以把两个数组去掉，其结果为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">min</span>(left_max, <span class="built_in">max</span>(<span class="built_in">height</span>[left], <span class="built_in">height</span>[left+<span class="number">1</span>], ... , <span class="built_in">height</span>[right]) ) - <span class="built_in">height</span>[left];</span><br></pre></td></tr></table></figure><p>如果 <code>left_max &lt; height[right]</code>  或是小于这其中的任意一个，那么上式等于 <code>left_max - height[left]</code>。这种情况下，我们不需要遍历 left 位置右边那一堆柱子的高度就可以得到 left 位置的载水量。</p><p>同理，对于位置 right 的柱子，其载水量为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">min</span>(right_max, <span class="built_in">max</span>(<span class="built_in">height</span>[<span class="number">0</span>], <span class="built_in">height</span>[<span class="number">1</span>], ... , <span class="built_in">height</span>[right]) ) - <span class="built_in">height</span>[right];</span><br></pre></td></tr></table></figure><p>如果 <code>right_max &lt; height[0]</code> 或是小于这其中的任意一个，那么上式等于 <code>right_max - height[right]</code>。</p><p>这样我们得到了下面的算法</p><ul><li>使用两个双指针 left 和 right 分别指向 height 数组的左右端点，同时使用上面的 left_max 和 right_max 分别维护左右两个方向的最大值。</li><li>当 left &lt;= right 时<ul><li>更新 <code>left_max = max(left_max, height[left])</code></li><li>更新 <code>right_max = max(right_max, height[right])</code></li><li>如果 <code>left_max &lt;= right_max</code>，根据木桶效应， left 位置的柱子的载水量可以直接算出，结果为 <code>left_max - height[left]</code>。</li><li>如果 <code>right_max &lt;= left_max</code>，根据木桶效应， right 位置的柱子的载水量可以直接算出，结果为 <code>right_max - height[right]</code>。</li><li>更新 left 指针或 right 指针位置，重复以上步骤</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left_max = <span class="number">0</span>, right_max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="built_in">height</span>.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        left_max = <span class="built_in">max</span>(left_max, <span class="built_in">height</span>[left]);</span><br><span class="line">        right_max = <span class="built_in">max</span>(right_max, <span class="built_in">height</span>[right]);</span><br><span class="line">        <span class="keyword">if</span> (left_max &lt; right_max) &#123; <span class="comment">// 右边再大也没用，因为左边是短板</span></span><br><span class="line">            ans += left_max - <span class="built_in">height</span>[left++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// right_max &lt;= left_max // 做百年再大也没用，因为右边是短板</span></span><br><span class="line">            ans += right_max - <span class="built_in">height</span>[right--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定 &lt;em&gt;n&lt;/em&gt; 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。&lt;/p&gt;
&lt;p&gt;&lt;img
      
    
    </summary>
    
      <category term="刷题" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
      <category term="LeetCode" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/LeetCode/"/>
    
    
      <category term="思路" scheme="965087276.github.io/tags/%E6%80%9D%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer 树的子结构</title>
    <link href="965087276.github.io/2020/04/01/%E5%89%91%E6%8C%87Offer-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"/>
    <id>965087276.github.io/2020/04/01/剑指Offer-树的子结构/</id>
    <published>2020-04-01T01:28:14.000Z</published>
    <updated>2020-05-15T01:33:21.407Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>输入两棵完全二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p><p>例如:<br>给定的树 A:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    3  </span><br><span class="line">   &#x2F; \  </span><br><span class="line">  4   5 </span><br><span class="line"> &#x2F; \ </span><br><span class="line">1   2</span><br></pre></td></tr></table></figure><p>给定的树 B：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  4  </span><br><span class="line"> &#x2F; </span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p><p>输入按照完全二叉树的 BFS 遍历顺序输入</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：A &#x3D; [1,2,3], B &#x3D; [3,1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：A &#x3D; [3,4,5,1,2], B &#x3D; [4,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>回顾一下做字符串匹配时的思路。假设我们要判断字符串  <code>B = &quot;cde&quot;</code> 是否是字符串 <code>A = &quot;abcdef&quot;</code> 的子串，那么我们首先要找到 $A$ 中哪个位置的字符与 $B$ 的第一个字符 <code>c</code> 相等，经过这个步骤后，我们找到了子串 <code>A1 = &quot;cdef&quot;</code>；然后，我们需要判断 $B$ 是否是 $A1$ 的前缀，如果是，则说明 $B$ 是 $A$ 的字串，如果不是，那么我们需要最开始的步骤，在 $A$ 中再寻找下一个等于 <code>c</code> 的字符的位置进行判断。</p><p>这道题也是类似，要判断 $B$ 是否是 $A$ 的子树，我们先找到 $A$ 中哪个节点与 $B$ 的根节点相等，然后再判断 $B$ 是否是以该节点为根的树的前缀，如果不是，则再去 $A$ 中找到下一个这样的节点再做判断，以此类推。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="keyword">null</span> || B == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// A.val与B.val相等，判断B是否是A的前缀树</span></span><br><span class="line">        <span class="keyword">if</span> (A.val == B.val &amp;&amp; isPrefix(A, B)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// A.val与B.val不相等 或者 相等但不是前缀，则再去找下一个满足条件的A</span></span><br><span class="line">        <span class="keyword">if</span> (isSubStructure(A.left, B) || isSubStructure(A.right, B)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 判断B是否是A的前缀</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPrefix</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (B == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 空树是A的前缀</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A == <span class="keyword">null</span> || A.val != B.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isPrefix(A.left, B.left) &amp;&amp; isPrefix(A.right, B.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;输入两棵完全二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)&lt;/p&gt;
&lt;p&gt;B是A的子结构， 即 A中有出现和B相同
      
    
    </summary>
    
      <category term="刷题" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
      <category term="剑指Offer" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="二叉树" scheme="965087276.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.824 lab1笔记</title>
    <link href="965087276.github.io/2020/03/31/MIT6-824-lab1%E7%AC%94%E8%AE%B0/"/>
    <id>965087276.github.io/2020/03/31/MIT6-824-lab1笔记/</id>
    <published>2020-03-31T01:04:25.000Z</published>
    <updated>2020-05-31T01:29:05.824Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>这次的 Lab1 是根据 MapReduce 的论文来实现一个简易的 MapReduce 框架，需要具备基本的任务分发和超时任务检测机制。</p><p><img src="1.png" alt=""></p><p>先来回顾一下 MapReduce 的执行过程，论文中将其大致为如下几步</p><ol><li><p><strong>论文：</strong>MapReduce将用户输入分成 M 部分，每部分通常在 16-64MB ，并将用户程序（Map 函数和 Reduce 函数）拷贝到每台机器中。</p><p><strong>本实验：</strong> 在本实验中，有若干个待处理的 txt 文件（pg-*.txt），可以将每个 txt 文件作为一个 Map 任务。同时，Map 函数和 Reduce 函数的代码已经被编译到文件 wc.so 中，各个 Worker 需要读取这个文件将两个函数加载进来。</p></li><li><p><strong>论文：</strong> Master 将任务划分成 M 个 Map 任务和 R 个 Reduce 任务，每次寻找一个空闲的 Worker 将一个任务分配给它。</p><p><strong>本实验</strong>：本实验中，Map 任务的数量和 Reduce 任务的数量都已经事先确定好了。Map 任务的数量就是输入的 txt 文件的数量，Reduce 任务的数量在 master 的入口程序中设定（后面会提到）。在任务分配方面，与论文有所不同，实验中采用的是 Worker 主动向 Master 拉取任务的方式。</p></li><li><p><strong>论文：</strong> 执行 Map 任务的 Worker 读取输入文件，将文件传给 Map 函数，Map 函数解析文件内容并生成 key/value pairs 中间结果。这些中间结果会通过分区函数分成 R 个区域并写入本地磁盘中。Map 任务执行完后，Worker 将 R 个中间文件的回传给 Master，master 会将这些文件的位置传送给 Reduce worker。</p><p><strong>本实验：</strong> 与论文的步骤大致相同</p></li><li><p><strong>论文：</strong> 执行 Reduce 任务的 Worker 通过 RPC 从 Map Worker 所在主机的磁盘上读取这些中间文件，并通过 key 值进行排序，将具有相同 key 值的 key/value pair 传送到同一个 Reduce 任务中。Reduce 任务的输出同样输出到磁盘中。</p><p><strong>本实验：</strong> 由于本实验是使用单机的多个进程来模拟多机的分布式环境，因此 Reduce 任务只需要从本地读取 Map 任务的中间结果即可。</p></li><li><p>任务完成。</p></li></ol><p>下面根据代码详细介绍下这几个步骤</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先设定几个常量，来表示 master 当前所处的阶段（“Map阶段”、“Reduce阶段”或者“已完成”）和 每个任务的状态（未开始、进行中、完成）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// master.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Phase <span class="keyword">int8</span></span><br><span class="line"><span class="keyword">type</span> Status <span class="keyword">int8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line"><span class="comment">// master所处的阶段</span></span><br><span class="line">Phase_Map      = Phase(<span class="number">1</span>)</span><br><span class="line">Phase_Reduce   = Phase(<span class="number">2</span>)</span><br><span class="line">Phase_Complete = Phase(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务状态</span></span><br><span class="line">Status_Idel      = Status(<span class="number">0</span>)</span><br><span class="line">Status_Progess   = Status(<span class="number">1</span>)</span><br><span class="line">Status_Completed = Status(<span class="number">2</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="程序入口"><a href="#程序入口" class="headerlink" title="程序入口"></a>程序入口</h2><p>master 程序和 worker 程序的入口分别为 main 目录下的 mrmaster.go 和 mrworker.go。</p><h3 id="mrmaster-go"><a href="#mrmaster-go" class="headerlink" title="mrmaster.go"></a>mrmaster.go</h3><p>首先来看 mrmaster.go ，mrmaster.go 执行的命令为如下，可以看到 mrmaster.go会读取所有的输入文件作为参数。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> run mrmaster.<span class="keyword">go</span> pg-*.txt</span><br></pre></td></tr></table></figure><p>读取输入参数后，主函数调用 master.go 中的 MakeMaster 函数创建一个 Master 对象，MakeMaster传入的参数有两个，第一个参数为上面的输入文件 “pg-*.txt”，第二个参数为 reduce 任务的个数，这里固定为 10 个。</p><p>创建 Master 对象后，主函数每隔一秒会调用 m.Done() 函数判断 Master的所有任务是否都已完成，如果完成，那么整个流程结束，主程序将退出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mrmaster.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &lt; <span class="number">2</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">"Usage: mrmaster inputfiles...\n"</span>)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// os.Args[1:]为所有的输入文件， 10为reduce任务的个数</span></span><br><span class="line">m := mr.MakeMaster(os.Args[<span class="number">1</span>:], <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> m.Done() == <span class="literal">false</span> &#123;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以先看一下 m.Done() 函数如何实现。前面说到，我们使用了 Phase_Map、Phase_Reduce、Phase_Complete 三个常量表示 Master 当前所处的状态。因此，只需要判断 Master 是否处于 Phase_Complete 状态即可，代码如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Master.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">Done</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// m.Phase表示Master当前的状态，若为Complete状态，则所有任务均已完成</span></span><br><span class="line"><span class="keyword">return</span> m.Phase == Phase_Complete</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mrworker-go"><a href="#mrworker-go" class="headerlink" title="mrworker.go"></a>mrworker.go</h3><p>再来看 mrworker.go，mrworker.go 的执行命令如下，其中 wc.so 文件中包含了具体的 Map 和 Reduce 函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> run mrworker.<span class="keyword">go</span> wc.so</span><br></pre></td></tr></table></figure><p>mrworker.go 通过 loadPlugin 方法加载map函数和reduce函数，然后调用 mr.Worker 方法正式执行。当所有任务都执行完毕时，mrworker.go就会结束。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mrworker.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">2</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">"Usage: mrworker xxx.so\n"</span>)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mapf, reducef := loadPlugin(os.Args[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">mr.Worker(mapf, reducef)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// load the application Map and Reduce functions</span></span><br><span class="line"><span class="comment">// from a plugin file, e.g. ../mrapps/wc.so</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadPlugin</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">func</span>(<span class="keyword">string</span>, <span class="keyword">string</span>)</span> []<span class="title">mr</span>.<span class="title">KeyValue</span>, <span class="title">func</span><span class="params">(<span class="keyword">string</span>, []<span class="keyword">string</span>)</span> <span class="title">string</span>)</span> &#123;</span><br><span class="line">p, err := plugin.Open(filename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"cannot load plugin %v"</span>, filename)</span><br><span class="line">&#125;</span><br><span class="line">xmapf, err := p.Lookup(<span class="string">"Map"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"cannot find Map in %v"</span>, filename)</span><br><span class="line">&#125;</span><br><span class="line">mapf := xmapf.(<span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span> []<span class="title">mr</span>.<span class="title">KeyValue</span>)</span></span><br><span class="line">xreducef, err := p.Lookup(<span class="string">"Reduce"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"cannot find Reduce in %v"</span>, filename)</span><br><span class="line">&#125;</span><br><span class="line">reducef := xreducef.(<span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>, []<span class="keyword">string</span>)</span> <span class="title">string</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> mapf, reducef</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Master-对象初始化"><a href="#Master-对象初始化" class="headerlink" title="Master 对象初始化"></a>Master 对象初始化</h2><p>下面是 Master 对象中相关变量的定义，后面碰到某个变量时会对其详细解释，这里先暂时列出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// master.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Master <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reduce任务的数量</span></span><br><span class="line">NReduce <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// map任务的数量</span></span><br><span class="line">NMap    <span class="keyword">int</span></span><br><span class="line"><span class="comment">// 存放所有的map任务</span></span><br><span class="line">MapTasks []*MapTask</span><br><span class="line"><span class="comment">// 存放所有的reduce任务</span></span><br><span class="line">ReduceTasks []*ReduceTask</span><br><span class="line"><span class="comment">// Master当前所处的阶段</span></span><br><span class="line">Phase Phase</span><br><span class="line"><span class="comment">// map任务channel</span></span><br><span class="line">MapTaskChan    <span class="keyword">chan</span> *MapTask</span><br><span class="line"><span class="comment">// reduce任务channel</span></span><br><span class="line">    ReduceTaskChan <span class="keyword">chan</span> *ReduceTask</span><br><span class="line"><span class="comment">// map任务输出的中间文件的位置，数组大小NMap * NReduce</span></span><br><span class="line">    <span class="comment">// 每个map任务输出NReduce个中间文件</span></span><br><span class="line">IntermediateFiles [][]<span class="keyword">string</span></span><br><span class="line"><span class="comment">// 已完成的map任务的数量</span></span><br><span class="line">NCompleteMap    <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 已完成的reduce任务的数量</span></span><br><span class="line">NCompleteReduce <span class="keyword">int</span></span><br><span class="line"><span class="comment">// 互斥锁</span></span><br><span class="line">mu sync.Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mrmaster.go 通过调用 <code>mr.MakeMaster(os.Args[1:], 10)</code> 函数创建一个Master。</p><p>下面的MakeMaster函数主要做了三件事：1. 初始化 Master 对象的各个变量；2. 调用 m.server() 开启TCP服务监听；3. 初始化 map 任务，这里为了不阻塞 MakeMaster 过程，开启了一个新的线程异步的执行 map 任务的初始化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// master.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeMaster</span><span class="params">(files []<span class="keyword">string</span>, nReduce <span class="keyword">int</span>)</span> *<span class="title">Master</span></span> &#123;</span><br><span class="line">m := Master&#123;&#125;</span><br><span class="line"><span class="comment">// 初始化Master各变量</span></span><br><span class="line">m.NReduce = nReduce</span><br><span class="line">m.MapTasks = <span class="built_in">make</span>([]*MapTask, <span class="number">0</span>)</span><br><span class="line">m.MapTaskChan = <span class="built_in">make</span>(<span class="keyword">chan</span> *MapTask)</span><br><span class="line">m.ReduceTaskChan = <span class="built_in">make</span>(<span class="keyword">chan</span> *ReduceTask)</span><br><span class="line">m.NCompleteMap = <span class="number">0</span></span><br><span class="line">m.NCompleteReduce = <span class="number">0</span></span><br><span class="line">m.IntermediateFiles = <span class="built_in">make</span>([][]<span class="keyword">string</span>, nReduce)</span><br><span class="line">m.NMap = <span class="built_in">len</span>(files)</span><br><span class="line">m.Phase = Phase_Map</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于master和worker之间需要通过RPC来传递任务。因此，需要将两个任务对象注册到RPC中，这样</span></span><br><span class="line">    <span class="comment">// 对方才能够成功的反序列化</span></span><br><span class="line">gob.Register(&amp;MapTask&#123;&#125;)</span><br><span class="line">gob.Register(&amp;ReduceTask&#123;&#125;)</span><br><span class="line">    </span><br><span class="line">m.server()</span><br><span class="line"><span class="comment">// 初始化 Map 任务</span></span><br><span class="line"><span class="keyword">go</span> m.GenerateMapTask(files)</span><br><span class="line">    <span class="keyword">return</span> &amp;m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="详细实现"><a href="#详细实现" class="headerlink" title="详细实现"></a>详细实现</h2><p>下面结合介绍一下整个 lab 的详细实现。有一点要说明一下，下面几小节中各个方法的代码并不是完整的，我会删掉一些与该小节无关的代码以尽量避免干扰。</p><h3 id="一-Map任务的初始化"><a href="#一-Map任务的初始化" class="headerlink" title="一  Map任务的初始化"></a>一  Map任务的初始化</h3><p>首先是 Map 任务的初始化。在最开始，mrmaster.go中会调用MakeMaster 函数生成Master对象，而MakeMaster中会调用 GenerateMapTask 函数进行 map 任务的初始化，每一个 txt 文件为一个 map 任务。</p><p>该函数遍历所有的输入文件，为每个文件生成一个map任务，初始时任务为闲置（未开始）状态，当任务被分配或任务完成后，任务状态会相应的改变。map任务生成后，将其放入 MapTasks 数组存储起来，同时将其放入 MapTaskChan 中用于后面任务的分配。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// master.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map任务初始化，files为所有 "pg-*.txt" 输入文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">GenerateMapTask</span><span class="params">(files []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i, file := <span class="keyword">range</span> files &#123;</span><br><span class="line">mapTask := MapTask&#123;</span><br><span class="line">Id:       i, <span class="comment">// 任务编号</span></span><br><span class="line">FileName: file, <span class="comment">// 文件名称</span></span><br><span class="line">Status:  Status_Idel, <span class="comment">// 任务状态为闲置状态</span></span><br><span class="line">NReduce: m.NReduce, <span class="comment">// reduce任务的数量（等于 map任务输出的中间文件的数量）</span></span><br><span class="line">&#125;</span><br><span class="line">m.MapTasks = <span class="built_in">append</span>(m.MapTasks, &amp;mapTask)</span><br><span class="line"><span class="comment">// 将 map 任务放到 channel 中</span></span><br><span class="line">        m.MapTaskChan &lt;- (&amp;mapTask)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、-Worker向-Master-拉取-Map-任务"><a href="#二、-Worker向-Master-拉取-Map-任务" class="headerlink" title="二、 Worker向 Master 拉取 Map 任务"></a>二、 Worker向 Master 拉取 Map 任务</h3><p>当 Worker 成功启动后，就可以向 Master 发起 RPC 调用来申请任务了。同时，根据 MapReduce 的特性，Master 刚开始分配的任务都是 Map 任务，只有在所有的 Map 任务都执行完毕后才会开始分配 Reduce 任务。本小节只介绍 Map 任务的申请。（为了减少代码的干扰，下面的代码中删去了与 Reduce 任务相关的部分）</p><p>在mrworker.go 中，通过调用 <code>mr.Worker(mapf, reducef)</code> 方法并传入 mapf 和 reducef 两个函数作为参数完成 Worker 对象的创建工作。Worker 创建后，会调用 Run() 方法正式开始工作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Worker对象。因为不能与下面的Worker()方法重名，所以这里用了Work</span></span><br><span class="line"><span class="keyword">type</span> Work <span class="keyword">struct</span> &#123;</span><br><span class="line">Mapf    <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span> []<span class="title">KeyValue</span></span></span><br><span class="line">Reducef <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>, []<span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// main/mrworker.go calls this function.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Worker</span><span class="params">(mapf <span class="keyword">func</span>(<span class="keyword">string</span>, <span class="keyword">string</span>)</span> []<span class="title">KeyValue</span>,</span></span><br><span class="line">reducef <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>, []<span class="keyword">string</span>)</span> <span class="title">string</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">gob.Register(&amp;MapTask&#123;&#125;)</span><br><span class="line">gob.Register(&amp;ReduceTask&#123;&#125;)</span><br><span class="line"></span><br><span class="line">worker := &amp;Work&#123;</span><br><span class="line">Mapf:    mapf,</span><br><span class="line">Reducef: reducef,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 该方法会一直执行，直到master的所有任务均已完成</span></span><br><span class="line">worker.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Worker 开始工作后，首先调用 PullTask() 方法获取一个任务。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Work)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 获取任务</span></span><br><span class="line">        reply := w.PullTask()</span><br><span class="line">        ... ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PullTask() 方法会通过 RPC 调用 Master 的 AssignTask 方法向其申请任务。这里暂不考虑RPC调用失败的情况</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Work)</span> <span class="title">PullTask</span><span class="params">()</span> *<span class="title">PullTaskReply</span></span> &#123;</span><br><span class="line">args := PullTaskArgs&#123;&#125;</span><br><span class="line">reply := PullTaskReply&#123;&#125;</span><br><span class="line">    <span class="comment">// RPC调用，向Master申请任务</span></span><br><span class="line"><span class="keyword">if</span> call(<span class="string">"Master.AssignTask"</span>, &amp;args, &amp;reply) &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;reply</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Master 接收到任务申请的请求后，检查 MapTaskChan 中是否还有空闲的任务。如果存在，则分配该任务并将任务状态修改为 Progress；如果暂时没有空闲的任务可以分配，则返回 nil </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// master.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">AssignTask</span><span class="params">(args *PullTaskArgs, reply *PullTaskReply)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="comment">// 存在空闲的map任务</span></span><br><span class="line">    <span class="keyword">case</span> mapTask := &lt;-m.MapTaskChan:</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Printf(<span class="string">"Assign a mapTask : %v\n"</span>, *mapTask)</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 修改任务状态</span></span><br><span class="line">mapTask.Status = Status_Progess</span><br><span class="line">reply.Task = *mapTask</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Println(<span class="string">"No task to assign"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// No tasks can be assigned</span></span><br><span class="line">reply.Task = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Worker 从 PullTask 中接收到任务后，首先检查任务的状态。如果任务为 nil ，则说明 master 当前没有空闲的任务可以分配，这时候，为了避免 Worker 再频繁的向 Master 申请任务，可以先让 Worker 进程挂起一段时间（Sleep 1s），在这之后，再与 Master 通信。如果成功拿到任务，则调用 RunMapTask() 方法执行 Map 任务。</p><p>这里的 for 循环是个死循环，Worker 执行完一个任务后，可以再向 Master 申请下一个任务。for 循环的退出条件会在后面的 Reduce 任务相关小节说明。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// master.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Work)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">reply := w.PullTask()</span><br><span class="line">        <span class="keyword">if</span> reply.Task == <span class="literal">nil</span> &#123; <span class="comment">// Master暂时分配不到任务，等待1s后继续向Master申请</span></span><br><span class="line">            <span class="keyword">if</span> debug &#123;</span><br><span class="line">                log.Println(<span class="string">"Cannot apply a map Task, wait 1s"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 等待1s</span></span><br><span class="line">            time.Sleep(time.Second)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 执行 map 任务</span></span><br><span class="line">            w.RunMapTask(reply.Task)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、Map-任务执行"><a href="#三、Map-任务执行" class="headerlink" title="三、Map 任务执行"></a>三、Map 任务执行</h3><p>Worker 接收到来自 Master 分配的 Map 任务后，调用 RunMapTask 方法执行 Map 任务。</p><p>这部分代码与 “串行MapReduce示例“的代码基本一致，这里不作过多阐述。需要注意的是，Map任务的输出需要按照分区写入多个文件中，文件的数量与NReduce一致。每个中间文件的名称为 “mr-taskId-partitionId”</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Work)</span> <span class="title">RunMapTask</span><span class="params">(task *MapTask)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Printf(<span class="string">"Receive a map task: %v\n"</span>, *task)</span><br><span class="line">&#125;</span><br><span class="line">file, err := os.Open(task.FileName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"cannot open %v"</span>, task.FileName)</span><br><span class="line">&#125;</span><br><span class="line">content, err := ioutil.ReadAll(file)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"cannot read %v"</span>, task.FileName)</span><br><span class="line">&#125;</span><br><span class="line">file.Close()</span><br><span class="line">kva := w.Mapf(task.FileName, <span class="keyword">string</span>(content))</span><br><span class="line"></span><br><span class="line">sort.Sort(ByKey(kva))</span><br><span class="line"><span class="comment">// 中间结果；将中间结果划分成NReduce个分区存储</span></span><br><span class="line">kvas := <span class="built_in">make</span>([][]KeyValue, task.NReduce)</span><br><span class="line"><span class="comment">// 将中间结果分配到各个分区</span></span><br><span class="line"><span class="keyword">for</span> _, kv := <span class="keyword">range</span> kva &#123;</span><br><span class="line">outK := ihash(kv.Key) % task.NReduce</span><br><span class="line">kvas[outK] = <span class="built_in">append</span>(kvas[outK], kv)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 存储中间结果</span></span><br><span class="line">intermediateFiles := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 将中间结果写到文件中</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; task.NReduce; i++ &#123;</span><br><span class="line">os.Mkdir(<span class="string">"maptmp"</span>, os.ModePerm)</span><br><span class="line">filename := <span class="string">"maptmp/mr-"</span> + strconv.Itoa(task.Id) + <span class="string">"-"</span> + strconv.Itoa(i)</span><br><span class="line">file, _ := os.Create(filename)</span><br><span class="line">enc := json.NewEncoder(file)</span><br><span class="line"><span class="keyword">for</span> _, kv := <span class="keyword">range</span> kvas[i] &#123;</span><br><span class="line">err := enc.Encode(&amp;kv)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"write intermediate file error"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">intermediateFiles = <span class="built_in">append</span>(intermediateFiles, filename)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向Master报告任务</span></span><br><span class="line">w.ReportTaskFinish(task.Id, Phase_Map, intermediateFiles)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Map 任务完成后，调用 ReportTaskFinish 向 Master 报告</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Work)</span> <span class="title">ReportTaskFinish</span><span class="params">(taskId <span class="keyword">int</span>, taskType Phase, intermediates []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">args := ReportTaskFinishArgs&#123;</span><br><span class="line">TaskId:            taskId,</span><br><span class="line">TaskPhase:         taskType,</span><br><span class="line">IntermediateFiles: intermediates,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reply := ReportTaskFinishReply&#123;&#125;</span><br><span class="line">call(<span class="string">"Master.ReportTaskFinish"</span>, &amp;args, &amp;reply)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、Worker-执行完-Map-任务，向-Master-报告"><a href="#四、Worker-执行完-Map-任务，向-Master-报告" class="headerlink" title="四、Worker 执行完 Map 任务，向 Master 报告"></a>四、Worker 执行完 Map 任务，向 Master 报告</h3><p>Master 收到 Worker完成Map任务的消息后，修改这个Map任务的状态（状态变为 Completed 状态），并将Map任务产生的中间文件的位置存储下来。<strong>注意以上所有的修改均需要加锁，以避免不一致的情况。</strong> 同时，Master 还维护了 NCompleteMap 变量记录了当前已完成的Map任务的数量，当所有的Map任务均已经完成时，Master 转为 Reduce 阶段，并初始化 Reduce 任务。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// master.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">ReportTaskFinish</span><span class="params">(args *ReportTaskFinishArgs, reply *ReportTaskFinishReply)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> args.TaskPhase &#123;</span><br><span class="line"><span class="keyword">case</span> Phase_Map: <span class="comment">// Map阶段</span></span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Printf(<span class="string">"Complete map task %d\n"</span>, args.TaskId)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">m.mu.Lock()</span><br><span class="line">m.MapTasks[args.TaskId].Status = Status_Completed</span><br><span class="line">m.NCompleteMap++</span><br><span class="line"><span class="comment">// 添加中间文件的位置</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m.NReduce; i++ &#123;</span><br><span class="line">m.IntermediateFiles[i] = <span class="built_in">append</span>(m.IntermediateFiles[i], args.IntermediateFiles[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 所有Map任务均已完成</span></span><br><span class="line"><span class="keyword">if</span> m.NCompleteMap == m.NMap &#123;</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Println(<span class="string">"All Map Tasks finished"</span>)</span><br><span class="line">&#125;</span><br><span class="line">m.Phase = Phase_Reduce</span><br><span class="line"><span class="comment">// 初始化Reduce任务</span></span><br><span class="line"><span class="keyword">go</span> m.GenerateReduceMap()</span><br><span class="line">&#125;</span><br><span class="line">m.mu.Unlock()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、Master-初始化-Reduce-任务"><a href="#五、Master-初始化-Reduce-任务" class="headerlink" title="五、Master 初始化 Reduce 任务"></a>五、Master 初始化 Reduce 任务</h3><p>每个 Map 任务会输出 NReduce 个中间文件，因此 NMap 个 Map 任务总共输出 NReduce * NMap 个中间文件。在 Reduce 任务阶段，每个Reduce任务负责其中1个分区的所有中间文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// master.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">GenerateReduceMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// IntermediateFiles大小为 NReduce * NMap，即共有 NReduce 个分区</span></span><br><span class="line">    <span class="comment">// 每个reduce任务负责其中1个分区的所有中间文件</span></span><br><span class="line"><span class="keyword">for</span> i, files := <span class="keyword">range</span> m.IntermediateFiles &#123;</span><br><span class="line">reduceTask := ReduceTask&#123;</span><br><span class="line">Id:        i,</span><br><span class="line">FileNames: files,</span><br><span class="line">Status:    Status_Idel,</span><br><span class="line">&#125;</span><br><span class="line">m.ReduceTasks = <span class="built_in">append</span>(m.ReduceTasks, &amp;reduceTask)</span><br><span class="line">m.ReduceTaskChan &lt;- &amp;reduceTask</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六、Worker-向-Master-申请-Reduce-任务"><a href="#六、Worker-向-Master-申请-Reduce-任务" class="headerlink" title="六、Worker 向 Master 申请 Reduce 任务"></a>六、Worker 向 Master 申请 Reduce 任务</h3><p>这部分代码与前一部分基本一致；这里把Reduce任务相关的代码添加上。</p><p>Worker 调用 PullTask 方法向 Master 申请任务，Master 会返回自己当前所处的阶段作为任务标识</p><ul><li>如果 Master 处于 Phase_Complete 阶段，说明所有任务均已完成，此时 Worker 退出</li><li>如果 Master 处于 Phase_Map 阶段，说明拿到的任务为 Map 任务，此时调用 RunMapTask 执行 Map 任务</li><li>如果 Master 处于 Phase_Reduce 阶段，说明拿到的任务为 Reduce 任务，此时调用 RunReduceTask 执行 Reduce 任务</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Work)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">reply := w.PullTask()</span><br><span class="line"><span class="keyword">if</span> reply == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> reply.Master_Phase &#123;</span><br><span class="line"><span class="keyword">case</span> Phase_Complete:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> Phase_Map:</span><br><span class="line"><span class="keyword">if</span> reply.Task == <span class="literal">nil</span> &#123; <span class="comment">// Master 暂时无法分配任务，等待1s后继续申请</span></span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Println(<span class="string">"Cannot apply a map Task, wait 1s"</span>)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">w.RunMapTask(reply.Task.(*MapTask))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> Phase_Reduce:</span><br><span class="line"><span class="keyword">if</span> reply.Task == <span class="literal">nil</span> &#123; <span class="comment">// Master 暂时无法分配任务，等待1s后继续申请</span></span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Println(<span class="string">"Cannot apply a reduce Task, wait 1s"</span>)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">w.RunReduceTask(reply.Task.(*ReduceTask))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PullTask 方法通过 RPC 向 Master 申请任务</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Work)</span> <span class="title">PullTask</span><span class="params">()</span> *<span class="title">PullTaskReply</span></span> &#123;</span><br><span class="line">args := PullTaskArgs&#123;&#125;</span><br><span class="line">reply := PullTaskReply&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> call(<span class="string">"Master.AssignTask"</span>, &amp;args, &amp;reply) &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;reply</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里的 PullTaskReply{} 中的任务既可以是 Map 任务，又可以是 Reduce 任务。因此，在该对象中，使用go中的任意类型 <code>interface{}</code> 来表示任务</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rpc.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PullTaskReply <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 任务对象。interface&#123;&#125;代表任意类型</span></span><br><span class="line">    <span class="comment">// 可以通过 Task.(*MapTask) 或 Task.(*ReduceTask) 转变成 MapTask 或 ReduceTask</span></span><br><span class="line">Task         <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">Master_Phase Phase</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="七、Worker-执行-Reduce-任务"><a href="#七、Worker-执行-Reduce-任务" class="headerlink" title="七、Worker 执行 Reduce 任务"></a>七、Worker 执行 Reduce 任务</h3><p>在Reduce执行阶段，Worker读取Map任务产生的中间文件，调用 Reduce 函数计算后，将结果写入一个最终文件中，文件名为 “mr-out-taskId”。任务执行完成后，向 Master 报告</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Work)</span> <span class="title">RunReduceTask</span><span class="params">(task *ReduceTask)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Printf(<span class="string">"Receive a reduce task: %v\n"</span>, *task)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// map任务产生的中间文件</span></span><br><span class="line">files := task.FileNames</span><br><span class="line">kva := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">for</span> _, fileName := <span class="keyword">range</span> files &#123;</span><br><span class="line">file, err := os.Open(fileName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"cannot open %v"</span>, fileName)</span><br><span class="line">&#125;</span><br><span class="line">dec := json.NewDecoder(file)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">var</span> kv KeyValue</span><br><span class="line"><span class="keyword">if</span> err := dec.Decode(&amp;kv); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">kva[kv.Key] = <span class="built_in">append</span>(kva[kv.Key], kv.Value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 文件名为 "mr-out-taskId"</span></span><br><span class="line">ofile, _ := os.Create(<span class="string">"mr-out-"</span> + strconv.Itoa(task.Id))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> kva &#123;</span><br><span class="line">output := w.Reducef(k, kva[k])</span><br><span class="line">fmt.Fprintf(ofile, <span class="string">"%v %v\n"</span>, k, output)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">w.ReportTaskFinish(task.Id, Phase_Reduce, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="八、Worker-执行完-Reduce-任务，向-Master-报告"><a href="#八、Worker-执行完-Reduce-任务，向-Master-报告" class="headerlink" title="八、Worker 执行完 Reduce 任务，向 Master 报告"></a>八、Worker 执行完 Reduce 任务，向 Master 报告</h3><p>Master 根据 TaskPhase 参数判断 worker 提交的任务的类型。对于 reduce 任务，Master 维护了 NCompleteReduce 变量来表示当前已经完成的 reduce 任务的数量。若所有任务均已完成，Master会转变为 Phase_Completed 阶段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// master.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">ReportTaskFinish</span><span class="params">(args *ReportTaskFinishArgs, reply *ReportTaskFinishReply)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> args.TaskPhase &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> Phase_Map:</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Printf(<span class="string">"Complete map task %d\n"</span>, args.TaskId)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// lock</span></span><br><span class="line">m.mu.Lock()</span><br><span class="line">m.MapTasks[args.TaskId].Status = Status_Completed</span><br><span class="line">m.NCompleteMap++</span><br><span class="line"><span class="comment">// Add the intermediate files</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m.NReduce; i++ &#123;</span><br><span class="line">m.IntermediateFiles[i] = <span class="built_in">append</span>(m.IntermediateFiles[i], args.IntermediateFiles[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// All map tasks are completed</span></span><br><span class="line"><span class="keyword">if</span> m.NCompleteMap == m.NMap &#123;</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Println(<span class="string">"All Map Tasks finished"</span>)</span><br><span class="line">&#125;</span><br><span class="line">m.Phase = Phase_Reduce</span><br><span class="line"><span class="comment">// generate the reduce tasks</span></span><br><span class="line"><span class="keyword">go</span> m.GenerateReduceMap()</span><br><span class="line">&#125;</span><br><span class="line">m.mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> Phase_Reduce:</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Printf(<span class="string">"Complete reduce task %d\n"</span>, args.TaskId)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// lock</span></span><br><span class="line">m.mu.Lock()</span><br><span class="line">m.ReduceTasks[args.TaskId].Status = Status_Completed</span><br><span class="line">m.NCompleteReduce++</span><br><span class="line"><span class="comment">// All Reduce tasks are completed</span></span><br><span class="line"><span class="keyword">if</span> m.NCompleteReduce == m.NReduce &#123;</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Println(<span class="string">"All Reduce Tasks finished"</span>)</span><br><span class="line">&#125;</span><br><span class="line">m.Phase = Phase_Complete</span><br><span class="line">&#125;</span><br><span class="line">m.mu.Unlock()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="九、超时任务监测及重分配"><a href="#九、超时任务监测及重分配" class="headerlink" title="九、超时任务监测及重分配"></a>九、超时任务监测及重分配</h3><p>对于分配出去的每一个任务，Master 都会开启一个新的线程来监测该任务的状态（下面的 <code>go m.MonitorMapTask(mapTask)</code> 或 <code>go m.MonitorReduceTask(reduceTask)</code>）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// master.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">AssignTask</span><span class="params">(args *PullTaskArgs, reply *PullTaskReply)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> mapTask := &lt;-m.MapTaskChan:</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Printf(<span class="string">"Assign a mapTask : %v\n"</span>, *mapTask)</span><br><span class="line">&#125;</span><br><span class="line">mapTask.Status = Status_Progess</span><br><span class="line">reply.Task = *mapTask</span><br><span class="line"><span class="comment">// 监测Map任务</span></span><br><span class="line"><span class="keyword">go</span> m.MonitorMapTask(mapTask)</span><br><span class="line"><span class="keyword">case</span> reduceTask := &lt;-m.ReduceTaskChan:</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Printf(<span class="string">"Assign a reduceTask : %v\n"</span>, *reduceTask)</span><br><span class="line">&#125;</span><br><span class="line">reduceTask.Status = Status_Progess</span><br><span class="line">reply.Task = *reduceTask</span><br><span class="line"><span class="comment">// 监测Reduce任务</span></span><br><span class="line"><span class="keyword">go</span> m.MonitorReduceTask(reduceTask)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Println(<span class="string">"No task to assign"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// No tasks can be assigned</span></span><br><span class="line">reply.Task = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">reply.Master_Phase = m.Phase</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以 <code>go m.MonitorReduceTask(reduceTask)</code> 为例。该方法使用一个 NewTicker 定时器，该定时器相当于一个 channel，每隔 10s，系统会向定时器中发送一条信息。下面的 for 循环持续监测任务的状态，如果超过10s后任务仍未完成，将默认worker已经宕机。此时，这个任务会被设为 Idel 状态并重新加入任务队列 ReduceTaskChan 中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// master.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">MonitorReduceTask</span><span class="params">(task *ReduceTask)</span></span> &#123;</span><br><span class="line"><span class="comment">// timeout = 10s</span></span><br><span class="line">t := time.NewTicker(time.Second * <span class="number">10</span>)</span><br><span class="line"><span class="keyword">defer</span> t.Stop()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="comment">// timeout</span></span><br><span class="line"><span class="keyword">case</span> &lt;-t.C:</span><br><span class="line">m.mu.Lock()</span><br><span class="line">task.Status = Status_Idel</span><br><span class="line">m.ReduceTaskChan &lt;- task</span><br><span class="line">m.mu.Unlock()</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// task finished in 10s</span></span><br><span class="line"><span class="keyword">if</span> task.Status == Status_Completed &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是整个代码的主体部分。所有代码的汇总见下一小节。</p><h2 id="代码汇总"><a href="#代码汇总" class="headerlink" title="代码汇总"></a>代码汇总</h2><p><strong>master.go</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mr</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/gob"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">import</span> <span class="string">"net"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"os"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/rpc"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Phase <span class="keyword">int8</span></span><br><span class="line"><span class="keyword">type</span> Status <span class="keyword">int8</span></span><br><span class="line"><span class="keyword">type</span> MStatus <span class="keyword">int8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line"><span class="comment">// the master's phase</span></span><br><span class="line">Phase_Map      = Phase(<span class="number">1</span>)</span><br><span class="line">Phase_Reduce   = Phase(<span class="number">2</span>)</span><br><span class="line">Phase_Complete = Phase(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// the task's status</span></span><br><span class="line">Status_Idel      = Status(<span class="number">0</span>)</span><br><span class="line">Status_Progess   = Status(<span class="number">1</span>)</span><br><span class="line">Status_Completed = Status(<span class="number">2</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> WorkerMachine <span class="keyword">struct</span> &#123;</span><br><span class="line">Id     <span class="keyword">int64</span></span><br><span class="line">Status Status</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MapTask <span class="keyword">struct</span> &#123;</span><br><span class="line">Id       <span class="keyword">int</span></span><br><span class="line">FileName <span class="keyword">string</span></span><br><span class="line">WorkerId <span class="keyword">int64</span></span><br><span class="line">Status   Status</span><br><span class="line">NReduce  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReduceTask <span class="keyword">struct</span> &#123;</span><br><span class="line">Id        <span class="keyword">int</span></span><br><span class="line">FileNames []<span class="keyword">string</span></span><br><span class="line">WorkerId  <span class="keyword">int64</span></span><br><span class="line">Status    Status</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Master <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The number of reduce tasks</span></span><br><span class="line">NReduce <span class="keyword">int</span></span><br><span class="line"><span class="comment">// The number of map tasks</span></span><br><span class="line">NMap <span class="keyword">int</span></span><br><span class="line"><span class="comment">// array of map tasks</span></span><br><span class="line">MapTasks []*MapTask</span><br><span class="line"><span class="comment">// array of reduce tasks</span></span><br><span class="line">ReduceTasks []*ReduceTask</span><br><span class="line"><span class="comment">// the master's phase : map, reduce or complete</span></span><br><span class="line">Phase Phase</span><br><span class="line"><span class="comment">// the channel of map task</span></span><br><span class="line">MapTaskChan <span class="keyword">chan</span> *MapTask</span><br><span class="line"><span class="comment">// the channel of reduce task</span></span><br><span class="line">ReduceTaskChan <span class="keyword">chan</span> *ReduceTask</span><br><span class="line"><span class="comment">// the location of intermediate files for map tasks.  size = NMap * NReduce</span></span><br><span class="line">IntermediateFiles [][]<span class="keyword">string</span></span><br><span class="line"><span class="comment">// the number of map tasks which has completed</span></span><br><span class="line">NCompleteMap <span class="keyword">int</span></span><br><span class="line"><span class="comment">// the number of reduce tasks which has completed</span></span><br><span class="line">NCompleteReduce <span class="keyword">int</span></span><br><span class="line"><span class="comment">// mutex lock</span></span><br><span class="line">mu sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// start a thread that listens for RPCs from worker.go</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">server</span><span class="params">()</span></span> &#123;</span><br><span class="line">rpc.Register(m)</span><br><span class="line">rpc.HandleHTTP()</span><br><span class="line"><span class="comment">//l, e := net.Listen("tcp", ":1234")</span></span><br><span class="line">sockname := masterSock()</span><br><span class="line">os.Remove(sockname)</span><br><span class="line">l, e := net.Listen(<span class="string">"unix"</span>, sockname)</span><br><span class="line"><span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"listen error:"</span>, e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> http.Serve(l, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">GenerateMapTask</span><span class="params">(files []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i, file := <span class="keyword">range</span> files &#123;</span><br><span class="line">mapTask := MapTask&#123;</span><br><span class="line">Id:       i,</span><br><span class="line">FileName: file,</span><br><span class="line">Status:   Status_Idel,</span><br><span class="line">NReduce:  m.NReduce,</span><br><span class="line">&#125;</span><br><span class="line">m.MapTasks = <span class="built_in">append</span>(m.MapTasks, &amp;mapTask)</span><br><span class="line">m.MapTaskChan &lt;- &amp;mapTask</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">GenerateReduceMap</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i, files := <span class="keyword">range</span> m.IntermediateFiles &#123;</span><br><span class="line">reduceTask := ReduceTask&#123;</span><br><span class="line">Id:        i,</span><br><span class="line">FileNames: files,</span><br><span class="line">Status:    Status_Idel,</span><br><span class="line">&#125;</span><br><span class="line">m.ReduceTasks = <span class="built_in">append</span>(m.ReduceTasks, &amp;reduceTask)</span><br><span class="line">m.ReduceTaskChan &lt;- &amp;reduceTask</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">AssignTask</span><span class="params">(args *PullTaskArgs, reply *PullTaskReply)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> mapTask := &lt;-m.MapTaskChan:</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Printf(<span class="string">"Assign a mapTask : %v\n"</span>, *mapTask)</span><br><span class="line">&#125;</span><br><span class="line">mapTask.Status = Status_Progess</span><br><span class="line">reply.Task = *mapTask</span><br><span class="line"><span class="comment">// monitor the task</span></span><br><span class="line"><span class="keyword">go</span> m.MonitorMapTask(mapTask)</span><br><span class="line"><span class="keyword">case</span> reduceTask := &lt;-m.ReduceTaskChan:</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Printf(<span class="string">"Assign a reduceTask : %v\n"</span>, *reduceTask)</span><br><span class="line">&#125;</span><br><span class="line">reduceTask.Status = Status_Progess</span><br><span class="line">reply.Task = *reduceTask</span><br><span class="line"><span class="comment">// monitor the task</span></span><br><span class="line"><span class="keyword">go</span> m.MonitorReduceTask(reduceTask)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Println(<span class="string">"No task to assign"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// No tasks can be assigned</span></span><br><span class="line">reply.Task = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">reply.Master_Phase = m.Phase</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">ReportTaskFinish</span><span class="params">(args *ReportTaskFinishArgs, reply *ReportTaskFinishReply)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> args.TaskPhase &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> Phase_Map:</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Printf(<span class="string">"Complete map task %d\n"</span>, args.TaskId)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// lock</span></span><br><span class="line">m.mu.Lock()</span><br><span class="line">m.MapTasks[args.TaskId].Status = Status_Completed</span><br><span class="line">m.NCompleteMap++</span><br><span class="line"><span class="comment">// Add the intermediate files</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m.NReduce; i++ &#123;</span><br><span class="line">m.IntermediateFiles[i] = <span class="built_in">append</span>(m.IntermediateFiles[i], args.IntermediateFiles[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// All map tasks are completed</span></span><br><span class="line"><span class="keyword">if</span> m.NCompleteMap == m.NMap &#123;</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Println(<span class="string">"All Map Tasks finished"</span>)</span><br><span class="line">&#125;</span><br><span class="line">m.Phase = Phase_Reduce</span><br><span class="line"><span class="comment">// generate the reduce tasks</span></span><br><span class="line"><span class="keyword">go</span> m.GenerateReduceMap()</span><br><span class="line">&#125;</span><br><span class="line">m.mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> Phase_Reduce:</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Printf(<span class="string">"Complete reduce task %d\n"</span>, args.TaskId)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// lock</span></span><br><span class="line">m.mu.Lock()</span><br><span class="line">m.ReduceTasks[args.TaskId].Status = Status_Completed</span><br><span class="line">m.NCompleteReduce++</span><br><span class="line"><span class="comment">// All Reduce tasks are completed</span></span><br><span class="line"><span class="keyword">if</span> m.NCompleteReduce == m.NReduce &#123;</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Println(<span class="string">"All Reduce Tasks finished"</span>)</span><br><span class="line">&#125;</span><br><span class="line">m.Phase = Phase_Complete</span><br><span class="line">&#125;</span><br><span class="line">m.mu.Unlock()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">MonitorMapTask</span><span class="params">(task *MapTask)</span></span> &#123;</span><br><span class="line"><span class="comment">// timeout = 10s</span></span><br><span class="line">t := time.NewTicker(time.Second * <span class="number">10</span>)</span><br><span class="line"><span class="keyword">defer</span> t.Stop()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="comment">// timeout</span></span><br><span class="line"><span class="keyword">case</span> &lt;-t.C:</span><br><span class="line">m.mu.Lock()</span><br><span class="line">task.Status = Status_Idel</span><br><span class="line">m.MapTaskChan &lt;- task</span><br><span class="line">m.mu.Unlock()</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// task finished in 10s</span></span><br><span class="line"><span class="keyword">if</span> task.Status == Status_Completed &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">MonitorReduceTask</span><span class="params">(task *ReduceTask)</span></span> &#123;</span><br><span class="line"><span class="comment">// timeout = 10s</span></span><br><span class="line">t := time.NewTicker(time.Second * <span class="number">10</span>)</span><br><span class="line"><span class="keyword">defer</span> t.Stop()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="comment">// timeout</span></span><br><span class="line"><span class="keyword">case</span> &lt;-t.C:</span><br><span class="line">m.mu.Lock()</span><br><span class="line">task.Status = Status_Idel</span><br><span class="line">m.ReduceTaskChan &lt;- task</span><br><span class="line">m.mu.Unlock()</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// task finished in 10s</span></span><br><span class="line"><span class="keyword">if</span> task.Status == Status_Completed &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// main/mrmaster.go calls Done() periodically to find out</span></span><br><span class="line"><span class="comment">// if the entire job has finished.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">Done</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> m.Phase == Phase_Complete</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// create a Master.</span></span><br><span class="line"><span class="comment">// main/mrmaster.go calls this function.</span></span><br><span class="line"><span class="comment">// nReduce is the number of reduce tasks to use.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeMaster</span><span class="params">(files []<span class="keyword">string</span>, nReduce <span class="keyword">int</span>)</span> *<span class="title">Master</span></span> &#123;</span><br><span class="line">m := Master&#123;&#125;</span><br><span class="line"></span><br><span class="line">m.NReduce = nReduce</span><br><span class="line">m.MapTasks = <span class="built_in">make</span>([]*MapTask, <span class="number">0</span>)</span><br><span class="line">m.MapTaskChan = <span class="built_in">make</span>(<span class="keyword">chan</span> *MapTask)</span><br><span class="line">m.ReduceTaskChan = <span class="built_in">make</span>(<span class="keyword">chan</span> *ReduceTask)</span><br><span class="line">m.NCompleteMap = <span class="number">0</span></span><br><span class="line">m.NCompleteReduce = <span class="number">0</span></span><br><span class="line">m.IntermediateFiles = <span class="built_in">make</span>([][]<span class="keyword">string</span>, nReduce)</span><br><span class="line">m.NMap = <span class="built_in">len</span>(files)</span><br><span class="line">m.Phase = Phase_Map</span><br><span class="line"></span><br><span class="line">gob.Register(&amp;MapTask&#123;&#125;)</span><br><span class="line">gob.Register(&amp;ReduceTask&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// generate the map task</span></span><br><span class="line"><span class="keyword">go</span> m.GenerateMapTask(files)</span><br><span class="line">m.server()</span><br><span class="line"><span class="keyword">return</span> &amp;m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>worker.go</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mr</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/gob"</span></span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"sort"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">import</span> <span class="string">"log"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/rpc"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"hash/fnv"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Map functions return a slice of KeyValue.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">type</span> KeyValue <span class="keyword">struct</span> &#123;</span><br><span class="line">Key   <span class="keyword">string</span></span><br><span class="line">Value <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for sorting by key.</span></span><br><span class="line"><span class="keyword">type</span> ByKey []KeyValue</span><br><span class="line"></span><br><span class="line"><span class="comment">// for sorting by key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByKey)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(a) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByKey)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; a[i], a[j] = a[j], a[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByKey)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> a[i].Key &lt; a[j].Key &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// use ihash(key) % NReduce to choose the reduce</span></span><br><span class="line"><span class="comment">// task number for each KeyValue emitted by Map.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ihash</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">h := fnv.New32a()</span><br><span class="line">h.Write([]<span class="keyword">byte</span>(key))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">int</span>(h.Sum32() &amp; <span class="number">0x7fffffff</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Work <span class="keyword">struct</span> &#123;</span><br><span class="line">Id      <span class="keyword">int64</span></span><br><span class="line">Mapf    <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span> []<span class="title">KeyValue</span></span></span><br><span class="line">Reducef <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>, []<span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// main/mrworker.go calls this function.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Worker</span><span class="params">(mapf <span class="keyword">func</span>(<span class="keyword">string</span>, <span class="keyword">string</span>)</span> []<span class="title">KeyValue</span>,</span></span><br><span class="line">reducef <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>, []<span class="keyword">string</span>)</span> <span class="title">string</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">gob.Register(&amp;MapTask&#123;&#125;)</span><br><span class="line">gob.Register(&amp;ReduceTask&#123;&#125;)</span><br><span class="line"></span><br><span class="line">worker := &amp;Work&#123;</span><br><span class="line">Mapf:    mapf,</span><br><span class="line">Reducef: reducef,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">worker.Run()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Work)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">reply := w.PullTask()</span><br><span class="line"><span class="keyword">if</span> reply == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> reply.Master_Phase &#123;</span><br><span class="line"><span class="keyword">case</span> Phase_Complete:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> Phase_Map:</span><br><span class="line"><span class="keyword">if</span> reply.Task == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Println(<span class="string">"Cannot apply a map Task, wait 1s"</span>)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">w.RunMapTask(reply.Task.(*MapTask))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> Phase_Reduce:</span><br><span class="line"><span class="keyword">if</span> reply.Task == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Println(<span class="string">"Cannot apply a reduce Task, wait 1s"</span>)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">w.RunReduceTask(reply.Task.(*ReduceTask))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Work)</span> <span class="title">PullTask</span><span class="params">()</span> *<span class="title">PullTaskReply</span></span> &#123;</span><br><span class="line">args := PullTaskArgs&#123;&#125;</span><br><span class="line">reply := PullTaskReply&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> call(<span class="string">"Master.AssignTask"</span>, &amp;args, &amp;reply) &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;reply</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Work)</span> <span class="title">RunMapTask</span><span class="params">(task *MapTask)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Printf(<span class="string">"Receive a map task: %v\n"</span>, *task)</span><br><span class="line">&#125;</span><br><span class="line">file, err := os.Open(task.FileName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"cannot open %v"</span>, task.FileName)</span><br><span class="line">&#125;</span><br><span class="line">content, err := ioutil.ReadAll(file)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"cannot read %v"</span>, task.FileName)</span><br><span class="line">&#125;</span><br><span class="line">file.Close()</span><br><span class="line">kva := w.Mapf(task.FileName, <span class="keyword">string</span>(content))</span><br><span class="line"></span><br><span class="line">sort.Sort(ByKey(kva))</span><br><span class="line"></span><br><span class="line">kvas := <span class="built_in">make</span>([][]KeyValue, task.NReduce)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, kv := <span class="keyword">range</span> kva &#123;</span><br><span class="line">outK := ihash(kv.Key) % task.NReduce</span><br><span class="line">kvas[outK] = <span class="built_in">append</span>(kvas[outK], kv)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">intermediateFiles := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; task.NReduce; i++ &#123;</span><br><span class="line">os.Mkdir(<span class="string">"maptmp"</span>, os.ModePerm)</span><br><span class="line">filename := <span class="string">"maptmp/mr-"</span> + strconv.Itoa(task.Id) + <span class="string">"-"</span> + strconv.Itoa(i)</span><br><span class="line">file, _ := os.Create(filename)</span><br><span class="line">enc := json.NewEncoder(file)</span><br><span class="line"><span class="keyword">for</span> _, kv := <span class="keyword">range</span> kvas[i] &#123;</span><br><span class="line">err := enc.Encode(&amp;kv)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"write intermediate file error"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">intermediateFiles = <span class="built_in">append</span>(intermediateFiles, filename)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">w.ReportTaskFinish(task.Id, Phase_Map, intermediateFiles)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Work)</span> <span class="title">RunReduceTask</span><span class="params">(task *ReduceTask)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> debug &#123;</span><br><span class="line">log.Printf(<span class="string">"Receive a reduce task: %v\n"</span>, *task)</span><br><span class="line">&#125;</span><br><span class="line">files := task.FileNames</span><br><span class="line">kva := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">for</span> _, fileName := <span class="keyword">range</span> files &#123;</span><br><span class="line">file, err := os.Open(fileName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"cannot open %v"</span>, fileName)</span><br><span class="line">&#125;</span><br><span class="line">dec := json.NewDecoder(file)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">var</span> kv KeyValue</span><br><span class="line"><span class="keyword">if</span> err := dec.Decode(&amp;kv); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">kva[kv.Key] = <span class="built_in">append</span>(kva[kv.Key], kv.Value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ofile, _ := os.Create(<span class="string">"mr-out-"</span> + strconv.Itoa(task.Id))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> kva &#123;</span><br><span class="line">output := w.Reducef(k, kva[k])</span><br><span class="line">fmt.Fprintf(ofile, <span class="string">"%v %v\n"</span>, k, output)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">w.ReportTaskFinish(task.Id, Phase_Reduce, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Work)</span> <span class="title">ReportTaskFinish</span><span class="params">(taskId <span class="keyword">int</span>, taskType Phase, intermediates []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">args := ReportTaskFinishArgs&#123;</span><br><span class="line">TaskId:            taskId,</span><br><span class="line">TaskPhase:         taskType,</span><br><span class="line">IntermediateFiles: intermediates,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reply := ReportTaskFinishReply&#123;&#125;</span><br><span class="line">call(<span class="string">"Master.ReportTaskFinish"</span>, &amp;args, &amp;reply)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// send an RPC request to the master, wait for the response.</span></span><br><span class="line"><span class="comment">// usually returns true.</span></span><br><span class="line"><span class="comment">// returns false if something goes wrong.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">call</span><span class="params">(rpcname <span class="keyword">string</span>, args <span class="keyword">interface</span>&#123;&#125;, reply <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">// c, err := rpc.DialHTTP("tcp", "127.0.0.1"+":1234")</span></span><br><span class="line">sockname := masterSock()</span><br><span class="line">c, err := rpc.DialHTTP(<span class="string">"unix"</span>, sockname)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"dialing:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> c.Close()</span><br><span class="line"></span><br><span class="line">err = c.Call(rpcname, args, reply)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>rpc.go</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mr</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// RPC definitions.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// remember to capitalize all names.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"os"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"strconv"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PullTaskArgs <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//Id int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PullTaskReply <span class="keyword">struct</span> &#123;</span><br><span class="line">Task         <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">Master_Phase Phase</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReportTaskFinishArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">TaskId            <span class="keyword">int</span></span><br><span class="line">TaskPhase         Phase</span><br><span class="line">IntermediateFiles []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReportTaskFinishReply <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cook up a unique-ish UNIX-domain socket name</span></span><br><span class="line"><span class="comment">// in /var/tmp, for the master.</span></span><br><span class="line"><span class="comment">// Can't use the current directory since</span></span><br><span class="line"><span class="comment">// Athena AFS doesn't support UNIX-domain sockets.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">masterSock</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">s := <span class="string">"/var/tmp/824-mr-"</span></span><br><span class="line">s += strconv.Itoa(os.Getuid())</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;这次的 Lab1 是根据 MapReduce 的论文来实现一个简易的 MapReduce 框架，需要具备基本的任务分发和超时任务检测机制。&lt;
      
    
    </summary>
    
      <category term="课程学习" scheme="965087276.github.io/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="MIT 6.824" scheme="965087276.github.io/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/MIT-6-824/"/>
    
    
      <category term="MIT 6.824" scheme="965087276.github.io/tags/MIT-6-824/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer-正则表达式匹配</title>
    <link href="965087276.github.io/2020/03/27/%E5%89%91%E6%8C%87Offer-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
    <id>965087276.github.io/2020/03/27/剑指Offer-正则表达式匹配/</id>
    <published>2020-03-27T15:08:09.000Z</published>
    <updated>2020-05-15T01:34:05.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>请实现一个函数用来匹配包含<code>&#39;. &#39;</code>和<code>&#39;*&#39;</code>的正则表达式。模式中的字符<code>&#39;.&#39;</code>表示任意一个字符，而<code>&#39;*&#39;</code>表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串<code>&quot;aaa&quot;</code>与模式<code>&quot;a.a&quot;</code>和<code>&quot;ab*ac*a&quot;</code>匹配，但与<code>&quot;aa.a&quot;</code>和<code>&quot;ab*a&quot;</code>均不匹配。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#39;*&#39; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#39;a&#39;。因此，字符串 &quot;aa&quot; 可被视为 &#39;a&#39; 重复了一次。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;ab&quot;</span><br><span class="line">p &#x3D; &quot;.*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: &quot;.*&quot; 表示可匹配零个或多个（&#39;*&#39;）任意字符（&#39;.&#39;）。</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aab&quot;</span><br><span class="line">p &#x3D; &quot;c*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#39;*&#39; 表示零个或多个，这里 &#39;c&#39; 为 0 个, &#39;a&#39; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br></pre></td></tr></table></figure><p><strong>示例 5:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;mississippi&quot;</span><br><span class="line">p &#x3D; &quot;mis*is*p*.&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>令 $dp[i][j]$ 表示串 $s$ 的前 $i$ 个字符和串 $p$ 的前 $j$ 个字符是否匹配（这里的 $i, j &gt;= 1$）。分为下面三种情况</p><ol><li><p>串 $p$ 的第 $j$ 个字符 $p[j-1]$ 为普通字符（不是 <code>. 或 *</code> ）</p><p>这时候 <code>dp[i][j]</code> 成立 的条件是 <code>dp[i-1][j-1] == true and s[i-1] == p[j-1]</code></p></li><li><p>串 $p$ 的第 $j$ 个字符  <code>p[j-1] == &#39;.&#39;</code> </p><p>这时候匹配的条件是 <code>dp[i-1][j-1] == true</code></p></li><li><p>串 $p$ 的第 $j$ 个字符  <code>p[j-1] == &#39;*&#39;</code> </p><p>设 <code>*</code> 前面的字符为 $x$, 这时候要再分为两种情况</p><ol><li><p><code>x*</code> 不去和串 $s$ 匹配</p><p>这时候 <code>dp[i][j]</code> 成立的条件是 <code>dp[i][j-2] == true</code></p></li><li><p><code>x*</code> 和串 $s$ 匹配</p><p>这时候 <code>dp[i][j]</code> 成立的条件是 <code>dp[i-1][j] == true and (s[i] == p[j-1] or p[j-1] == &#39;.&#39;)</code></p></li></ol></li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = s.length(), len2 = p.length();</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 处理 s = ""  p = "a*b*" 这种情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len2; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[j] == <span class="string">'*'</span>) dp[<span class="number">0</span>][j+<span class="number">1</span>] = dp[<span class="number">0</span>][j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len2; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[j] != <span class="string">'*'</span>) &#123;</span><br><span class="line">            dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = (dp[i][j] &amp;&amp; (s[i] == p[j] || p[j] == <span class="string">'.'</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// x* 不去和 s 匹配</span></span><br><span class="line">            dp[i+<span class="number">1</span>][j+<span class="number">1</span>] |= dp[i+<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">            <span class="comment">// x* 去和 s 匹配</span></span><br><span class="line">            dp[i+<span class="number">1</span>][j+<span class="number">1</span>] |= (dp[i][j+<span class="number">1</span>] &amp;&amp; (s[i] == p[j<span class="number">-1</span>] || p[j<span class="number">-1</span>] == <span class="string">'.'</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len1][len2];</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;请实现一个函数用来匹配包含&lt;code&gt;&amp;#39;. &amp;#39;&lt;/code&gt;和&lt;code&gt;&amp;#39;*&amp;#39;&lt;/code&gt;的正则表达式。
      
    
    </summary>
    
      <category term="刷题" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
      <category term="剑指Offer" scheme="965087276.github.io/categories/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87Offer/"/>
    
    
      <category term="动态规划" scheme="965087276.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
</feed>
